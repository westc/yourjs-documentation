{
  "base": "/**\n * @preserve YourJS v{{VERSION}} - Your Very Own JS Library\n * http://yourjs.com\n *\n * Copyright (c) 2015-{{CURRENT_YEAR}} Christopher West\n * Licensed under the MIT license.\n */\n(function(__VERSION, __VARIABLE_NAME, undefined) {\n  var YourJS,\n      __GLOBAL = this,\n      __EMPTY_ARRAY = [],\n      __EMPTY_OBJECT = {},\n      __DOCUMENT = __GLOBAL.document,\n      __callsAfterDefs = [];\n  \n  /*{DEFINITIONS}*/\n\n  /**\n   * YourJS object.\n   * @name {{VARIABLE_NAME}}\n   * @namespace\n   * @global\n   */\n  YourJS = /*{MEMBERS_OBJECT}*/;\n\n  __callsAfterDefs.forEach(function(fn) { fn(); });\n\n  // Add to browser/node environment correctly.\n  if(typeof exports !== 'undefined') {\n    if(typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = YourJS;\n    }\n    (exports[__VARIABLE_NAME] = YourJS)[__VARIABLE_NAME] = undefined;\n  } \n  else {\n    __GLOBAL[__VARIABLE_NAME] = YourJS;\n  }\n})(/*{VERSION}*/, /*{VARIABLE_NAME}*/);\n",
  "version": "2.21.0",
  "parts": [
    {
      "name": "add",
      "code": "",
      "description": "Finds the sum of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be added to `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to be added to `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given the sum of the two will be returned.  Otherwise a partial function will be returned which when called will accept one number and will return the number passed to the partial function added to `number1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "after",
      "code": "",
      "description": "Finds the substring after a specific target.",
      "params": [
        {
          "name": "subject",
          "description": "The string to search.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "The target to find and key off of within `subject`.",
          "type": "string|RegExp"
        },
        {
          "name": "opt_occurrence",
          "description": "The occurrence of `target` that you want to key off of within `subject`. If negative, the occurrence will be counted from the end of `subject`.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "string|null",
        "description": "Returns the string found after `target`. If `target` was not found or the specified occurrence (`opt_occurrence`) of `target` was not found, `null` will be returned."
      },
      "requires": [
        "around"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "afterAll",
      "code": "function afterAll(objects, binder, callback) {\n  objects = objects.slice();\n  var arr = [], result = [], callsLeft = objects.length;\n  objects.forEach(function(object, index) {\n    result[index] = false;\n    function registerAction() {\n      if (callsLeft) {\n        if (!arr[index]) {\n          callsLeft--;\n        }\n        result[index] = true;\n        arr[index] = { arguments: arguments, timeStamp: +new Date };\n        if (!callsLeft) {\n          callback(objects, arr);\n        }\n      }\n    }\n    if ('function' === typeof binder) {\n      binder(registerAction, object, index);\n    }\n    else {\n      binder.forEach(function(eventName) {\n        object.addEventListener(eventName, registerAction);\n      });\n    }\n  });\n  return result;\n}",
      "description": "Calls a function after all of the objects in an array have had an action carried out.",
      "params": [
        {
          "name": "objects",
          "description": "Array of objects for which a function is sure to be called.",
          "type": "Array"
        },
        {
          "name": "binder",
          "description": "If this is a function it will be called for each object in `objects` and will be passed (1) a function that is to be called when action is to be taken (eg. on an event), (2) an object from `objects` and (3) the corresponding index of that object from `objects`.  Call If this is an array of strings the strings will be treated as event names that will be listened to.",
          "type": "Function|Array<string>"
        },
        {
          "name": "callback",
          "description": "Function to be called once either action was taken for all of the objects in `objects`.  If `binder` is an array of strings this means once at least one of the events was called for each object in `objects`.  This function will be called with (1) a copy of `objects` and (2) an array of objects that will have a `arguments` property containing the arguments passed when the action was taken and a `timeStamp` property containing the epoch value of when the action was taken.  The objects in the second argument passed will always correspond to the objects in the first argument.",
          "type": "Function"
        }
      ],
      "return": {
        "type": "Array<boolean>",
        "description": "Returns an array of booleans each one indicating if the corresponding object from `objects` has had an action take place."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "alias",
      "code": "function alias(context, name) { return context[name].bind(context); }",
      "description": "Binds a context to a given function within that context.",
      "params": [
        {
          "name": "context",
          "description": "Context object containing the function to be called.",
          "type": "Object"
        },
        {
          "name": "name",
          "description": "Name of the function to call within the context.",
          "type": "string"
        }
      ],
      "return": {
        "description": "Function that when called will execute the function with the given name under the given context.",
        "type": "Function"
      },
      "requires": [],
      "tests": [
        {
          "name": "Array slicer",
          "code": "var sliceArray = YourJS.alias([].slice, 'call');\ntest(sliceArray([3,4,5,6,7,8,9], 2, -3).join(','), [3,4,5,6,7,8,9].slice(2, -3).join(','));"
        }
      ],
      "required": false
    },
    {
      "name": "andBits",
      "code": "",
      "description": "Finds the bitwise `and` of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be `and`ed against `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to be `and`ed against `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given a bitwise `and` will be executed on both and returned.  Otherwise a partial function will be returned which when called will accept one number and will return a number which is the result of using bitwise `and` on `number1` and the number passed to this partial function."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "applyOf",
      "code": "",
      "description": "Gets the `apply()` function for the specified function.",
      "params": [
        {
          "name": "fn",
          "description": "The function or the function name for which to get the `apply()` function.",
          "type": "Function|string"
        },
        {
          "name": "opt_owner",
          "description": "If `fn` is a string then this will be used as the parent object to reference the actual function.",
          "type": "Object",
          "optional": true
        },
        {
          "name": "opt_objThis",
          "description": "If given this will be the value that is always used as the `this` keyword by `fn` (the function).  If not given, the first argument passed to the returned function will be referenced as the `this` keyword.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "Function",
        "description": "If `opt_objThis` is not passed, a version of `apply()` will be returned which will use the first argument as the `this` keyword and the subsequent argument (which should be an array or an array-like object) as the normal arguments.  Otherwise a function which accepts only the array of arguments (not the `this` keyword definition) will be returned."
      },
      "requires": [
        "callOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var slice = YourJS.applyOf('slice', []);\nvar arr = slice([1,2,3,4,5,6,7], [1, -1]);\nvar arrCheck = [2,3,4,5,6];\ntest(JSON.stringify(arr), JSON.stringify(arrCheck));"
        },
        {
          "name": "All Args",
          "code": "var slice = YourJS.applyOf(Array.prototype.slice, null, [1,2,3,4,5,6,7]);\nvar arr = slice([1, -1]);\nvar arrCheck = [2,3,4,5,6];\ntest(JSON.stringify(arr), JSON.stringify(arrCheck));"
        }
      ]
    },
    {
      "name": "around",
      "code": "var around = Function('P,T,M,Q', 'return[ , [0], [1]]'.replace(/ ([^,]{3})?/g, 'function(a,b,d){var e,c=[];d=P(d||1,10);b=(T(b)===\"RegExp\"?M:Q)(b,\"g\");a.replace(b,function(a,b){e=arguments;c.push([b=e[e.length-2],a.length+b])});a=(c=c[d+(0<d?-1:c.length)])?[a.slice(0,c[0]),a.slice(c[1])]:[null,null];return a$1}'))(parseInt, typeOf, modRegExp, quoteRegExp),\n    before = around[1],\n    after = around[2];\naround = around[0];",
      "description": "Gets the substrings around a specific target.",
      "params": [
        {
          "name": "subject",
          "description": "The string to search.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "The target to find and key off of within `subject`.",
          "type": "string|RegExp"
        },
        {
          "name": "opt_occurrence",
          "description": "The occurrence of `target` that you want to key off of within `subject`. If negative, the occurrence will be counted from the end of `subject`.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array",
        "description": "Returns an array with two values: the string found before `target` and the string found after `target`. If `target` was not found or the specified occurrence (`opt_occurrence`) of `target` was not found, `[null, null]` will be returned."
      },
      "requires": [
        "typeOf",
        "modRegExp",
        "quoteRegExp",
        "before",
        "after"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "array",
      "code": "function array(length, opt_filler, opt_callFiller) {\n  opt_callFiller = !!opt_callFiller && 'function' === typeof opt_filler;\n  for (var result = Array(length), i = 0; i < length; i++) {\n    result[i] = opt_callFiller ? opt_filler(i) : opt_filler;\n  }\n  return result;\n}",
      "description": "Creates a new array with the given length and fills the array with the given value.",
      "params": [
        {
          "name": "length",
          "description": "Integer that represents the length of the array (minimum of 0).",
          "type": "number"
        },
        {
          "name": "opt_filler",
          "description": "Either a filler value or if this is a function and `opt_callFiller` is `true`-ish then this function will be called with the index to be filled and the return value will be used as the value added at that index.",
          "type": "Function|*",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_callFiller",
          "description": "If specified as `true`-ish and `opt_filler` is a function then `opt_filler` will be called as a function to generate the values at for each item in the new array.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A new array of the specified length with the specified value used for each item."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.array(10, function(x) { return x * x; }, true)), '[0,1,4,9,16,25,36,49,64,81]');"
        }
      ]
    },
    {
      "name": "attempt",
      "code": "function attempt(root, path) {\n  if ('string' === typeof path) {\n    path = [path];\n  }\n  for (var fn = root, i = 0, l = path.length; fn != undefined && i < l;) {\n    root = fn;\n    fn = root[path[i++]];\n  }\n  if ('function' === typeof fn) {\n    return fn.apply(root, slice(arguments, 2));\n  }\n}",
      "description": "Attempts to call a function if one exists at the given path starting at the given root object.",
      "params": [
        {
          "name": "root",
          "description": "The root object for which to begin traversing the `path` the find the corresponding function to be called.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "If this is a string it represents the name of `root`'s function that will be called.  If this is an array it represents a path to the object and then the underlying function that will be called.",
          "type": "string|Array<string>"
        },
        {
          "name": "opt_argX",
          "description": "Zero or more arguments to be passed to the function at `path`.",
          "type": "*",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "*",
        "description": "If there is a function found at `path` under root it will be executed and the return value will be returned.  Otherwise `undefined` is returned."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "avg",
      "code": "function avg(array) {\n  for (var sum = 0, count = 0, i = array.length; i--;) {\n    if (has(array, i)) {\n      sum += +array[i];\n      count++;\n    }\n  }\n  return count ? sum / count : undefined;\n}",
      "description": "Finds the average of the number in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array of numbers for which to find the average.",
          "type": "Array<number>"
        }
      ],
      "return": {
        "type": "number",
        "description": "The average of the numbers in `array`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "before",
      "code": "",
      "description": "Finds the substring before a specific target.",
      "params": [
        {
          "name": "subject",
          "description": "The string to search.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "The target to find and key off of within `subject`.",
          "type": "string|RegExp"
        },
        {
          "name": "opt_occurrence",
          "description": "The occurrence of `target` that you want to key off of within `subject`. If negative, the occurrence will be counted from the end of `subject`.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "string|null",
        "description": "Returns the string found before `target`. If `target` was not found or the specified occurrence (`opt_occurrence`) of `target` was not found, `null` will be returned."
      },
      "requires": [
        "around"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "best",
      "code": "function best(array, iterator) {\n  function getBest(array) {\n    for (var t, best = array[0], i = 1, l = array.length; i < l; i++) {\n      if (iterator(t = array[i], best)) {\n        best = t;\n      }\n    }\n    return best;\n  }\n  return array == undefined ? getBest : getBest(array);\n}",
      "description": "Gives the best item in a list based on the return value of the given iterator function.",
      "params": [
        {
          "name": "array",
          "description": "Either the array to be iterated over to find the best value or `undefined` (or `null`) indicating that this is a partial function call.",
          "type": "Array|undefined|null"
        },
        {
          "name": "iterator",
          "description": "Function that will receive two values starting with the first two in `array` or in the array passed when calling the returned partial function.  When a `true`-ish is returned by this function the value in `array` passed as the first argument will be regarded as the best value, otherwise the value in `array` passed as the second argument will be regarded as the best value.",
          "type": "Function"
        }
      ],
      "return": {
        "type": "Function|*",
        "description": "If `array` is `undefined` or `null` a partial function that is simply awaiting the value of `array` will be returned. Otherwise the value that was determined to be the best will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Shortest & Longest",
          "code": "var words = 'This is an interesting bit of code'.split(' ');\nvar shortest = YourJS.best(null, function(a,b){ return a.length < b.length });\nvar longest = YourJS.best(null, function(a,b){ return a.length > b.length });\ntest(JSON.stringify([shortest(words),longest(words)]), '[\"is\",\"interesting\"]');"
        }
      ]
    },
    {
      "name": "bind",
      "code": "function bind(fn, objThis, opt_args) {\n  opt_args = slice(opt_args || []);\n  return function() {\n    return fn.apply(objThis, opt_args.concat(slice(arguments)));\n  };\n}",
      "description": "Creates a function that when called will call `fn` with `this` referring to `objThis` and any values in `opt_args` be passed as the first arguments to `fn`.",
      "params": [
        {
          "name": "fn",
          "description": "Function to invoke when the return function is called.",
          "type": "Function"
        },
        {
          "name": "objThis",
          "description": "The value to which `this` will refer unless `undefined` or `null` is given.",
          "type": "*"
        },
        {
          "name": "opt_args",
          "description": "Array of arguments to prepend to the arguments passed to `fn` when the returned function is called.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A function that when called will call `fn` with `this` referring to `objThis` and any values in `opt_args` be passed as the first arguments to `fn`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var result = YourJS.bind(function(a, b) { return [b,a,this,a,b]; }, 1, [2])(3);\ntest(result.join(','), '3,2,1,2,3');"
        }
      ]
    },
    {
      "name": "bindCompare",
      "code": "function bindCompare(namespaces, opt_negate) {\n  namespaces = namespaces.reduce(function(namespaces, ns) {\n    var nsIsArray = isArray(ns), l = nsIsArray && ns.length;\n    if (!nsIsArray || l) {\n      namespaces.push(nsIsArray ? ns : [ns]);\n    }\n    return namespaces;\n  }, []);\n  return (Function(\n    'c,g,n' + namespaces.map(function (_, i) { return i; }).join(',n'),\n    'return function(a,b){return'\n      + (opt_negate ? '-' : '')\n      + '('\n      + namespaces.map(function (_, i) { return 'c(g(a,n' + i + '),g(b,n' + i + '))'; }).join('||')\n      + ')}'\n  )).apply(namespaces, [compare, getAt].concat(namespaces));\n}",
      "description": "Creates a compare function which binds the namespaces within the two given objects.",
      "params": [
        {
          "name": "namespaces",
          "description": "An array of namespaces to compare.  Each namespace can be an array of strings and/or numbers, a string or a number.  The order of the namespaces will determine the order in which the comparison occurs.",
          "type": "Array"
        },
        {
          "name": "opt_negate",
          "description": "Specifies whether or not the comparison value should be negated.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A comparison function with the namespaces to be checked bound within the function."
      },
      "requires": [
        "compare",
        "getAt",
        "isArray"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "blockify",
      "code": "function blockify(obj, opt_filter, opt_overwrite) {\n  var filterType = nativeType(opt_filter);\n  var filter = filterType === 'Function'\n    ? opt_filter\n    : filterType === 'Array'\n      ? function(v, key) { return opt_filter.indexOf(key) >= 0; } // Array#indexOf() has IE9+ support\n      : filterType === 'RegExp'\n        ? function(v, key) { return opt_filter.test(key); }\n        : function(v, key) { return opt_filter !== key; };\n  opt_overwrite = opt_overwrite === undefined ? true : !!opt_overwrite;\n  var code = ['try{if(@===undefined){throw 1}}catch(e){throw new Error(\"Specified block no longer exists.\")}'];\n  var global = (function() { return this; })();\n  for (var id; has(global, id = '*yjsBlock' + Math.random()););\n  global[id] = Object.keys(obj).reduce(function(carry, key) {\n    if (isValidVarName(key) && filter(obj[key], key, obj)) {\n      carry[key] = obj[key];\n      code.push('var ' + key + (!opt_overwrite ? '=' + key + '===undefined?@.' + key + ':' : '=@.') + key);\n    }\n    return carry;\n  }, {});\n  code.push('delete @');\n  return code.join(';').replace(/@/g, '(function(){return this})()[\"' + id + '\"]');\n}",
      "description": "Creates global variables and when the returned code is executed via `eval()` the global variables will be deleted and will only be included in the block in which `eval()` executes.",
      "params": [
        {
          "name": "obj",
          "description": "The object whose values should be added to the block's scope.",
          "type": "Object"
        },
        {
          "name": "opt_filter",
          "description": "If not given then all values will be setup to be added to the block's scope.  If this is an array, only the matching keys found in the array will be setup to be added to the block's scope.  If this is a function then it will iterate over all of the values in `obj` and will be passed (1) the value, (2) the key, (3) `obj` and the return value will be coerced to a boolean to determine if the key-value pair should be setup to be added to the block's scope.  If this is a regular expression then only the keys that match will be setup to be added to the block's scope.  In all other cases, all key-value pairs will be added as long as the key isn't this value.",
          "type": "Array|Function|RegExp|*",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_overwrite",
          "description": "Defaults to `true`.  If `true` whenever `eval()` is called on the returned string any variables that could possibly be overwritten will be overwritten.",
          "type": "boolean",
          "optional": true,
          "default": "true"
        }
      ],
      "return": {
        "type": "string",
        "description": "The JavaScript code that can be called by `eval()` to add the desired variables to the current scope."
      },
      "requires": [
        "nativeType",
        "isValidVarName",
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var now = new Date;\neval(YourJS.blockify({ a: now, b: now }));\ntest(a === b, now === b);"
        }
      ]
    },
    {
      "name": "call",
      "code": "function call(fn, objThis) {\n  var t = typeof(fn) === 'string';\n  if (t) {\n    t = fn.match(/^([\\w\\$]+(?=\\.|#))?(#|\\.?prototype\\.)(\\w+)$/);\n    fn = t ? (t[1] ? __GLOBAL[t[1]].prototype : objThis)[t[3]] : YourJS[fn];\n  }\n  return fn.apply(t ? objThis : undefined, slice(arguments, t ? 2 : 1));\n}",
      "description": "Calls a function whether it be a global prototype function or a YourJS function or a custom bindable.",
      "params": [
        {
          "name": "fn",
          "description": "If a function is supplied it will be called.  If a string, it can refer to a prototype function by using either the `\"Array.prototype.slice\"` (`\"Prototype_Name.prototype.function_name\"`) format, the `\"Array#slice\"` (`\"Prototype_Name#function_name\"`) format or the `\"#slice\"` (`\"#function_name\"` for `objThis`) format.  If not in the previous format but is a string it must be the string name of a function in the `YourJS` object.",
          "type": "Function|string"
        },
        {
          "name": "objThis",
          "description": "If `fn` is a function or is a string referring to a prototypal function, this will be the value passed as the `this` object to `fn`.",
          "type": "*",
          "optional": true,
          "default": "global"
        },
        {
          "name": "argX",
          "description": "Arguments to pass to `fn`.",
          "type": "*",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "*",
        "description": "Return value of calling `fn` with the specified arguments and using the specified context object."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Call YourJS.toString function",
          "code": "test(YourJS.call('toString'), YourJS.toString());"
        },
        {
          "name": "Call YourJS.typeOf function (since it is required)",
          "code": "test(YourJS.call('typeOf', 34), YourJS.typeOf(34));"
        },
        {
          "name": "Call slice on string",
          "code": "var msg = 'Hello world!!!';\nvar start = -8, end = -2;\ntest(\n  YourJS.call('#slice', msg, start, end),\n  msg.slice(start, end)\n);"
        }
      ]
    },
    {
      "name": "callOf",
      "code": "/*******************************************************************************\n// Original code for callOf() and applyOf()\nfunction callOf(fn, opt_owner, opt_objThis) {\n  if ('string' === typeof fn) {\n    fn = opt_owner[fn];\n  }\n  return arguments.length < 3\n    ? function(opt_objThis) { return fn.apply(opt_objThis, [].slice.call(arguments, 1)); }\n    : function () { return fn.apply(opt_objThis, arguments); };\n}\nfunction applyOf(fn, opt_owner, opt_objThis) {\n  if ('string' === typeof fn) {\n    fn = opt_owner[fn];\n  }\n  return arguments.length < 3\n    ? function(opt_objThis, args) { return fn.apply(opt_objThis, args); }\n    : function (args) { return fn.apply(opt_objThis, args); };\n}\n*******************************************************************************/\neval('0call2[].slice.call(arguments,1)3arguments)}}0apply2b3b)}}'.replace(/\\d/g, function (i) {\n  return [\n    'function ',\n    1,\n    'Of(a,b,c){\"string\"===typeof a&&(a=b[a]);return 3>arguments.length?function(d,b){return a.apply(d,',\n    ')}:function(b){return a.apply(c,'\n  ][i];\n}));",
      "description": "Gets the `call()` function for the specified function.",
      "params": [
        {
          "name": "fn",
          "description": "The function or the function name for which to get the `call()` function.",
          "type": "Function|string"
        },
        {
          "name": "opt_owner",
          "description": "If `fn` is a string then this will be used as the parent object to reference the actual function.",
          "type": "Object",
          "optional": true
        },
        {
          "name": "opt_objThis",
          "description": "If given this will be the value that is always used as the `this` keyword by `fn` (the function).  If not given, the first argument passed to the returned function will be referenced as the `this` keyword.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "Function",
        "description": "If `opt_objThis` is not passed, a version of `call()` will be returned which will use the first argument as the `this` keyword and all subsequent parameters will be normal arguments.  Otherwise a function which accepts only arguments (not the `this` keyword definition) will be returned."
      },
      "requires": [
        "applyOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var slice = YourJS.callOf('slice', []);\nvar arr = slice([1,2,3,4,5,6,7], 1, -1);\nvar arrCheck = [2,3,4,5,6];\ntest(JSON.stringify(arr), JSON.stringify(arrCheck));"
        },
        {
          "name": "All Args",
          "code": "var slice = YourJS.callOf(Array.prototype.slice, null, [1,2,3,4,5,6,7]);\nvar arr = slice(1, -1);\nvar arrCheck = [2,3,4,5,6];\ntest(JSON.stringify(arr), JSON.stringify(arrCheck));"
        }
      ]
    },
    {
      "name": "calls",
      "code": "function calls(value) {\n  for (var callArgs, args = slice(arguments), i = 0, l = args.length, i = l; i < l; i++) {\n    callArgs = args[i];\n    if (nativeType(callArgs) !== 'Array') {\n      callArgs = [callArgs];\n    }\n    value = call.apply(undefined, slice(callArgs, 0, 1).concat([value], slice(callArgs, 1)));\n  }\n  return value;\n}",
      "description": "Makes multiple calls using the YourJS `call()` function.",
      "params": [
        {
          "name": "value",
          "description": "The value to start off with in the calling chain.",
          "type": "*"
        },
        {
          "name": "callArgs",
          "description": "If any of these arguments are strings or functions that will be wrapped in arrays.  The items in each array argument will be passed as arguments to YourJS's `call()` function.",
          "type": "Array|Function|string",
          "optional": true,
          "rest": true
        }
      ],
      "return": {
        "type": "*",
        "description": "Return value of making the specified calls to YourJS's call function in the specified sequence."
      },
      "requires": [
        "nativeType",
        "slice",
        "call"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "canDefault",
      "code": "",
      "description": "Determines whether or not a value would be defaulted to another value.",
      "params": [
        {
          "name": "value",
          "description": "Value to test out.",
          "type": "*"
        },
        {
          "name": "opt_beStrict",
          "description": "Specifies whether or not to only check if `value` is `undefined`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "If `opt_beStrict` is `true`-ish and `value` is `undefined`, `true` will be returned.  If `opt_beStrict` is `false`-ish and `value` is `undefined`, `null` or `NaN`, `true` will be returned.  In all other cases `false` will be returned."
      },
      "requires": [
        "defaultTo"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "cap",
      "code": "function cap(fn, opt_maxArity, opt_staticArgs, opt_indexInArgs) {\n  var leftArgs = slice(\n        opt_staticArgs = opt_staticArgs || [],\n        0,\n        opt_indexInArgs = opt_indexInArgs == undefined ? opt_staticArgs.length : opt_indexInArgs\n      ),\n      rightArgs = slice(opt_staticArgs, opt_indexInArgs);\n  if ('string' == typeof fn) {\n    fn = YourJS[fn];\n    if ('function' != typeof fn) {\n      throw new Error('Cannot resolve cap function for \"' + fn + '\"');\n    }\n  }\n  opt_maxArity = opt_maxArity != undefined ? opt_maxArity : fn.length;\n  return function(arg1) {\n    return fn.apply(\n      this,\n      leftArgs.concat(slice(arguments, 0, opt_maxArity), rightArgs)\n    );\n  };\n}",
      "description": "Puts a cap (limit) on the amount of arguments that a function can receive.",
      "params": [
        {
          "name": "fn",
          "description": "The function that will be called by the capped function.  If a string it be interpreted as the function within the YourJS object's context with that name.",
          "type": "Function|string"
        },
        {
          "name": "opt_maxArity",
          "description": "The max number of arguments that will be accepted by the returned capped function.",
          "type": "number",
          "optional": true,
          "default": "fn.length"
        },
        {
          "name": "opt_staticArgs",
          "description": "Arguments that will always be passed to `fn`.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        },
        {
          "name": "opt_indexInArgs",
          "description": "Position within `opt_staticArgs` to place the limited additional arguments if any are passed to the capped function.  Negative position will be counted from the end of `opt_staticArgs`.",
          "type": "number",
          "optional": true,
          "default": "opt_staticArgs.length"
        }
      ],
      "return": {
        "type": "Function",
        "description": "Returns a function that will call `fn` with the passed in arguments when invoked, but it will limit the argument count to the value `opt_maxArity`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Generic Slice",
          "code": "inner = YourJS.cap(function(v, s, e){return v.slice(s,e)}, 1, [1, -1], 0);\ntest(\n  JSON.stringify([inner('where'), inner([1,2,3,4,5,6,7,8,9])]),\n  '[\"her\",[2,3,4,5,6,7,8]]'\n);"
        }
      ]
    },
    {
      "name": "capProto",
      "code": "function capProto(fn, opt_maxArity, opt_staticArgs, opt_indexInArgs) {\n  var fnIsString = 'string' === typeof fn,\n      leftArgs = slice(\n        opt_staticArgs = opt_staticArgs || [],\n        0,\n        opt_indexInArgs = opt_indexInArgs == undefined ? opt_staticArgs.length : opt_indexInArgs\n      ),\n      rightArgs = slice(opt_staticArgs, opt_indexInArgs);\n  if (fnIsString) {\n    fn.replace(/^([\\w\\$]+(?=\\.|#))?(?:#|\\.?prototype\\.)(\\w+)$|[\\s\\S]*/, function(m, globalClassName, fnName) {\n      fnIsString = !globalClassName;\n      if (globalClassName) {\n        fn = __GLOBAL[globalClassName].prototype[fnName];\n        if ('function' !== typeof fn) {\n          fn = 0;\n        }\n      }\n      else {\n        fn = fnName;\n      }\n      if (!fn) {\n        throw new Error('Cannot resolve prototype function for \"' + m + '\"');\n      }\n    });\n  }\n  return function(objThis) {\n    var f = fn;\n    if (fnIsString) {\n      f = Object(objThis)[f];\n      if ('function' !== typeof f) {\n        throw new Error(\"Invalid value for this prototype function\");\n      }\n    }\n    return f.apply(objThis, leftArgs.concat(\n      slice(arguments, 1, opt_maxArity == undefined ? f.length + 1 : opt_maxArity),\n      rightArgs\n    ));\n  };\n}",
      "description": "Creates a wrapper function for a prototype function that can be capped (limited in the amount of arguments it can receive).",
      "params": [
        {
          "name": "fn",
          "description": "The prototype function that will be called by the returned wrapper function.  If it is a string it can refer to a prototype function by using either the `\"Array.prototype.slice\"` (`\"Prototype_Name.prototype.function_name\"`) format, the `\"Array#slice\"` (`\"Prototype_Name#function_name\"`) format or the `\"#slice\"` (`\"#function_name\"` for the 1st argument) format.",
          "type": "Function|string"
        },
        {
          "name": "opt_maxArity",
          "description": "The max number of arguments that will be accepted by the returned capped function.",
          "type": "number",
          "optional": true,
          "default": "fn.length"
        },
        {
          "name": "opt_staticArgs",
          "description": "Arguments that will always be passed to `fn`.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        },
        {
          "name": "opt_indexInArgs",
          "description": "Position within `opt_staticArgs` to place the limited additional arguments if any are passed to the capped function.  Negative position will be counted from the end of `opt_staticArgs`.",
          "type": "number",
          "optional": true,
          "default": "opt_staticArgs.length"
        }
      ],
      "return": {
        "type": "Function",
        "description": "Returns a function that will call `fn` with the passed in arguments when invoked, but it will limit the argument count to the value `opt_maxArity` (not including the 1st argument which is the context argument)."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Generic Slice",
          "code": "inner = YourJS.capProto('#slice', 1, [1, -1], 0);\ntest(\n  JSON.stringify([inner('where'), inner([1,2,3,4,5,6,7,8,9])]),\n  '[\"her\",[2,3,4,5,6,7,8]]'\n);"
        }
      ]
    },
    {
      "name": "cbrt",
      "code": "function cbrt(x) {\n  var y = Math.pow(Math.abs(x), 1 / 3);\n  return x < 0 ? -y : y;\n}",
      "description": "Gets the cube root of a number.",
      "params": [
        {
          "name": "x",
          "description": "A number.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cube root of the given number."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.cbrt(27), 3)"
        }
      ]
    },
    {
      "name": "ceil",
      "code": "",
      "description": "Rounds towards `Infinity` with the specified precision.",
      "params": [
        {
          "name": "num",
          "description": "The number to be rounded towards `Infinity`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number towards `Infinity`. Using the precision is similar to doing `Math.ceil(num * Math.pow(10, precision)) / Math.pow(10, precision)`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` rounded towards `-Infinity` with the specified precision."
      },
      "requires": [
        "round"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "chain",
      "code": "var chain, mixin;\n(function(RGX_INVALID_PROP_NAMES) {\n  function YourJSChain(value, previousWrap) {\n    this.$$ = previousWrap;\n    this.$ = value;\n  }\n\n  function value() { return this.$; }\n\n  YourJSChain.prototype = {\n    _: function(name) {\n      return new YourJSChain(this.$[name].apply(this.$, slice(arguments, 1)), this);\n    },\n    value: value,\n    end: function() { return this.$$; },\n    valueOf: value\n  };\n\n  __callsAfterDefs.push(function() {\n    forIn(YourJS, function(prop, name) {\n      if ('function' === typeof prop && !RGX_INVALID_PROP_NAMES.test(name)) {\n        YourJSChain.prototype[name] = function() {\n          return new YourJSChain(prop.apply(undefined, [this.$].concat(slice(arguments))), this);\n        };\n      }\n    });\n  });\n\n  typeOf(YourJSChain, 'YourJSChain');\n\n  chain = function(value) {\n    return new YourJSChain(value);\n  };\n\n  mixin = function(fn, name) {\n    if (RGX_INVALID_PROP_NAMES.test(name) || has(YourJS, name)) {\n      return false;\n    }\n\n    YourJS[name] = fn;\n    YourJSChain.prototype[name] = function() {\n      return new YourJSChain(fn.apply(undefined, [this.$].concat(slice(arguments))), this);\n    };\n    return true;\n  };\n})(/^(value|end|_|mixin|\\$\\$?)$/);",
      "description": "Creates a chained version of a value.",
      "params": [
        {
          "name": "value",
          "description": "Value to make chainable.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "YourJSChain",
        "description": "A `YourJSChain` object allows for chaining other YourJS functions calls together and thusly all of its functions except the `value()` function will return a `YourJSChain` object.  You can call the `YourJSChain`'s `value()` function to return the actual internal value.  The `YourJSChain`'s `end()` function will return the previous `YourJSChain` object."
      },
      "requires": [
        "slice",
        "forIn",
        "typeOf",
        "is",
        "mixin",
        "has"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "chunk",
      "code": "function chunk(array, opt_size) {\n  opt_size = opt_size >= 1 ? ~~opt_size : 1;\n  for (var chunks = [], i = Math.floor((array.length - 1) / opt_size) * opt_size; i >= 0; i -= opt_size) {\n    chunks.unshift(array.slice(i, i + opt_size));\n  }\n  return chunks;\n}",
      "description": "Takes an array, splits it up into chunks of a specified size and returns a new array containing said array chunks.",
      "params": [
        {
          "name": "array",
          "description": "The array that will be used to make the chunks.  This array will not be modified.",
          "type": "Array"
        },
        {
          "name": "opt_chunkLimit",
          "description": "The maximum number of items in each chunk.  All chunks will contain this amount of items with the exception of the final chunk.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of arrays where each subarray contains a chunk of the values from `array`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "clamp",
      "code": "function clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}",
      "description": "Confine a given number to a specific range.",
      "params": [
        {
          "name": "x",
          "description": "The number to be confined to the specified range.",
          "type": "number"
        },
        {
          "name": "min",
          "description": "The minimum number that can be returned.",
          "type": "number"
        },
        {
          "name": "max",
          "description": "The maximum number that can be returned.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The closest number to `x` that is greater than or equal to `min` and less than or equal to `max`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "closestMultOf",
      "code": "function closestMultOf(factor, target) {\n  return Math.round(target / factor) * factor;\n}",
      "description": "Finds the closest multiple of a number to another number.",
      "params": [
        {
          "name": "factor",
          "description": "The number to find a multiple of.",
          "type": "number"
        },
        {
          "name": "target",
          "description": "The number that the multiple of `factor` should approximate.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "A multiple of `factor` that approximates `target`.  If `factor` is 0 or not a number, `NaN` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "commaNumber",
      "code": "function commaNumber(num) {\n  if (num = fullNumber(num)) {\n    num = num.split('.');\n    num[0] = num[0].replace(/\\d(?=(\\d{3})+$)/g, '$&,');\n    return num.join('.');\n  }\n}",
      "description": "Turns a number into a string in its fullest form with commas separating the integral part at the thousands mark, millions mark, billions mark, etc.",
      "params": [
        {
          "name": "num",
          "description": "Number that will be converted to a string and will have commas added to it to separate the hundreds from thousands, the thousands from the millions, etc.",
          "type": "number|string"
        }
      ],
      "return": {
        "type": "string|undefined",
        "description": "A string representation of `num` with commas separating the hundreds from thousands, the thousands from the millions, etc.  If `num` is not a finite number `undefined` will be returned."
      },
      "requires": [
        "fullNumber"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "compact",
      "code": "function compact(arrOrObj) {\n  return filter(arrOrObj, function(value) { return value; });\n}",
      "description": "Create a new array or object with all of the `false`-ish values removed.",
      "params": [
        {
          "name": "arrOrObj",
          "description": "Array or object of values to comb through.",
          "type": "Array|Object"
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "If `arrOrObj` is an array or is array-like then an array will be returned.  Otherwise an object will be returned.  The returned array or object will be similar to `arrOrObj` but will only have `true`-ish values."
      },
      "requires": [
        "filter"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Array",
          "code": "test(\n  JSON.stringify(YourJS.compact([false,true,5,0,\"\",\"H\",null])),\n  '[true,5,\"H\"]'\n)"
        },
        {
          "name": "Simple Object",
          "code": "var obj = { a: 'Hello world!!!', b: 0, c: null, d: undefined, e: false };\nvar obj2 = YourJS.compact(obj);\nvar objCheck = { a: 'Hello world!!!' };\ntest(JSON.stringify(obj2), JSON.stringify(objCheck));"
        }
      ]
    },
    {
      "name": "compare",
      "code": "function compare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}",
      "description": "Simple compare function typically use in sorting.",
      "params": [
        {
          "name": "a",
          "description": "First argument to compare.",
          "type": "*"
        },
        {
          "name": "b",
          "description": "Second argument to compare.",
          "type": "*"
        }
      ],
      "return": {
        "type": "number",
        "description": "`-1` is returned if `a < b`.  `1` is returned if `a > b`.  In all other cases `0` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "compareTitle",
      "code": "function compareTitle(title1, title2) {\n  var parts1, parts2, part1, part2, i, l, isDigits = /^\\d/.test(title1 += '');\n  if (isDigits === /^\\d/.test(title2 += '') || (!/\\d/.test(title1) && !/\\d/.test(title2))) {\n    l = Math.min(\n      (parts1 = title1.match(/\\D+|\\d+/g)).length,\n      (parts2 = title2.match(/\\D+|\\d+/g)).length\n    );\n    for (i = 0; i < l; i++, isDigits = !isDigits) {\n      part1 = parts1[i];\n      part2 = parts2[i];\n      if (part1 !== part2) {\n        return isDigits ? Math.ceil(part1) - Math.ceil(part2) : part1 < part2 ? -1 : 1;\n      }\n    }\n  }\n  return title1 < title2 ? -1 : title1 > title2 ? 1 : 0;\n}",
      "description": "Compares 2 titles by splitting the titles into sections where each section is either full of digits or non-digits.",
      "params": [
        {
          "name": "title1",
          "description": "First title to compare to `title2`.",
          "type": "string"
        },
        {
          "name": "title2",
          "description": "Second title to compare to `title1`.",
          "type": "string"
        }
      ],
      "return": {
        "type": "number",
        "description": "If `title1` comes before `title2` a negative number will be returned.  If `title1` comes after `title2` a positive number will be returned.  In all other cases `0` will be returned. "
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "compose",
      "code": "function compose(fnWrapper, fnToWrap, opt_applyArgs) {\n  return Function('x,y', 'return function(){return x.' + (opt_applyArgs ? 'apply' : 'call') + '(this,y.apply(this,arguments))}')(fnWrapper, fnToWrap);\n}",
      "description": "Create a new function which is basically the composition of two functions.",
      "params": [
        {
          "name": "fnWrapper",
          "description": "Function that will be passed the return value of `fnToWrap` and whose return value will be returned by the composed function.",
          "type": "Function"
        },
        {
          "name": "fnToWrap",
          "description": "Function that will be called 1st by te composed function and whose return value will be passed to `fnWrapper`.",
          "type": "Function"
        },
        {
          "name": "opt_applyArgs",
          "description": "Set to `true` if the return value from `fnToWrap` is an `Array` and each element should be passed a separate argument to `fnWrapper`.  Leave blank or set to `false` if the return value from `fnToWrap` should just be passed as the 1st argument to `fnWrapper`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The function that is composed of `fnToWrap` and `fnWrapper`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "construct",
      "code": "function construct(constructor) {\n  return new(constructor.bind.apply(constructor, [null].concat(slice(arguments, 1))));\n}",
      "description": "Constructs an object with an arbitrary number of arguments passed via an array (or an array-like object).",
      "params": [
        {
          "name": "constructor",
          "description": "The constructor function.",
          "type": "Function"
        },
        {
          "name": "args",
          "description": "Zero or more arguments with which `constructor` will be used to construct the desired object type.",
          "type": "*",
          "optional": true,
          "rest": true
        }
      ],
      "return": {
        "type": "*",
        "description": "Returns the result of calling `new constructor(...args)`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Array",
          "code": "test(JSON.stringify(YourJS.construct(Array,4,5,6)), '[4,5,6]');"
        }
      ]
    },
    {
      "name": "copyProps",
      "code": "function copyProps(target, source, props, opt_dontDelete) {\n  if (target) {\n    source = Object(source);\n    for (var prop, i = props.length; i--;) {\n      prop = props[i];\n      if ((prop in source) || opt_dontDelete) {\n        target[prop] = source[prop];\n      }\n      else {\n        delete target[prop];\n      }\n    }\n  }\n  return target;\n}",
      "description": "Copies the specified properties from the source object to the target object.",
      "params": [
        {
          "name": "target",
          "description": "Target object to which the properties will be copied.",
          "type": "*"
        },
        {
          "name": "source",
          "description": "Source object from which the properties will be copied.",
          "type": "*"
        },
        {
          "name": "keys",
          "description": "Array of keys for the properties that should be copied from source to target.",
          "type": "Array"
        },
        {
          "name": "opt_dontDelete",
          "description": "Indicates whether properties that dont exist should be deleted between objects.  If `true`, non-existent properties will be set to `undefined`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "Returns a reference to `target`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var a = {a: 1, b: 2};\nvar b = {b: 3, c: 4};\nYourJS.copyProps(a, b, ['b', 'a']);\ntest(JSON.stringify(Object.entries(a).sort((x,y)=>x[0]<y[0]?-1:1)),'[[\"b\",3]]')"
        },
        {
          "name": "Simple dont delete",
          "code": "var a = {a: 1, b: 2};\nvar b = {b: 3, c: 4};\nYourJS.copyProps(a, b, ['b', 'a'], true);\ntest(JSON.stringify(Object.entries(a).sort((x,y)=>x[0]<y[0]?-1:1)),'[[\"a\",null],[\"b\",3]]')"
        }
      ]
    },
    {
      "name": "copySign",
      "code": "function copySign(a, b) {\n  return (a < 0 || 1 / a < 0) === (b < 0 || 1 / b < 0) ? a : -a;\n}",
      "description": "Takes the sign of the number from the second argument and uses it as the sign of the number given in the first argument.",
      "params": [
        {
          "name": "number1",
          "description": "The number that will be returned with the sign specified by `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "The number that has the sign (positive or negative) to use as the sign for `number1` when it is returned from this function.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "`number1` will be returned but with the same sign (positive or negative) as the one specified for `number2`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.copySign(1, -0), -1);"
        }
      ]
    },
    {
      "name": "cos",
      "code": "",
      "description": "Determines the cosine of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose cosine value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cosine of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the cosine of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "cot",
      "code": "",
      "description": "Determines the cotangent of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose cotangent value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cotangent of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the cotangent of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "count",
      "code": "function count(arrOrObj, tester, opt_traverseAll) {\n  var count = 0, isStrTester = nativeType(tester) === 'String';\n  forOf(arrOrObj, function(value, key, arrOrObj) {\n    if (tester(value, key, arrOrObj)) {\n      count++;\n    }\n  }, opt_traverseAll);\n  return count;\n}",
      "description": "Count how many items in an array or an object pass a given tester function.",
      "params": [
        {
          "name": "arrOrObj",
          "description": "If this is an array or an object all of the items that pass the `tester` function will be counted.  If this is a string all of the characters that pass the `tester` function will be counted.",
          "type": "Array|Object|string"
        },
        {
          "name": "tester",
          "description": "Function that will take in (1) each value, (2) the corresponding key, and (3) a reference to `arrOrObj`.  If the function returns a `true`-ish value the count will be incremented.",
          "type": "Function"
        },
        {
          "name": "opt_traverseAll",
          "description": "Indicates whether or not all items, including the non-owned ones, should be traversed and included in the count.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The number of times `tester` returned a `true`-ish value."
      },
      "requires": [
        "forOf",
        "nativeType"
      ],
      "required": false,
      "tests": [
        {
          "name": "Count Odds In Array",
          "code": "test(YourJS.count([1,2,3,4,5,6,7], function(v){return v%2}), 4);"
        }
      ]
    },
    {
      "name": "countBy",
      "code": "var countBy = Function('G,H,T', ('return[@\"number\"!==typeof c[f=g?d(b[a],a,b):G(b[a],d)]&&(c[f]=0),c[f]++#,@\"Array\"!==T(c[f=g?d(b[a],a,b):G(b[a],d)])&&(c[f]=[]),c[f].push(b[a])#,@f=c[g?d(b[a],a,b):G(b[a],d)]=b[a]#]').replace(/@([^#]+)#/g, 'function(b,d,c){c=c||{};d=\"string\"===typeof d?[d]:d;for(var f,g=\"function\"===typeof d,a=0,h=b.length;a<h;a++)H(b,a)&&($1);return c}'))(getAt, has, nativeType),\n    groupBy = countBy[1],\n    indexBy = countBy[2];\ncountBy = countBy[0];",
      "description": "Creates or augments an object, making new properties that correspond to values in the given array.  Each property added will indicate how many items in the array corresponding to those property names.",
      "params": [
        {
          "name": "arr",
          "description": "Array or array-like object containing items to group together and count.",
          "type": "Array"
        },
        {
          "name": "grouper",
          "description": "If a function, it will be passed a value which will be used to group the items in `arr`.  If an array or a string it will be seen as the path within each item in `arr` to the property by which to group each item.",
          "type": "Function|Array|string"
        },
        {
          "name": "opt_initial",
          "description": "Object to augment with property names that will contain counts of how many items correspond to the values returned by `grouper`.",
          "type": "Object",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "Object",
        "description": "`opt_initial` with property names that will contain counts of how many items correspond to the values returned by `grouper`."
      },
      "requires": [
        "has",
        "getAt",
        "nativeType",
        "groupBy",
        "indexBy"
      ],
      "required": false,
      "tests": [
        {
          "name": "Odds & Evens",
          "code": "var nums = [0,1,2,3,4,5,6,7,8,9,10];\nvar counts = YourJS.countBy(nums, function(n) { return n % 2 ? 'odd' : 'even'; });\ntest(counts.odd + ' odds, ' + counts.even + ' evens', '5 odds, 6 evens');"
        }
      ]
    },
    {
      "name": "csc",
      "code": "",
      "description": "Determines the cosecant of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose cosecant value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cosecant of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the cosecant of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "css",
      "code": "var css;\n(function(RGX_UPPER, RGX_AMP, RGX_NO_COMMAS_OR_NOTHING, RGX_NO_AMP, RGX_IND_SEL, RGX_CLS, RGX_TRIM_SELS) {\n  css = function(obj, selAncestors) {\n    if (typeof selAncestors != 'string') {\n      if (selAncestors) {\n        var className = ('_' + Math.random()).replace(RGX_CLS, +new Date);\n        selAncestors = nativeType(selAncestors) == 'Array' ? selAncestors : [selAncestors];\n        for (var i = selAncestors.length; i--;) {\n          selAncestors[i].className += ' ' + className;\n        }\n      }\n      selAncestors = className ? '.' + className : '';\n    }\n\n    var code = getCssCode(obj, selAncestors);\n    var style = __DOCUMENT.createElement('style');\n    style.type = 'text/css';\n    if (style.styleSheet && !style.sheet) {\n      style.styleSheet.cssText = code;\n    }\n    else {\n      style.appendChild(__DOCUMENT.createTextNode(code));\n    }\n    (__DOCUMENT.getElementsByTagName('head')[0] || __DOCUMENT.body).appendChild(style);\n    return style;\n  }\n\n  function getCssCode(obj, selAncestors) {\n    var rules = [];\n    var rule = [];\n    for (var key in obj) {\n      if (has(obj, key)) {\n        var value = obj[key];\n        var typeName = nativeType(value);\n        if (!key.indexOf('@media ')) {\n          rules.push(key + '{' + getCssCode(value, selAncestors) + '}');\n        }\n        else if (typeName === 'Object') {\n          // Trim selectors\n          key = key.replace(RGX_TRIM_SELS, '$1');\n          // Return all selectors\n          key = key.replace(RGX_IND_SEL, function(sel) {\n            sel = selAncestors ? sel.replace(RGX_NO_AMP, '& $&') : sel;\n            return selAncestors.replace(RGX_NO_COMMAS_OR_NOTHING, function(selAncestor) {\n              return sel.replace(RGX_AMP, selAncestor);\n            });\n          });\n          rules.push(getCssCode(value, key));\n        }\n        else {\n          value = typeName !== 'Array'\n            ? value != undefined\n              ? value && typeof value == 'number'\n                ? value + 'px'\n                : ((value + '').slice(-1) == '!' ? value + 'important' : value)\n              : 'none'\n            : value.join(',');\n          key = key.replace(RGX_UPPER, '-$&').toLowerCase();\n          rule.push(key + ':' + value + ';');\n        }\n      }\n    }\n    if (rule[0]) {\n        rules.unshift(selAncestors + '{' + rule.join('') + '}');\n    }\n    return rules.join('');\n  }\n})(\n  /[A-Z]/g,                                       // RGX_UPPER\n  /&/g,                                           // RGX_AMP\n  /[^,]+|^$/g,                                    // RGX_NO_COMMAS_OR_NOTHING\n  /^[^&]+$/,                                      // RGX_NO_AMP\n  /[^\\s\\xa0,][^,]*/g,                             // RGX_IND_SEL\n  /0(.|$)/,                                       // RGX_CLS\n  /^[\\s\\xa0]+|[\\s\\xa0]*(,)[\\s\\xa0]*|[\\s\\xa0]+$/g  // RGX_TRIM_SELS\n);",
      "description": "Creates a CSS stylesheet from an JSON representation of a stylesheet.",
      "params": [
        {
          "name": "objStyles",
          "description": "An object representing the CSS rules to be inserted into the document. Property names will be used as media queries if they start with `\"@media \"`. Property names will be used as rule selectors if the value is an object. If a property name is to be used as a selector, if any selectors don't contain `&`, `\"& \"` will be prepended to it. For all selectors, `&` will be replaced recursively with the selectors found in the parent. CSS property names will be uncamelcased by inserting dashes before each uppercased character and lower casing all characters. If a value is `null` or `undefined`, it will be turned into `\"none\"`. If a value is a number other than `0`, `\"px\"` will be appended to it. If a value is an array all of the items will be concatenated together, using `\",\"` to delimit the values. If a value ends with `!` it will be replaced with `\"!important\"`.",
          "type": "Object"
        },
        {
          "name": "opt_ancestors",
          "description": "This can be an element or an array of elements which will get another class added to target all rules to it and its children. This can alternatively be a CSS path (selector) specifying the root on which all CSS rules created should be based.",
          "type": "HTMLElement|Array.<HTMLElement>|string"
        }
      ],
      "return": {
        "type": "HTMLStyleSheet",
        "description": "The stylesheet that is created and appended to the document is returned."
      },
      "requires": [
        "has",
        "nativeType"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "curry",
      "code": "function curry(fn, opt_argsNeeded, opt_curryRight, opt_presetArgs) {\n  opt_presetArgs = opt_presetArgs || [];\n  opt_argsNeeded = opt_argsNeeded == undefined ? fn.length - opt_presetArgs.length : opt_argsNeeded;\n  return function() {\n    var inArgs = slice(arguments),\n        args = opt_curryRight ? inArgs.concat(opt_presetArgs) : opt_presetArgs.concat(inArgs),\n        newArgsNeeded = opt_argsNeeded - inArgs.length;\n    return newArgsNeeded > 0\n      ? curry(fn, newArgsNeeded, opt_curryRight, args)\n      : fn.apply(this, args);\n  };\n}",
      "description": "Creates a wrapper function that will only execute the given function once the number of arguments passed is at least a given amount.  If the wrapper is called with too few arguments, those arguments will be recursively stored within a new wrapper function.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be executed once enough arguments have been passed.",
          "type": "Function"
        },
        {
          "name": "opt_argsNeeded",
          "description": "Number of arguments needed to successfully invoke this function.",
          "type": "number",
          "optional": true,
          "default": "fn.length"
        },
        {
          "name": "opt_curryRight",
          "description": "Indicates whether returned partial functions will group the arguments recursively from right-to-left.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        },
        {
          "name": "opt_presetArgs",
          "description": "Arguments that will always be passed to `fn`.  If `opt_curryRight` is `true` any arguments passed to the wrapper function will precede these arguments when invoking the function, otherwise any arguments passed to the wrapper function will come after these arguments when invoking the function.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function that will recursively create wrapper functions upon invocation until the cumulative number of arguments (excluding those specified in `opt_presetArgs`) amounts to `opt_argsNeeded`.  If the minimum number of arguments are passed to this function it will invoke `fn` with all of the arguments passed in."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Wait for 5",
          "code": "var waitFor5 = YourJS.curry(function(a,b,c,d,e){return [].join.call(arguments, ',')});\ntest(waitFor5(4,5)(6)(7)(8,9), '4,5,6,7,8,9');"
        },
        {
          "name": "Wait for 5 curryRight",
          "code": "var waitFor5 = YourJS.curry(function(a,b,c,d,e){return [].join.call(arguments, ',')}, undefined, true);\ntest(waitFor5(4,5)(6)(7)(8,9), '8,9,7,6,4,5');"
        },
        {
          "name": "Wait for 5 prefilled curryRight",
          "code": "var waitFor5 = YourJS.curry(function(a,b,c,d,e){return [].join.call(arguments, ',')}, undefined, true, [1,2,3]);\ntest(waitFor5(4)(5,6,7), '5,6,7,4,1,2,3');"
        }
      ]
    },
    {
      "name": "cut",
      "code": "function cut(str, startIndex, opt_endIndex) {\n  var len = str.length;\n  if (opt_endIndex == undefined) {\n    opt_endIndex = Infinity;\n  }\n  else if (opt_endIndex < 0) {\n    opt_endIndex = opt_endIndex < -len ? 0 : (len + opt_endIndex);\n  }\n  if (startIndex < 0) {\n    startIndex = startIndex < -len ? 0 : (len + startIndex);\n  }\n  if (opt_endIndex < startIndex) {\n    opt_endIndex = startIndex;\n  }\n  return str.slice(0, startIndex) + str.slice(opt_endIndex);\n}",
      "description": "Cut out a substring within a given range.",
      "params": [
        {
          "name": "str",
          "description": "String to cut from.",
          "type": "string"
        },
        {
          "name": "startIndex",
          "description": "Index within `str` where the substring that will be removed starts.",
          "type": "number",
          "optional": false
        },
        {
          "name": "opt_endIndex",
          "description": "Index within `str` where the substring that will be removed ends.",
          "type": "number",
          "optional": true,
          "default": "str.length"
        }
      ],
      "return": {
        "type": "string",
        "description": "`str` without the cut substring found between `startIndex` and `opt_endIndex`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "debounce",
      "code": "eval('debounce231k=b;b=@;##b-k##@-b#throttle312#k=@,#k-b#b=k,#k-b#'.replace(\n  /(\\D+)(.)(.)(.)([^#]*)#([^#]*)#([^#]*)#([^#]*)#([^#]*)#/g,\n  'function $1(h,c,a){var u,d,e,f,g,k,b=0;a=u==a?$2:a?$3:$4;return function(){d=0;e=arguments;f=this;$5a&1&&($6d=$7>=c)&&($8g=h.apply(f,e));!d&&a&2&&setTimeout(function(){k=@,k-b>=c&&(b=k,g=h.apply(f,e))},c);return g}}'\n).replace(/@/g, '+new Date'));",
      "description": "Creates a debounced copy of the function which when called will delay the execution until the specified amount of milliseconds have elapsed since the last time it was called.",
      "params": [
        {
          "name": "fnCallback",
          "description": "The function to debounce. The context and parameters sent to the debounced function will be sent to this function.",
          "type": "Function"
        },
        {
          "name": "msWait",
          "description": "The amount of milliseconds that must pass since the last call to this function before really invoking `fnCallback`.",
          "type": "number"
        },
        {
          "name": "opt_initialAndAfter",
          "description": "Specify `true` if both the initial calls and the trailing calls should invoke the `fnCallback` function.  Specify `false` if only the initial calls should invoke the `fnCallback` function.  If not specified or specified as `null` or `undefined` only the trailing calls will invoke `fnCallback`.",
          "type": "boolean",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The debounced copy of `fnCallback`."
      },
      "requires": [
        "throttle"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "deburr",
      "code": "var deburr;\n(function(RGX_DEBURR, ARR_DEBURR, RGX_NON_SPACE) {\n  function replaceDeburrChar() {\n    return ARR_DEBURR[slice(arguments, 1).join(' ').search(RGX_NON_SPACE, '')];\n  }\n  deburr = function(str) {\n    return str.replace(RGX_DEBURR, replaceDeburrChar);\n  };\n})(\n  /([\\xc0-\\xc5\\u0100])|([\\xe0-\\xe5\\u0101])|([\\xc7\\u0106\\u010c])|([\\xe7\\u0107\\u010d])|(\\xd0\\u0110)|(\\xf0\\u0111)|([\\xc8-\\xcb\\u0112\\u0116\\u0118])|([\\xe8-\\xeb\\u0113\\u0117\\u0119])|([\\xcc-\\xcf\\u012a\\u012e])|([\\xec-\\xef\\u012b\\u012f])|([\\xd1\\u0143])|([\\xf1\\u0144])|([\\xd2-\\xd6\\xd8\\u014c])|([\\xf2-\\xf6\\xf8\\u014d])|([\\xd9-\\xdc\\u016a])|([\\xf9-\\xfc\\u016b])|([\\xdd\\u0178])|([\\xfd\\xff])|(\\xc6)|(\\xe6)|(\\xde)|(\\xfe)|(\\xdf)|(\\u0152)|(\\u0153)|(\\u0141)|(\\u0142)|([\\u02B9-\\u036F])/g,\n  'A,a,C,c,D,d,E,e,I,i,N,n,O,o,U,u,Y,y,Ae,ae,Th,th,ss,Oe,oe,L,l,'.split(','),\n  /\\S/\n);",
      "description": "Converts supplementary latin letters into basic latin letters, removing the diacritical marks.  In other words this normalizes a string.",
      "params": [
        {
          "name": "str",
          "description": "The string to be modified and returned without supplementary latin letters.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns a copy of `str` but with all of the following characters replaced by their corresponding basic latin letters:  `À`, `Á`, `Â`, `Ã`, `Ä`, `Å`, `Ā` convert to `A`.  `à`, `á`, `â`, `ã`, `ä`, `å`, `ā` convert to `a`.  `Ç`, `Ć`, `Č` convert to `C`.  `ç`, `ć`, `č` convert to `c`.  `Ð`, `Đ` convert to `D`.  `ð`, `đ` convert to `d`.  `È`, `É`, `Ê`, `Ë`, `Ē`, `Ė`, `Ę` convert to `E`.  `è`, `é`, `ê`, `ë`, `ē`, `ė`, `ę` convert to `e`.  `Ì`, `Í`, `Î`, `Ï`, `Ī`, `Į` convert to `I`.  `ì`, `í`, `î`, `ï`, `ī`, `į` convert to `i`.  `Ñ`, `Ń` convert to `N`.  `ñ`, `ń` convert to `n`.  `Ò`, `Ó`, `Ô`, `Õ`, `Ö`, `Ø`, `Ō` convert to `O`.  `ò`, `ó`, `ô`, `õ`, `ö`, `ø`, `ō` convert to `o`.  `Ù`, `Ú`, `Û`, `Ü`, `Ū` convert to `U`.  `ù`, `ú`, `û`, `ü`, `ū` convert to `u`.  `Ý`, `Ÿ` convert to `Y`.  `ý`, `ÿ` convert to `y`.  `Æ` converts to `Ae`.  `æ` converts to `ae`.  `Þ` converts to `Th`.  `þ` converts to `th`.  `ß` converts to `ss`.  `Œ` converts to `Oe`.  `œ` converts to `oe`.  `Ł` converts to `L`.  `ł` converts to `l`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "defaulter",
      "code": "",
      "description": "Creates a partial function which will always default to another value when non-values are passed to it.",
      "params": [
        {
          "name": "defaultValue",
          "description": "Value to default to if the value passed to the partial function is not sufficient.",
          "type": "*"
        },
        {
          "name": "opt_beStrict",
          "description": "Specifies whether or not to only check if the value passed to the partial function is `undefined`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "A partial function which will return either the value passed in or `defaultValue` based on the following criteria:  If `opt_beStrict` is `true`-ish and `value` is `undefined`, `defaultValue` will be returned.  If `opt_beStrict` is `false`-ish and `value` is `undefined`, `null` or `NaN`, `defaultValue` will be returned.  In all other cases `value` will be returned."
      },
      "requires": [
        "defaultTo"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "defaultTo",
      "code": "eval('function c?void 0===a:null==a||\"number\"===typeof a&&isNaN(a)return '.replace(/(.{9})(.+)(.{7})/, '$1canDefault(a,c){$3$2}$1defaultTo(a,b,c){$3($2)?b:a}$1defaulter(b,c){$3$1(a){$3($2)?b:a}}'));",
      "description": "Defaults specific non-values to another given value.",
      "params": [
        {
          "name": "value",
          "description": "Value to test out.",
          "type": "*"
        },
        {
          "name": "defaultValue",
          "description": "Value to default to if `value` is not sufficient.",
          "type": "*"
        },
        {
          "name": "opt_beStrict",
          "description": "Specifies whether or not to only check if `value` is `undefined`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `opt_beStrict` is `true`-ish and `value` is `undefined`, `defaultValue` will be returned.  If `opt_beStrict` is `false`-ish and `value` is `undefined`, `null` or `NaN`, `defaultValue` will be returned.  In all other cases `value` will be returned."
      },
      "requires": [
        "canDefault",
        "defaulter"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "defer",
      "code": "function defer(fn, opt_args) {\n  var objThis = this;\n  opt_args = slice(opt_args || []);\n  return setTimeout(function() { fn.apply(objThis, opt_args); }, 0);\n}",
      "description": "Defers calling a function until the current call stack is done.  Similar to using the global `setTimeout` function.",
      "params": [
        {
          "name": "fn",
          "description": "Function whose call will be deferred until after all other calls in the current stack are done.",
          "type": "Function"
        },
        {
          "name": "opt_args",
          "description": "Array of the arguments to be passed to `fn`.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "number",
        "description": "The `timeoutID` associated with the deferred call.  If passed to the global `clearTimeout` while the function is being deferred the deferred function will not be called."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Check deferred change in 100ms",
          "code": "var value, newValue = Math.random();\nYourJS.defer(function(input){ value = input; }, [newValue]);\nif (value === newValue) {\n  test('defer never happened');\n}\nsetTimeout(function() {\n  test(value, newValue);\n}, 100);"
        }
      ]
    },
    {
      "name": "degrees",
      "code": "function degrees(radians) {\n  return radians * 180 / Math.PI;\n}",
      "description": "Converts radians to degrees.",
      "params": [
        {
          "name": "radians",
          "description": "The number representing radians of in angle which will be converted to degrees.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The equivalent of `radians` in degrees."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "delay",
      "code": "function delay(fn, msDelay, opt_args) {\n  var objThis = this;\n  opt_args = slice(opt_args || []);\n  return setTimeout(function() { fn.apply(objThis, opt_args); }, msDelay);\n}",
      "description": "Calls a function after a given amount of time.  This is very similar to the global `setTimeout` function.",
      "params": [
        {
          "name": "fn",
          "description": "Function to call after a certain amount of time.",
          "type": "Function"
        },
        {
          "name": "msDelay",
          "description": "Delay in milliseconds before `fn` is actually called.",
          "type": "number"
        },
        {
          "name": "opt_args",
          "description": "An array of the arguments to pass to `fn`.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "number",
        "description": "The `timeoutID` corresponding to this delayed function call.  The global `clearTimeout` function can be used to cancel this delayed call."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Delay call",
          "code": "var delayCalled;\nYourJS.delay(function(){ delayCalled = true; }, 500);\nif (delayCalled) {\n  test(true, false);\n}\nelse {\n  setTimeout(function() {\n    test(delayCalled, true);\n  }, 600);\n}"
        }
      ]
    },
    {
      "name": "deleteAt",
      "code": "function deleteAt(root, path) {\n  var objs = [root].concat(testAt(root, path)),\n      l = path.length - 1;\n  return (l + 1 && objs.length - 2 === l) ? delete objs[l][path[l]] : false;\n}",
      "description": "Tries to delete the value at the specified `path` starting at `root`.",
      "params": [
        {
          "name": "root",
          "description": "Root object at which the `path` to delete from will start.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "Array of numbers/strings that represents the path to the value that should be deleted.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if the value can be deleted from the specified `path` under `root`, otherwise `false`."
      },
      "requires": [
        "testAt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "deleteKeys",
      "code": "function deleteKeys(obj, keys) {\n  function deleteKeys(obj) {\n    obj = Object(obj);\n    for (var value, key, result = {}, i = keys.length; i--; ) {\n      if (has(obj, key = keys[i])) {\n        value = obj[key];\n        if (delete obj[key]) {\n          result[key] = value;\n        }\n      }\n    }\n    return result;\n  }\n  return obj == undefined ? deleteKeys : deleteKeys(obj);\n}",
      "description": "Deletes one or more keys from an object of some sort.",
      "params": [
        {
          "name": "obj",
          "description": "If `undefined` or `null`, a partial function waiting for this value will be returned.  Otherwise this will be the object from which the specified keys will be deleted.",
          "type": "Object|undefined|null"
        },
        {
          "name": "keys",
          "description": "Array of keys to be deleted from `obj`.",
          "type": "Arrays"
        }
      ],
      "return": {
        "type": "Function|Object",
        "description": "If `obj` is `undefined` or `null` this will be a partial function which will simply accept the given `obj`.  The return value of the partial function is the same as the return value of this function in the case that `obj` is not `undefined` or `null`.  All keys that are found and successfully deleted will be returned within an object."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "dice",
      "code": "function dice(str, delim, opt_limit) {\n  var arr = [], start = 0, i;\n  if (str) {\n    str.replace(\n      (typeOf(delim) == 'RegExp' ? modRegExp : quoteRegExp)(delim, 'g'),\n      function(m) {\n        i = arguments;\n        i = i[i.length - 2];\n        if (!(opt_limit-- < 1)) {\n          arr.push(str.slice(start, i));\n          start = i + (m.length || 1);\n        }\n      }\n    );\n    arr.push(str.slice(start));\n  }\n  return arr;\n}",
      "description": "Dices up a string splitting it on the passed in delimiter and placing the results in an array while making sure that the empty string is converted to an empty array.",
      "params": [
        {
          "name": "str",
          "description": "The string to be diced and turned into an array of strings.",
          "type": "string"
        },
        {
          "name": "delim",
          "description": "The regular expression or string to be used as a delimiter in order to dice up `str`. The matched substrings will not be included in the strings returned in the array.",
          "type": "RegExp|string"
        },
        {
          "name": "opt_limit",
          "description": "If specified, this number represents the maximum number of times `str` will be split on `delim`. Unlike with `String.prototype.split()`, the remaining substring after this limit will simply be placed in the last element of the array.",
          "type": "number",
          "optional": true,
          "default": "Infinity"
        }
      ],
      "return": {
        "type": "Array.<string>",
        "description": "Returns an array of substrings formed by dicing (splitting) up `str` by `delim`. If `str` is an empty string, an empty array will be returned."
      },
      "requires": [
        "typeOf",
        "modRegExp",
        "quoteRegExp"
      ],
      "required": false,
      "tests": [
        {
          "name": "Empty String",
          "code": "test(JSON.stringify(YourJS.dice('', ',')), '[]');"
        },
        {
          "name": "Simple String",
          "code": "test(JSON.stringify(YourJS.dice('Abe Bob Car', ' ')), '[\"Abe\",\"Bob\",\"Car\"]');"
        },
        {
          "name": "One Item",
          "code": "test(JSON.stringify(YourJS.dice('Abe', ',')), '[\"Abe\"]');"
        }
      ]
    },
    {
      "name": "diffArrays",
      "code": "function diffArrays(array1, array2) {\n  array1 = slice(array1);\n  array2 = slice(array2);\n  for (var e1, i1 = 0, l1 = array1.length, i2, l2 = array2.length; i1 < l1; i1++) {\n    e1 = array1[i1];\n    for (i2 = 0; i2 < l2; i2++) {\n      if (e1 === array2[i2]) {\n        l1--;\n        array1.splice(i1--, 1);\n        l2--;\n        array2.splice(i2--, 1);\n        break;\n      }\n    }\n  }\n  return array1;\n}",
      "description": "Creates a new array which is the difference of the two given arrays.",
      "params": [
        {
          "name": "array1",
          "description": "Array containing the values that will be returned if they are not found in `array2`.",
          "type": "Array"
        },
        {
          "name": "array2",
          "description": "Array whose values will be compared to those in `array1` and only those that appear in `array1` and not in this array will be returned.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A new array with values from `array1` that are not in `array2`."
      },
      "requires": [
        "is",
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Remove Values",
          "code": "test(JSON.stringify(YourJS.diffArrays([2,3,4,3,5,6], [3,5,7])), '[2,4,3,6]');"
        }
      ]
    },
    {
      "name": "diffDates",
      "code": "function diffDates(dEnd, dStart, opt_onlyRemainder) {\n  var t = dEnd < dStart, multiplier = t ? -1 : 1;\n  if (t) {\n    t = dEnd;\n    dEnd = dStart;\n    dStart = t;\n  }\n\n  var years = dEnd.getFullYear() - dStart.getFullYear();\n  t = new Date(+dStart);\n  t.setFullYear(dEnd.getFullYear());\n  if (t.getDate() != dStart.getDate() || t.getMonth() != dStart.getMonth()) {\n    t.setDate(0);\n  }\n  if (dEnd < t) {\n    years--;\n    t.setFullYear(dEnd.getFullYear() - 1);\n    t.setDate(dStart.getDate());\n    if (t.getDate() != dStart.getDate()) {\n      t.setDate(0);\n    }\n  }\n  \n  var months = (opt_onlyRemainder ? 0 : (years * 12)) + dEnd.getMonth() - dStart.getMonth();\n  t = new Date(+dEnd);\n  t.setFullYear(dStart.getFullYear());\n  t.setDate(dEnd.getDate());\n  t.setMonth(dStart.getMonth());\n  if (t.getDate() != dEnd.getDate() || t.getMonth() != dStart.getMonth()) {\n    t.setDate(0);\n  }\n  if (dStart > t) {\n    --months;\n    t.setDate(dEnd.getDate());\n    t.setMonth(dStart.getMonth() + 1);\n    if (t.getDate() != dEnd.getDate()) {\n      t.setDate(0);\n    }\n  }\n  if (opt_onlyRemainder || months < 0) {\n    months = (months + 12) % 12;\n  }\n  \n  t = (opt_onlyRemainder ? t : dEnd) - dStart;\n\n  var days = Math.floor(t / 864e5);\n  var hours = Math.floor(t / 36e5) % (opt_onlyRemainder ? 24 : Infinity);\n  var minutes = Math.floor(t / 6e4) % (opt_onlyRemainder ? 60 : Infinity);\n  var seconds = Math.floor(t / 1e3) % (opt_onlyRemainder ? 60 : Infinity);\n  var ms = t % (opt_onlyRemainder ? 1e3 : Infinity);\n\n  t = {\n    start: multiplier + 1 ? dStart : dEnd,\n    end: multiplier + 1 ? dEnd : dStart,\n    years: multiplier * years,\n    months: multiplier * months,\n    days: multiplier * days,\n    hours: multiplier * hours,\n    minutes: multiplier * minutes,\n    seconds: multiplier * seconds,\n    milliseconds: multiplier * ms\n  };\n  if (opt_onlyRemainder) {\n    t.weekDays = t.days % 7;\n    t.weeks = Math.floor(multiplier * t.days / 7) * multiplier;\n  }\n  return t;\n}",
      "description": "Finds the differents between 2 dates.",
      "params": [
        {
          "name": "dEnd",
          "description": "Ending date.",
          "type": "Date"
        },
        {
          "name": "dStart",
          "description": "Starting date.",
          "type": "Date"
        },
        {
          "name": "opt_onlyRemainder",
          "description": "Determines whether or not the values returned will show the remainder values instead of the full values for each unit of measure.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Object",
        "description": "An object containing all of the following measurements in the corresponding object properties: `years`, `months`, `days`, `hours`, `minutes` and `seconds`.  If `opt_onlyRemainder` is specified as `true` all of the object's properties will not include the measures for the next highest unit of measure.  If `op_onlyRemainder` is supplied `weekDays` and `weeks` are added to this returned object.  If `opt_onlyRemainder` is not specified or is `false` all of the object's properties will individual calculations indicating the difference in time."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "divide",
      "code": "",
      "description": "Finds the quotient of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be divided by `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to divide by `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given the quotient of the two will be returned.  Otherwise a partial function will be returned which when called will accept one number and will return the number passed to the partial function divided by `number1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "doEvery",
      "code": "function doEvery(fn, msDelay, opt_args, opt_immediate) {\n  function caller() { fn.apply(objThis, opt_args); }\n  var objThis = this;\n  opt_args = slice(opt_args || []);\n  if (opt_immediate) {\n    try { caller(); }\n    catch (e) { setTimeout(function(){throw e;}, 0); }\n  }\n  return setInterval(caller, msDelay);\n}",
      "description": "Execute a function every so often.  Similar to `setTimeout`.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be executed every so often.",
          "type": "Function"
        },
        {
          "name": "msDelay",
          "description": "Number of milliseconds between calls to `fn`.",
          "type": "number"
        },
        {
          "name": "opt_args",
          "description": "Arguments to be passed to `fn` every time it is called.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        },
        {
          "name": "opt_immediate",
          "description": "Specifies whether or not an immediate call should occur.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The `timeoutID` associated with the ongoing process of running this function.  To stop calling `fn` you can use `clearInterval(timeoutID)`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "dom",
      "code": "var dom;\n(function(RGX_DASH, INNER_TEXT, TEXT_CONTENT, PROP_HASH) {\n  function capAfterDash(m, afterDash) {\n    return afterDash.toUpperCase();\n  }\n  dom = function(input) {\n    var elem, realPropName, propName, propValue, i, l, j, c, style, stylePropName, kids;\n    if (typeOf(input) == 'String') {\n      elem = slice(dom({ _: 'DIV', html: input }).childNodes);\n    }\n    else {\n      elem = __DOCUMENT.createElement(input.nodeName || input._);\n      for (realPropName in input) {\n        propValue = input[realPropName];\n        if (has(input, realPropName) && (propName = has(PROP_HASH, realPropName) ? PROP_HASH[realPropName] : realPropName) != '_') {\n          if (propName == 'style') {\n            style = elem[propName];\n            if (typeOf(propValue) == 'String') {\n              style.cssText = propValue;\n            }\n            else {\n              for (stylePropName in propValue) {\n                if (has(propValue, stylePropName)) {\n                  style[stylePropName.replace(RGX_DASH, capAfterDash)] = propValue[stylePropName];\n                }\n              }\n            }\n          }\n          else if (propName == INNER_TEXT || propName == TEXT_CONTENT) {\n            elem[TEXT_CONTENT] = elem[INNER_TEXT] = propValue;\n          }\n          else if (propName == '$') {\n            propValue = toArray(propValue);\n            for (i = 0, l = propValue.length; i < l;) {\n              for (kids = toArray(dom(propValue[i++])), j = 0, c = kids.length; j < c;) {\n                elem.appendChild(kids[j++]);\n              }\n            }\n          }\n          else {\n            elem[propName] = propValue;\n            if (propName == realPropName && elem.getAttribute(propName) == undefined && 'function' != typeof propValue) {\n              elem.setAttribute(propName, propValue);\n            }\n          }\n        }\n      }\n    }\n    return elem;\n  };\n})(/-([^-])/g, 'innerText', 'textContent',\n  {nodeName:'_',html:'innerHTML',text:'innerText',children:'$','for':'htmlFor','class':'className',cls:'className'});",
      "description": "Creates HTML DOM objects.",
      "params": [
        {
          "name": "input",
          "description": "The value that will be converted to DOM objects.  If a string, it will be interpreted as raw HTML.  Otherwise this must be an object specifying at least the `nodeName` (or `_`) property.  To represent an element with child nodes you can set the `children` (or `$`) property to an `input` object, `input` string, or array of `input` strings and/or objects that will be recursively interpreted.  The `html` property will be interpreted as the `innerHTML` property.  The `text` property will be interpreted ass the `innerText` and `textContent` properties.  The `cls` property will be interpreted as the element's class name.",
          "type": "string|Object"
        }
      ],
      "return": {
        "type": "Array.<Node>|HTMLElement",
        "description": "If `input` was a string an array of nodes represented in that string will be returned.  Otherwise the element represented by `input` will be returned."
      },
      "requires": [
        "has",
        "typeOf",
        "toArray"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  YourJS.dom({_:'div',$:{nodeName:'div',text:'1>2'}}).innerHTML.toLowerCase(),\n  '<div>1&gt;2</div>'\n);"
        }
      ]
    },
    {
      "name": "dow",
      "code": "function dow(date, opt_firstDayOfWeek) {\n  return ((date.getDay() - (opt_firstDayOfWeek || 0)) % 7 + 7) % 7;\n}",
      "description": "Gets the day of the week for the specified date.  This is different from `Date.prototype.getDay()` because it allows for the first day of the week to be days other than Sunday.",
      "params": [
        {
          "name": "date",
          "description": "Date object from which to pull the day of the week.",
          "type": "Date"
        },
        {
          "name": "opt_firstDayOfWeek",
          "description": "Indicates what the first day of the week is.  If given it should be between `0` (for Sunday) and `6` (for Saturday).",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "A number between `0` and `6`.  `0` will always correspond to the value of `opt_firstDayOfWeek` whereas `1` will be the next day and so on."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var d = new Date;\ntest(d.getDay(), YourJS.dow(d));"
        },
        {
          "name": "Start on Monday",
          "code": "var firstOfWeek = 1;\nvar d = new Date;\nvar dow = (d.getDay() - firstOfWeek + 7) % 7;\ntest(dow, YourJS.dow(d, firstOfWeek));"
        }
      ]
    },
    {
      "name": "endOfDay",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and day of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and day.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and day contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfFridayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Friday to Thursday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Friday to Thursday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Friday to Thursday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfHour",
      "code": "",
      "description": "Determines the latest date-time of the year, month, day, and hour of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, and hour.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, day, and hour contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfMinute",
      "code": "",
      "description": "Determines the latest date-time of the year, month, day, hour, and minute of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, hour, and minute.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, day, hour, and minute contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfMondayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Monday to Sunday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Monday to Sunday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Monday to Sunday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfMonth",
      "code": "",
      "description": "Determines the latest date-time of the year and month of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year and month.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year and month contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfSaturdayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Saturday to Friday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Saturday to Friday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Saturday to Friday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfSecond",
      "code": "",
      "description": "Determines the latest date-time of the year, month, day, hour, minute, and second of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, hour, minute, and second.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, day, hour, minute, and second contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfSundayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Sunday to Saturday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Sunday to Saturday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Sunday to Saturday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfThursdayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Thursday to Wednesday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Thursday to Wednesday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Thursday to Wednesday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfTuesdayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Tuesday to Monday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Tuesday to Monday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Tuesday to Monday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfWednesdayWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Wednesday to Tuesday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Wednesday to Tuesday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Wednesday to Tuesday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfWeek",
      "code": "",
      "description": "Determines the latest date-time of the year, month, and week (Sunday to Saturday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Sunday to Saturday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year, month, and week (Sunday to Saturday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endOfYear",
      "code": "",
      "description": "Determines the latest date-time of the year of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The latest date-time of the year contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "endsWith",
      "code": "function endsWith(string, target, opt_length) {\n  opt_length = opt_length != undefined ? opt_length || 0 : string.length;\n  if (opt_length < 0) {\n    opt_length += string.length;\n    if (opt_length < 0) {\n      opt_length = 0;\n    }\n  }\n  return string.slice(opt_length - ('' + target).length, opt_length) === target;\n}",
      "description": "Determines whether a string ends with the characters of a specified string.",
      "params": [
        {
          "name": "string",
          "description": "The string that will be searched.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "The characters to be searched for at the end of `string`.",
          "type": "string"
        },
        {
          "name": "opt_length",
          "description": "If provided it is used as the length of `string`. If omitted, the default value is the length of `string`.",
          "type": "number",
          "optional": true,
          "default": "string.length"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean value indicating whether or not `target` is found at the end of `string`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "ensureAt",
      "code": "function ensureAt(root, path, opt_value) {\n  for (var k, o = root, i = 0, l = o == undefined ? i : path.length, m = l - 1; i < l; i++) {\n    o = has(o, k = path[i])\n      ? o[k]\n      : (o[k] = i === m ? opt_value : {});\n  }\n  return root;\n}",
      "description": "Is similar to `setAt()` but always ensures that the specified path will be added to the root object.",
      "params": [
        {
          "name": "root",
          "description": "The object under which to ensure the path.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "An array of numbers or strings representing the path that must exist within `root`.",
          "type": "Array"
        },
        {
          "name": "opt_value",
          "description": "If given this will be the value assigned to the specified path, otherwise `undefined` is assigned.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "*",
        "description": "A reference to `root`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var o = { name: { first: 'Chris' } };\nYourJS.ensureAt(o, ['name', 'last'], 'West');\nconsole.log(o);\ntest(o.name.last, 'West');"
        }
      ]
    },
    {
      "name": "entries",
      "code": "function entries(value, opt_onlyNonEnums) {\n  for (var result = keys(value, opt_onlyNonEnums), i = result.length; i--;) {\n    result[i] = [result[i], value[result[i]]];\n  }\n  return result;\n}",
      "description": "Gets an array of pairs (array of length 2) indicating all of the keys and values within a given array or object.",
      "params": [
        {
          "name": "value",
          "description": "Value for which you would like the property names retrieved.",
          "type": "*"
        },
        {
          "name": "opt_onlyNonEnums",
          "description": "If specified and is not `null` or `undefined` but is `false`-ish, all of the property key/value pairs (enumerable or not) will be returned.  If this is `true`-ish only the non-enumerable property key/value pairs will be returned.  If this is not given or is `null` or `undefined` all of the enumerable property key/value pairs will be returned.",
          "type": "boolean",
          "optional": true,
          "default": ""
        }
      ],
      "return": {
        "type": "Array.<Array>",
        "description": "An array of pairs (arrays where the first item is the key and the second is the value)."
      },
      "requires": [
        "keys"
      ],
      "required": false,
      "tests": [
        {
          "name": "Sparse Array",
          "code": "var arr = [5];\narr[9] = \"7\";\narr[13] = 11;\ntest(JSON.stringify(YourJS.entries(arr)), '[[\"0\",5],[\"9\",\"7\"],[\"13\",11]]');"
        }
      ]
    },
    {
      "name": "eq",
      "code": "",
      "description": "Determines if one value is equal to (`==`) another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is equal to (`==`) `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is equal to (`==`) `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is equal to (`==`) `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is equal to (`==`) `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "eqs",
      "code": "",
      "description": "Determines if one value is strictly equal to (`===`) another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is strictly equal to (`===`) `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is strictly equal to (`===`) `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is strictly equal to (`===`) `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is strictly equal to (`===`) `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "escape",
      "code": "function escape(str) {\n  return encodeURIComponent(str)\n    .replace(/!/g, '%21')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29')\n    .replace(/\\*/g, '%2A')\n    .replace(/%20/g, '+');\n}",
      "description": "Encodes a string to be used in a query part of a URL.",
      "params": [
        {
          "name": "str",
          "description": "String to encode.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "Encoded string that can be used in the query part of a URL."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.escape('Hello world!'), 'Hello+world%21');"
        }
      ]
    },
    {
      "name": "exec",
      "code": "function exec(fn, opt_this) { return fn.apply(opt_this, slice(arguments, 2)), fn; }",
      "description": "Calls a function and returns it so it can be called again.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be called and returned.  The return value of this function will be ignored when it is called.",
          "type": "Function"
        },
        {
          "name": "opt_this",
          "description": "Value referenced by `this` in evaluation of `fn`.",
          "type": "*",
          "optional": true
        },
        {
          "name": "opt_args",
          "description": "Zero or more arguments to be passed to `fn`.",
          "type": "*",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "Function",
        "description": "After executing `fn` it will be returned."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "execAll",
      "code": "",
      "description": "Gets all of the matches found when matching a regular expression against a string.",
      "params": [
        {
          "name": "rgx",
          "description": "Regular expression to match against `str`.",
          "type": "RegExp"
        },
        {
          "name": "str",
          "description": "String against which the regular expression should be matched.",
          "type": "string"
        },
        {
          "name": "opt_fnMapper",
          "description": "If specified the return value of this function will always be appended to the array which will be returned by `matchAll()` unless `undefined` is the return value.  The 1st argument passed will be an array representing the matches array that was found.  The 2nd argument passed will be the amount of times this mapper has been called.",
          "type": "function(Array,number)",
          "optional": true
        }
      ],
      "return": {
        "type": "Array|null",
        "description": "If `rgx` matched a substring in `str` at least once and `opt_fnMapper` wasn't used, an array of all of the matches will be returned. Each match will at least have `match[0]`, `match.index` (the starting index of the found match within `str`), `match.source` (`rgx`) and `match.input` (`str`). If capture groups were specified in `rgx`, each will be found in its corresponding index starting with `match[1]`. If no matches were found, `null` is returned."
      },
      "requires": [
        "matchAll"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "expandRegExp",
      "code": "var expandRegExp;\n(function(store, casingInitialized) {\n  function addTo(groupName, index) {\n    var arr = !has(store, groupName += 'case') ? store[groupName] = [] : store[groupName];\n    var last = store['~' + groupName];\n    if (last && last[last.length - 1] + 1 === index) {\n      last[1] = index;\n    }\n    else {\n      arr.push(store['~' + groupName] = [index]);\n    }\n  }\n\n  function makeCasingRanges() {\n    for (var ch, lower, upper, groupName, i = 0; i <= 0xFFFF; i++) {\n      ch = String.fromCharCode(i);\n      lower = ch.toLowerCase();\n      upper = ch.toUpperCase();\n      groupName = upper === lower ? 'no' : upper === ch ? 'upper' : lower === ch ? 'lower' : 'mix';\n      addTo(groupName, i);\n    }\n    ['upper', 'lower', 'mix', 'no'].forEach(function (name) {\n      name += 'case';\n      store[name] = store[name].map(function(range) {\n        return range.map(function(value) {\n          return '\\\\u' + ('000' + value.toString(16)).slice(-4);\n        }).join('-');\n      }).join('');\n    });\n  }\n\n  expandRegExp = function(rgxOrExtName, opt_extension) {\n    if (typeOf(rgxOrExtName) === 'RegExp') {\n      var oldSource,\n          newSource = rgxOrExtName.source,\n          flags = (rgxOrExtName + '').replace(/[^]+\\/(\\w*)$/, '$1');\n      do {\n        oldSource = newSource;\n        newSource = oldSource.replace(\n          /\\[:(\\w+):\\]/g,\n          function(m, name) {\n            if (!casingInitialized && /^(upper|lower|mix|no)case$/.test(name)) {\n              makeCasingRanges();\n              casingInitialized = 1;\n            }\n            return has(store, name) ? store[name] : m;\n          }\n        );\n      } while (oldSource !== newSource);\n      rgxOrExtName = rgxOrExtName.source.replace(/\\[\\]/);\n      return new RegExp(newSource, flags);\n    }\n    else if (oldSource = /^\\w+$/.test(rgxOrExtName)) {\n      store[rgxOrExtName] = opt_extension.replace(/\\\\?]/g, '\\\\]');\n    }\n    return oldSource;  // works cuz of hoisting\n  };\n})({\n  space: '\\\\s',\n  alpha: 'A-Za-z',\n  punct: '!\"\\#$%&\\'()*+,\\\\-./:;<=>?@\\\\[\\\\\\\\\\\\]^_`{|}~',\n  digit: '\\\\d',\n  alnum: 'A-Za-z\\\\d',\n  xdigit: 'A-Fa-f0-9'\n});",
      "description": "Expands regular expressions by expanding the character classes.  Supports `[:alnum:]`, `[:alpha:]`, `[:digit:]`, `[:punct:]`, `[:space:]`, or `[:xdigit:]` and allows for addition of other character classes.",
      "params": [
        {
          "name": "rgxOrCharClsName",
          "description": "Regular expression or name of the character class to add to future regular expressions passed to this function.",
          "type": "RegExp|string"
        },
        {
          "name": "opt_charClass",
          "description": "If `rgxOrCharClsName` is a string this should be defined and should be the definition of the character class without brackets.  This character class will be added and will be used to expand future regular expressions passed into this function.",
          "type": "string",
          "optional": true
        }
      ],
      "return": {
        "type": "RegExp|boolean",
        "description": "If `rgxOrCharClsName` is a regular expression this will be a modified version of it with the character classes expanded, otherwise this will be a boolean value indicating if the character class was successfully added."
      },
      "requires": [
        "has",
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  YourJS.expandRegExp(/^[[:digit:]]+$/).test(9876543210),\n  YourJS.expandRegExp(/^[[:xdigit:]]+$/).test('0123456789aBcDeF')\n);"
        }
      ]
    },
    {
      "name": "extend",
      "code": "function extend(objToExtend, objProps) {\n  for (var k, args = arguments, i = 1; objProps = args[i++]; ) {\n    for (k in objProps) {\n      if (has(objProps, k)) {\n        objToExtend[k] = objProps[k];\n      }\n    }\n  }\n  return objToExtend;\n}",
      "description": "Adds extra properties to an object based on the properties owned by other specified objects.",
      "params": [
        {
          "name": "objToExtend",
          "description": "Object to be modified.",
          "type": "Object"
        },
        {
          "name": "objPropsX",
          "description": "One or more arguments where each one's properties will be added to `objToExtend`.",
          "type": "Object",
          "rest": true
        }
      ],
      "return": {
        "type": "Object",
        "description": "A reference to `objToExtend`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "fill",
      "code": "function fill(arr, value, opt_start, opt_end) {\n  var len = arr.length;\n  opt_start = opt_start < 0 ? Math.max(len + opt_start, 0) : (opt_start || 0);\n  for (\n    opt_end = opt_end < 0\n      ? Math.max(len + opt_end, 0)\n      : (opt_end || opt_end === 0 ? Math.min(opt_end, len) : len);\n    opt_start < opt_end;\n    opt_start++\n  ) { arr[opt_start] = value; }\n  return arr;\n}",
      "description": "Fill an array with a given value.",
      "params": [
        {
          "name": "arr",
          "description": "Array to fill.",
          "type": "Array"
        },
        {
          "name": "value",
          "description": "Value with which to fill `arr`.",
          "type": "*"
        },
        {
          "name": "opt_start",
          "description": "Starting position within `arr` at which to fill `arr`.  If it is negative it will be calculated from the end of `arr`.",
          "type": "number",
          "optional": true,
          "default": "0"
        },
        {
          "name": "opt_end",
          "description": "Ending position within `arr` at which to no longer fill `arr`.  If it is negative it will be calculated from the end of `arr`.",
          "type": "number",
          "optional": true,
          "default": "arr.length"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A reference to `arr`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  JSON.stringify(YourJS.fill(new Array(10), 5, 1, -1)),\n  '[null,5,5,5,5,5,5,5,5,null]'\n);"
        }
      ]
    },
    {
      "name": "filter",
      "code": "function filter(arrOrObj, test, opt_this) {\n  var result;\n  if (isArrayLike(arrOrObj = Object(arrOrObj))) {\n    result = [];\n    for (var i = 0, l = arrOrObj.length; i < l; i++) {\n      if (has(arrOrObj, i) && test.call(opt_this, arrOrObj[i], i, arrOrObj)) {\n        result.push(arrOrObj[i]);\n      }\n    }\n  }\n  else {\n    result = {};\n    for (var k in arrOrObj) {\n      if (has(arrOrObj, k) && test.call(opt_this, arrOrObj[k], k, arrOrObj)) {\n        result[k] = arrOrObj[k];\n      }\n    }\n  }\n  return result;\n}",
      "description": "Creates a new object or a new array based on the specified object array.  This new array will only have the values which pass the test function.",
      "params": [
        {
          "name": "arrOrObj",
          "description": "Array (or array-like object) or object which will be duplicated with only the values that pass the `test` function.",
          "type": "Array|Object"
        },
        {
          "name": "test",
          "description": "Function that will be called for every value in `arrOrObj` and whose return value for each call will be coerced to a boolean and used to determine if the value will be kept in the resulting array or object returned by `filter()`.  Only return values that are `true`-ish will be kept. The first argument passed will be the value that is being tested.  The second argument passed will be the index or key of the value that is being tested.  The third argument passed will be `arrOrObj`.  The `this` keyword will reference `opt_this`.",
          "type": "Function"
        },
        {
          "name": "opt_this",
          "description": "If not given or `undefined` or `null`, the global object will be used.  If given as a primitive, the object version of the value will be used.  This object will be used as `this` within `test()`.",
          "type": "*",
          "optional": true,
          "default": "global"
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "If `arrOrObj` is an array (or an array-like object) then an array with the filtered values will be returned.  Otherwise an object with the filtered values will be returned."
      },
      "requires": [
        "isArrayLike",
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Test object",
          "code": "var obj = { a: 0, b: null, c: undefined, d: false, e: 'Hello' };\nvar obj2 = YourJS.filter(obj, function(v) { return 'number' === typeof v; });\nvar objCheck = { a: 0 };\ntest(JSON.stringify(objCheck), JSON.stringify(obj2));"
        },
        {
          "name": "Test array",
          "code": "var arr = [1,true,/s/,null,undefined,'sdf'];\nvar arr2 = YourJS.filter(arr, function(v) { return 'string' === typeof v; });\nvar arrCheck = ['sdf'];\ntest(JSON.stringify(arrCheck), JSON.stringify(arr2));"
        }
      ]
    },
    {
      "name": "filterByProp",
      "code": "",
      "description": "Looks for all of the items in an array whose given property matches the criteria.",
      "params": [
        {
          "name": "array",
          "description": "Array to traverse.",
          "type": "Array"
        },
        {
          "name": "propName",
          "description": "Name of the property of each `array` item to inspect.  If no such property exists for any `array` item that item will simply be skipped.",
          "type": "string"
        },
        {
          "name": "tester",
          "description": "Criteria by which to test the property of each item in `array`.  If this is a function it will be passed the value of the property and the return value will be coerced to a boolean to see if the property fits the criteria.  If this is a regular expression it will be tested against the property to see if the property fits the criteria.  Any other type of value will be checked to see if the property is this value to see if it fits the criteria.",
          "type": "*"
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of the items in `array` for which `tester` matches the specified property."
      },
      "requires": [
        "findByProp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "filterMap",
      "code": "function filterMap(arr, fn, opt_badValue) {\n  for (var result, value, isBadValueNaN = opt_badValue !== opt_badValue, ret = [], i = 0, l = arr.length; i < l; i++) {\n    if (i in arr) {\n      result = fn(value = arr[i], i, arr);\n      if (isBadValueNaN ? result === result : result !== opt_badValue) {\n        ret.push(result);\n      }\n    }\n  }\n  return ret;\n}",
      "description": "Filters the contents of an array and then returns the remaining values mapped as different or possibly the same values.",
      "params": [
        {
          "name": "array",
          "description": "The array which will be shallow copied, filtered and sent back with possibly modified values based on `func`.",
          "type": "Array"
        },
        {
          "name": "func",
          "description": "The function which will called for each value that is in a defined index in `array`.  The function will be passed (1) the value to be examined, (2) the index of that value and (3) a reference to `array`.  If the function returns any value that is not the same as `opt_badValue`, that value will be appended to the end of the array that will be returned.",
          "type": "Function"
        },
        {
          "name": "opt_badValue",
          "description": "The value that if returned by `func` it will not be appended to the array to be returned.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A non-sparse array of all of the values that were filtered and mapped back from `array` based on `func` and `opt_badValue`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple Test",
          "code": "var arr = [1,2,3,4,5,6,7,8,9];\nvar arr2 = YourJS.filterMap(arr, function(x) {\n  if (x % 3) {\n    return x * 2;\n  }\n});\ntest(arr2.join(','), '2,4,8,10,14,16');"
        }
      ]
    },
    {
      "name": "findByProp",
      "code": "var findByProp = Function('T,I', ('return [find,findIndex,filter]').replace(/\\w+(?=,|\\])/g, 'function $&ByProp(d,e,a){var b=T(a),f=\"RegExp\"===b,g=\"Function\"===b||I(a)&&(a=isNaN);return d.$&(function(b,d){if(void 0==b)return!1;var c=b[e];return f?a.test(c):g?a(c):c===a})}'))(typeOf, isNaN),\n    filterByProp = findByProp[2],\n    findIndexByProp = findByProp[1];\nfindByProp = findByProp[0];",
      "description": "Looks for the first value in an array whose given property matches the criteria.",
      "params": [
        {
          "name": "array",
          "description": "Array to traverse.",
          "type": "Array"
        },
        {
          "name": "propName",
          "description": "Name of the property of each `array` item to inspect.  If no such property exists for any `array` item that item will simply be skipped.",
          "type": "string"
        },
        {
          "name": "tester",
          "description": "Criteria by which to test the property of each item in `array`.  If this is a function it will be passed the value of the property and the return value will be coerced to a boolean to see if the property fits the criteria.  If this is a regular expression it will be tested against the property to see if the property fits the criteria.  Any other type of value will be checked to see if the property is this value to see if it fits the criteria.",
          "type": "*"
        }
      ],
      "return": {
        "type": "*",
        "description": "The first item in `array` for which `tester` matches the specified property.  If `tester` never matches any of the properties `undefined` will be returned."
      },
      "requires": [
        "isNaN",
        "typeOf",
        "findIndexByProp",
        "filterByProp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "findIndexByProp",
      "code": "",
      "description": "Looks for the first index in an array whose given property matches the criteria.",
      "params": [
        {
          "name": "array",
          "description": "Array to traverse.",
          "type": "Array"
        },
        {
          "name": "propName",
          "description": "Name of the property of each `array` item to inspect.  If no such property exists for any `array` item that item will simply be skipped.",
          "type": "string"
        },
        {
          "name": "tester",
          "description": "Criteria by which to test the property of each item in `array`.  If this is a function it will be passed the value of the property and the return value will be coerced to a boolean to see if the property fits the criteria.  If this is a regular expression it will be tested against the property to see if the property fits the criteria.  Any other type of value will be checked to see if the property is this value to see if it fits the criteria.",
          "type": "*"
        }
      ],
      "return": {
        "type": "number",
        "description": "The first index in `array` for which `tester` matches the specified property.  If `tester` never matches any of the properties `-1` will be returned."
      },
      "requires": [
        "findByProp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "findNth",
      "code": "eval('var findNthIndex,findNth;(function(z,y){=function(b,c,e){var f=0>e,h=\"RegExp\"===typeOf(c);var a=\"String\"===typeOf(b);h&&(c=new RegExp(c.source,(c+\"g\").match(/\\\\w*$/)[0].replace(a?/g(.)/:/g()/g,\"$1\")));if(a){var g=[];b.replace(c,function(a){g.push(a)});var d=g.length;a=f?d+e:e;if(0<=a&&a<d)return g[a]}else{!f&&++e;var k=f?-1:1;d=b.length;for(a=f?d-1:0;f?0<=a:a<d;a+=k)if(has(b,a)&&(h?c.test(b[a]):c(b[a]))&&!(e-=k))return b[a]}};})'.replace(/=.+;/, 'findNthIndex$&findNth$&').replace('push(a)', 'push(arguments[arguments.length-2])').replace(/(return )b.a./, '$1a'))(typeOf, has);",
      "description": "Gets the nth value matching `target` in `subject`.",
      "params": [
        {
          "name": "subject",
          "description": "Array or string to search for `target` in.",
          "type": "Array|string"
        },
        {
          "name": "target",
          "description": "If `subject` is an array this must either be a function or a regular expression which will be tested against each element in `subject`.  If `subject` is a string this must be a regular expression which will be tested against it to find all of the matches.",
          "type": "Function|RegExp"
        },
        {
          "name": "n",
          "description": "The number of the occurrence that will be searched for and returned.  `0` represents the first occurrence whereas `-1` represents the last.",
          "type": "number"
        }
      ],
      "return": {
        "type": "*",
        "description": "The nth occurrence of `target` within `subject`.  If not found `undefined` will be returned."
      },
      "requires": [
        "has",
        "typeOf",
        "findNthIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "findNthIndex",
      "code": "",
      "description": "Get the nth index of the `target` in `subject`.",
      "params": [
        {
          "name": "subject",
          "description": "Array or string to search for `target` in.",
          "type": "Array|string"
        },
        {
          "name": "target",
          "description": "If `subject` is an array this must either be a function or a regular expression which will be tested against each element in `subject`. If `subject` is a string this must be a regular expression which will be tested against it to find all of the matches.",
          "type": "Function|RegExp"
        },
        {
          "name": "n",
          "description": "The number of the occurrence that will be searched for and returned.  `0` represents the first occurrence whereas `-1` represents the last.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number|undefined",
        "description": "If the nth occurrence of `target` can be found within `subject` the index will be returned otherwise `undefined` will be returned."
      },
      "requires": [
        "findNth"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "findPath",
      "code": "function findPath(base, callback, maxTimeMs=3000) {\n  let startTime = +new Date;\n  let toCheck = [{ value: base, path: [] }]\n  while (entry = toCheck.shift()) {\n    let value = entry.value;\n    let path = entry.path;\n    if (callback(value, path, base)) {\n      return path;\n    }\n    if (value && 'object' === typeof value) {\n      toCheck = toCheck.concat(Object.keys(value).map(key => ({ value: value[key], path: path.concat([key]) })));\n    }\n    if (new Date - startTime > maxTimeMs) {\n      return undefined;\n    }\n  }\n  return false;\n}",
      "description": "Find the path to a specific value based on a callback function.",
      "params": [
        {
          "name": "base",
          "description": "The object in which you want to start looking to see if it a match according to `callback`.",
          "type": "*"
        },
        {
          "name": "callback",
          "description": "The function that will be called for each value starting with `base` and traversing all of its descendants.  The arguments passed will be (1) the value be inspected, (2) the path as an array to that value and (3) a reference to `base`.  If this function returns a `true`-ish value then execution will stop and the path to this value will be returned.",
          "type": "Function"
        },
        {
          "name": "opt_maxTimeMs",
          "description": "The maximum amount of time to check before simply returning `undefined`.",
          "type": "number",
          "optional": true,
          "default": "3000"
        }
      ],
      "return": {
        "type": "Array<string>|boolean|undefined",
        "description": "If the desired value is found an array with the path to said `base`.  If the desired value is not found in the allotted time `undefined` is returned. In all other cases `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var path = YourJS.findPath(\n  [{ first: 'Chris' }, { name: { first: 'Stacey' } }],\n  function(value, path) { return path.slice(-1)[0] === 'first' && value === 'Stacey'; }\n);\ntest(JSON.stringify([\"1\", \"name\", \"first\"]), JSON.stringify(path));"
        }
      ]
    },
    {
      "name": "first",
      "code": "var first = nth(0);",
      "description": "Gets the last element in an array or an array-like object.",
      "params": [
        {
          "name": "array",
          "description": "The array or array-like object from which to pull the first element.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "*",
        "description": "The first value of `array`."
      },
      "requires": [
        "nth"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "flatMap",
      "code": "function flatMap(arrOrObj, callback, thisArg) {\n  if (Array.isArray(arrOrObj)) {\n    for (var returned, insertI = 0, i = 0, l = arrOrObj.length, result = new Array(l); i < l; i++ , insertI++) {\n      if (i in arrOrObj) {\n        if (!Array.isArray(returned = callback.call(thisArg, arrOrObj[i], i, arrOrObj))) {\n          returned = [returned];\n        }\n        result.splice.apply(result, [insertI, 1].concat(returned));\n        insertI = insertI + returned.length - 1;\n      }\n    }\n  }\n  else {\n    var result = {};\n    for (var i in arrOrObj) {\n      if (has(arrOrObj, i)) {\n        extend(result, callback.call(thisArg, arrOrObj[i], i, arrOrObj));\n      }\n    }\n  }\n  return result;\n}",
      "description": "Iterates through each item in an array or an object, passing the item to a mapping function, and flattens the result into the array or object.",
      "params": [
        {
          "name": "arrOrObj",
          "description": "Array or object whose items should be iterated through and passed to the mapping function.",
          "type": "Array|Object"
        },
        {
          "name": "mapper",
          "description": "Mapping function which will be passed (1) the item be analyzed, (2) the corresponding index or key for said item, and (3) a reference to `arrOrObj`.  The return value will be flattened into the array or object returned from `flatMap()`.",
          "type": "Function"
        },
        {
          "name": "opt_thisArg",
          "description": "The value that will be referenced when using the `this` keyword within `mapper`.  If not given this will refer to the global object.",
          "type": "*",
          "optional": true,
          "default": ""
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "If `arrOrObj` was an array then an array will be returned, otherwise an object will be returned.  If an array, the values returned from `mapper` for each item will occupy the position of the original item in this new array.  If an object, the values returned from `mapper` will be used instead of the items that were passed in and the new object will use the key(s) from the objects returned for this new object."
      },
      "requires": [
        "extend",
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Array",
          "code": "test(\n  JSON.stringify(YourJS.flatMap(['This', 'is a wonderful', 'day!'], function(x) { return x.split(' ') })),\n  '[\"This\",\"is\",\"a\",\"wonderful\",\"day!\"]'\n);"
        },
        {
          "name": "Simple Object",
          "code": "var obj = YourJS.flatMap({ name: 'Chris West' }, function(x) { return { first: x.split(' ')[0], last: x.split(' ')[1] }; });\nvar keys = Object.keys(obj).sort();\nvar values = keys.map(function(x) { return obj[x]; });\ntest(JSON.stringify(keys.concat(values)), '[\"first\",\"last\",\"Chris\",\"West\"]');"
        }
      ]
    },
    {
      "name": "flatten",
      "code": "function flatten(array, opt_depth) {\n  opt_depth = opt_depth == undefined ? 1 : opt_depth;\n  var result = [];\n  for (var nextDepth = opt_depth === true || (opt_depth - 1), i = 0, l = array.length; i < l; i++) {\n    if (opt_depth > 0 && typeOf(array[i]) == 'Array') {\n      result = result.concat(flatten(array[i], nextDepth));\n    }\n    else {\n      result.push(array[i]);\n    }\n  }\n  return result;\n}",
      "description": "Create a flattened copy of an array.",
      "params": [
        {
          "name": "array",
          "description": "Array to flatten.",
          "type": "Array"
        },
        {
          "name": "opt_depth",
          "description": "If `true` or `Infinity` there will be no limit to the recursiveness of the flattening.  Otherwise, if given, this should be a number indicated how many levels down this array should be flattened.",
          "type": "boolean|number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array",
        "description": "Flattened version of `array` up to the given `opt_depth`."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.flatten([1,[2,[3],4],5])), '[1,2,[3],4,5]')"
        }
      ]
    },
    {
      "name": "flattenKeys",
      "code": "function flattenKeys(obj, opt_keyedObjects) {\n  function recurse(base, path, keys, keysCount, ancestors) {\n    for (var innerKeys, innerKeysCount, v, k, i = 0; i < keysCount; i++) {\n      v = base[k = keys[i]];\n      innerKeys = (v && 'object' === typeof v) ? getKeys(v) : [];\n      if (ancestors.indexOf(v) < 0) {\n        k = k.replace(/\\\\|\\./g, '\\\\$&');\n        if (innerKeysCount = innerKeys.length) {\n          recurse(v, path + k + '.', innerKeys, innerKeysCount, ancestors.concat([v]));\n        }\n        if (opt_keyedObjects || !innerKeysCount) {\n          result[path + k] = v;\n        }\n      }\n    }\n  }\n\n  var getKeys = Object.keys,\n      result = {},\n      keys = (obj && 'object' === typeof obj) ? getKeys(obj) : [],\n      keysCount = keys.length;\n  if (keysCount) {\n    recurse(obj, '', keys, keysCount, [obj]);\n  }\n  return result;\n}",
      "description": "Creates a new object with keys to all of the values regardless of the level(excluding recursive objects). Keys for values on deeper levels will be joined by a \".\" while any dots or backslashes in the original keys will be escaped with a leading blackslash.",
      "params": [
        {
          "name": "obj",
          "description": "The object whose keys should be flattened.",
          "type": "Object"
        },
        {
          "name": "opt_keyedObjects",
          "description": "Determines whether or not to keep the objects as well as adding flattened keys.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Object",
        "description": "Returns a new object representing `obj` but having all nested keys represented by flat keys within the returned object."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var o = YourJS.flattenKeys([{ name: { first: 'Chris' }}]);\ntest(JSON.stringify(o), '{\"0.name.first\":\"Chris\"}');"
        }
      ]
    },
    {
      "name": "floor",
      "code": "",
      "description": "Rounds towards `-Infinity` with the specified precision.",
      "params": [
        {
          "name": "num",
          "description": "The number to be rounded towards `Infinity`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number towards `-Infinity`. Using the precision is similar to doing `Math.floor(num * Math.pow(10, precision)) / Math.pow(10, precision)`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` rounded towards `-Infinity` with the specified precision."
      },
      "requires": [
        "round"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "forEach",
      "code": "function forEach(a, fn, opt_traverseAll) {\n  function end(opt_getIfEnded) {\n    if(opt_getIfEnded) {\n      return !!endCalled;\n    }\n    throw endCalled = 1;\n  }\n  for (var endCalled, count = 0, i = 0, l = a.length, arr = nativeType(a) === 'String' ? a.split('') : a; i < l; i++) {\n    if (opt_traverseAll || has(arr, i)) {\n      try {\n        fn.call(++count, arr[i], i, a, end);\n      }\n      catch (e) {\n        if (endCalled) {\n          break;\n        }\n        throw e;\n      }\n    }\n  }\n  return count;\n}",
      "description": "Traverses all the characters in a string or all of the elements in an array or an array-like object, executing a function on each one.",
      "params": [
        {
          "name": "a",
          "description": "Array or array-like object or string to traverse.",
          "type": "Array|Arguments|string|Object",
          "optional": false
        },
        {
          "name": "fn",
          "description": "Function called on each item in `a`.  The parameters passed are as follows:  (1) value, (2) key, (3) `a` and (4) ender function.  The `this` keyword will contain the number of times the function has been called.  The ender function may be used to immediately stop traversing `a`.  Calling the ender function with a `true`-ish value will instead make the ender function return a boolean value indicating if the ender function has already been called (useful only in a `catch` or `finally` clause).",
          "type": "Function"
        },
        {
          "name": "opt_traverseAll",
          "description": "Boolean indicating if all items in `a`, including those not owned by `a`, should be traversed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The number of times `fn` was called."
      },
      "requires": [
        "has",
        "nativeType"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "forIn",
      "code": "function forIn(obj, fn, opt_traverseAll) {\n  var endCalled, count = 0;\n  function end(opt_getIfEnded) {\n    if(opt_getIfEnded) {\n      return !!endCalled;\n    }\n    throw endCalled=1;\n  }\n  for (var k in obj) {\n    if (opt_traverseAll || has(obj, k)) {\n      try {\n        fn.call(++count, obj[k], k, obj, end);\n      }\n      catch (e) {\n        if (endCalled) {\n          break;\n        }\n        throw e;\n      }\n    }\n  }\n  return count;\n}",
      "description": "Runs through all of the properties of an object, executing a function for each property found.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose properties will be traversed.",
          "type": "Object"
        },
        {
          "name": "fn",
          "description": "Function to call for each property in `obj`.  The parameters passed are as follows:  (1) value, (2) key, (3) `obj` and (4) ender function.  The `this` keyword will contain the number of times the function has been called.  The ender function may be used to immediately stop traversing `obj`.  Calling the ender function with a `true`-ish value will instead make the ender function return a boolean value indicating if the ender function has already been called (useful only in a `catch` or `finally` clause).",
          "type": "Function"
        },
        {
          "name": "opt_traverseAll",
          "description": "Boolean indicating whether or not even the properties that are not owned by `obj` should be traversed.  If `true` all properties will be traversed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "Number of times `fn` was called."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "formatDate",
      "code": "var formatDate = (function(arrMonths, arrDays) {\n  function prefixZeroes(num, end) {\n    return ((new Array(end)).join(0) + Math.abs(num)).slice(-end);\n  }\n  return function(date, strFormat, opt_options) {\n    opt_options = opt_options || {};\n    var arrCustomMonths = opt_options.months || arrMonths,\n        arrCustomDays = opt_options.days || arrDays,\n        YYYY = date.getFullYear(),\n        M = date.getMonth(),\n        MMMM = arrCustomMonths[M++],\n        DDDD = arrCustomDays[date.getDay()],\n        D = date.getDate(),\n        H = date.getHours(),\n        h = (H % 12) || 12,\n        m = date.getMinutes(),\n        s = date.getSeconds(),\n        S = date.getMilliseconds(),\n        tzOffset = date.getTimezoneOffset(),\n        subs = {\n          YYYY: YYYY,\n          YY: YYYY % 100,\n          MMMM: MMMM,\n          MMM: MMMM.slice(0, 3),\n          MM : prefixZeroes(M, 2),\n          M: M,\n          DDDD: DDDD,\n          DDD: DDDD.slice(0, 3),\n          DD: prefixZeroes(D, 2),\n          D: D,\n          HH: prefixZeroes(H, 2),\n          hh: prefixZeroes(h, 2),\n          H: H,\n          h: h,\n          mm: prefixZeroes(m, 2),\n          m: m,\n          ss: prefixZeroes(s, 2),\n          s: s,\n          a: H < 12 ? 'am' : 'pm',\n          A: H < 12 ? 'AM' : 'PM',\n          SSS: prefixZeroes(S, 3),\n          S: S,\n          Z: (tzOffset < 0 ? '+' : '-') + prefixZeroes(tzOffset / 60, 2) + prefixZeroes(tzOffset % 60, 2)\n        };\n    return strFormat.replace(\n      /YY(?:YY)?|M{1,4}|D{1,4}|HH?|hh?|mm?|ss?|a|A|S(?:SS)?|Z|'((?:[^']+|'')+)'/g,\n      function(m, quoted) {\n        return quoted ? quoted.replace(/''/g, \"'\") : subs[m]\n      }\n    );\n  };\n})(\n  'January February March April May June July August September October November December'.split(' '),\n  'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' ')\n);",
      "description": "Creates a string representation of the date using the specified format string.",
      "params": [
        {
          "name": "date",
          "description": "Date object to be formatted as a string.",
          "type": "Date"
        },
        {
          "name": "strFormat",
          "description": "If part of the string is wrapped in single quotes, those single quotes will be removed, any groupings of 2 consecutive single quotes will be replaced with just one and the other characters will appear in the returned string as is.  `YYYY` will be replaced by the full year (eg. 2018).  `YY` will be replaced by a 2-digit representation of the year (eg. 18).  `MMMM` will be replaced by the name of the month (eg. September).  `MMM` will be replaced by the 1st 3 characters of the name of the month (eg. Sep).  `MM` will be replaced by a 2-digit representation of the month (eg. 09).  `M` will be replaced by a numeric representation of the month (eg. 9).  `DDDD` will be replaced by the name of the day of the week (eg. Sunday).  `DDD` will be replaced by the 1st 3 characters of the name of the day of the week (eg. Sun).  `DD` will be replaced by a 2-digit representation of the day of the month (eg. 02).  `D` will be replaced by a numeric representation of the day of the month (eg. 2).  `HH` will be replaced with a 24-hour 2-digit representation of the hour (eg. 15).  `H` will be replaced with a 24-hour numeric representation of the hour (eg. 15).  `hh` will be replaced with a 12-hour 2-digit representation of the hour (eg. 03).  `h` will be replaced with a 12-hour numeric representation of the hour (eg. 3).  `mm` will be replaced with a 2-digit representation of the minutes (eg. 26).  `m` will be replaced with a numeric representation of the minutes (eg. 26).  `ss` will be replaced with a 2-digit representation of the seconds (eg. 01).  `s` will be replaced with a numeric representation of the seconds (eg. 1).  `A` will be replaced with \"AM\" or \"PM\".  `a` will be replaced with \"am\" or \"pm\".  `SSS` will be replaced with a 3-digit representation of the milliseconds (eg. 000).  `S` will be replaced with a numeric representation of the milliseconds (eg. 0).  `Z` will be replaced with a representation of the timezone offset that starts off with \"+\" or \"-\", followed by 2 digits that represent the hours offset, followed by 2 digits that represent the minutes offset.",
          "type": "string"
        },
        {
          "name": "opt_overrides",
          "description": "Object that can override the preset values.  If the `months` property is defined it should be an array of 12 month names starting with January.  If the `days` property is defined it should be an array of the 7 days of the week starting with Sunday.",
          "type": "Object",
          "optional": true
        }
      ],
      "return": {
        "type": "string",
        "description": "A string representation of `date` where all of the rules for `strFormat` are followed."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "formatTime",
      "code": "function formatTime(ms, format) {\n  var lastNum, floor = Math.floor, isNegative = ms < 0 || 1 / ms < 0;\n  ms = Math.abs(floor(ms));\n  return format.replace(\n    /(\\\\.)|'((?:[^']+|'')+)'|\"((?:[^\"]+|\"\")+)\"|#((?:[^#]+|##)+)#|(\\+)|(\\-)|(([Ww])|([Dd])|(HH?|hh?)|(mm?)|(ss?)|(S(?:SS)?))(\\!)?/g,\n    function (all, escaped, inner, inner2, inner3, plus, minus, num, w, d, h, m, s, S, full) {\n      if (escaped) {\n        return escaped;\n      }\n      if (num) {\n        lastNum = all = S\n          ? !full ? ms % 1e3 : ms\n          : s\n            ? (all = floor(ms / 1e3), !full ? all % 60 : all)\n            : m\n              ? (all = floor(ms / 6e4), !full ? all % 60 : all)\n              : h\n                ? (all = floor(ms / 36e5), !full ? all % 24 : all)\n                : d\n                  ? (all = floor(ms / 864e5), !full ? all % 7 : all)\n                  : floor(ms / 6048e5);\n        num = num.length;\n        return (full || num === 1) ? all : ('00' + all).slice(-num);\n      }\n\n      inner = inner || inner2 || inner3;\n\n      var quote = inner3 ? '#' : inner2 ? '\"' : \"'\";\n\n      return quote\n        ? (\n            (quote === '#' && lastNum != undefined)\n            ? inner.replace(/\\(((?:[^\\\\\\|\\(\\)]|\\\\.)*)(?:\\|((?:[^\\\\\\|\\(\\)]|\\\\.)*))?\\)/g, lastNum === 1 ? '$2' : '$1')\n            : inner\n          ).split(quote + quote).join(quote)\n        : isNegative ? '-' : plus ? '+' : '';\n    }\n  ).replace(/\\\\(.)/g, '$1');\n}",
      "description": "Formats the time (number of milliseconds) given based on a format string.  If you want to format time using a `Date` object with a timezone different from UTC (GMT) you should use `formatDate()`.",
      "params": [
        {
          "name": "ms",
          "description": "Number of milliseconds that will be represented in the returned string.",
          "type": "number"
        },
        {
          "name": "format",
          "description": "Format string where `W` (or `w`) will be replaced by the number of weeks, `D` (or `d`) by the number of days (maximum being 6), `H` (or `h`) by the number of hours (maximum being 23), `m` by the number of minutes (maximum being 59), `s` by the number of seconds (maximum being 59), and `S` by the number of milliseconds (maximum being 999).  Adding an exclamation point to the end of any of those characters (eg. `S!`) will result in the corresponding value not being truncated based on the next highest time increment.  Using `HH`, `hh`, `mm`, `ss` or `SSS` will result in leading zeroes for those corresponding values.  Instances of `-` will be removed only if `ms` is positive.  Instances of `+` will be replaced with `-` only if `ms` is negative, otherwise `+` will remain.  Wrapping a substring in single quotes or double quotes will cause that substring to be escaped and any instances of that same quote character being repeated once will be replaced with just one.  Wrapping a substring with the hash character (#) will result in a conditional string where any underlying substring wrapped in parentheses will only be returned if the preceding meta-group is not `1`.  If the the conditional substring is specified and the preceding meta-group is `1` then either nothing will be printed  or if the parenthesized group contains an unescaped vertical bar anything found thereafter will be printed.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "The value of `ms` formatted based on `format`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.formatTime(60000 + 1000 + 202, 'm:ss.SSS'), '1:01.202')"
        },
        {
          "name": "Hash Quotes",
          "code": "test(\n  YourJS.formatTime(60000 + 1000 + 202, '#sdf(s):# m #minute(s|\\\\(s\\\\))#, s #second(s)# \"and\" S #millisecond(s)#'),\n  'sdf(s): 1 minute(s), 1 second and 202 milliseconds'\n)"
        },
        {
          "name": "Slow Test",
          "code": "test(\n  YourJS.formatTime(60000 + 1000 + 202, 'm #minute(s)# s \"second(s)#'),\n  '1 minute 1 \"1econ0(1)#'\n)"
        }
      ]
    },
    {
      "name": "forOf",
      "code": "function forOf(obj, fn, opt_traverseAll) {\n  return (\n    (isArrayLike(obj) || nativeType(obj) === 'String') ? forEach : forIn\n  )(Object(obj), fn, opt_traverseAll);\n}",
      "description": "Traverses all the characters in a string or all of the items in an array or an object, executing a function on each one.",
      "params": [
        {
          "name": "obj",
          "description": "If is an array, an array-like object, or an object, its items will be traversed.  If it is a string its characters will be individual traversed.",
          "type": "Array|Object|string"
        },
        {
          "name": "fn",
          "description": "Function to call for each item traversed within `obj`.  The parameters passed are as follows:  (1) value, (2) key, (3) `obj` and (4) ender function.  The `this` keyword will contain the number of times this `fn` function has been called.  The ender function may be used to immediately stop traversing `obj`.  Calling the ender function with a `true`-ish value will instead make the ender function return a boolean value indicating if the ender function has already been called (useful only in a `catch` or `finally` clause).",
          "type": "Function"
        },
        {
          "name": "opt_traverseAll",
          "description": "Boolean indicating whether or not even the properties that are not owned by `obj` should be traversed.  If `true` all properties will be traversed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "Number of times `fn` was called."
      },
      "requires": [
        "isArrayLike",
        "forEach",
        "forIn",
        "nativeType"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "frac",
      "code": "function frac(num) {\n  return +(+num).toExponential().replace(\n    /(-?)(\\d+(\\.?)\\d*)e(.+)/,\n    function(m, neg, num, dot, offset) {\n      var zeroes = Array(Math.abs(offset) + 2).join('0');\n      num = (zeroes + num + (dot ? '' : '.') + zeroes).split('.');\n      return +(neg + '.' + num.join('').slice(+offset + num[0].length));\n    }\n  );\n}",
      "description": "Gets the fractional part of a number, removing the integral part.",
      "params": [
        {
          "name": "num",
          "description": "The number from which the fractional part will be pulled.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` without the integral part while keeping the sign."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "fround",
      "code": "var fround;\n(function (array) {\n  fround = function(x) {\n    return array[0] = x, array[0];\n  };\n})(new Float32Array(1));",
      "description": "Gets the nearest 32-bit single precision float representation of a number.",
      "params": [
        {
          "name": "doubleFloat",
          "description": "A Number. If the parameter is of a different type, it will get converted to a number or to `NaN` if it cannot be converted.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The nearest 32-bit single precision float representation of the given number."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple MDN Example",
          "code": "test(YourJS.fround(1.337), 1.3370000123977661);"
        }
      ]
    },
    {
      "name": "fullNumber",
      "code": "function fullNumber(num) {\n  var realNum = +num;\n  if (isFinite(realNum)) {\n    var match = /(\\d)(?:\\.(\\d+))?e(\\+|\\-)(\\d+)/.exec(realNum + '');\n    if (match) {\n      var end = match[2] || '';\n      var startAndEnd = match[1] + end;\n      var digits = +match[4];\n      num = match[3] === '+'\n        ? startAndEnd + Array(digits + 1 - end.length).join('0')\n        : ('0.' + Array(digits).join('0') + startAndEnd);\n    }\n    return num + '';\n  }\n}",
      "description": "Takes a number in any form and returns it as a string in its fullest form (removing exponents).",
      "params": [
        {
          "name": "num",
          "description": "Number to return in its fullest form.",
          "type": "number"
        }
      ],
      "return": {
        "type": "string|undefined",
        "description": "If `num` is a finite number it will be returned as a number in its fullest form without exponents of any kind.  If `num` is not a finite number `undefined` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.fullNumber(12345.67), '12345.67');"
        },
        {
          "name": "With extra zeros",
          "code": "test(YourJS.fullNumber('12345.000'), '12345.000');"
        },
        {
          "name": "Big",
          "code": "test(YourJS.fullNumber(4e21), '4000000000000000000000')"
        },
        {
          "name": "Small",
          "code": "test(YourJS.fullNumber(4e-21), '0.000000000000000000004')"
        }
      ]
    },
    {
      "name": "gcd",
      "code": "function gcd(int1, int2) {\n  return int2 ? gcd(int2, int1 % int2) : int1;\n}",
      "description": "Finds the largest integer which evenly divides the two specified integers.",
      "params": [
        {
          "name": "int1",
          "description": "The first of two integers for which the greatest common denominator should be found.",
          "type": "number"
        },
        {
          "name": "int2",
          "description": "The second of two integers for which the greatest common denominator should be found.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the largest integer which evenly divides `int1` and `int2`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.gcd(2*3*5*7*11, 2*5*7*13*19), 2*5*7);"
        }
      ]
    },
    {
      "name": "get",
      "code": "function get(obj, opt_name, opt_default) {\n  var emptyIndex = obj != undefined ? opt_name == undefined ? 1 : -1 : 0;\n  return (emptyIndex + 1)\n    ? Function('g,a,b,c', 'return function(x,y){return g(a,x,b,arguments.length>1?y:c)}'.replace(emptyIndex ? 'b,' : 'a,', ''))(get, obj, opt_name, opt_default)\n    : has(obj, opt_name)\n      ? obj[opt_name]\n      : opt_default;\n}",
      "description": "Get the value of the specified property name.",
      "params": [
        {
          "name": "obj",
          "description": "Object to get the property from.",
          "type": "Object|undefined"
        },
        {
          "name": "opt_name",
          "description": "Name of the property.",
          "type": "string|undefined",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_default",
          "description": "The default value to return if the specified property (`opt_name`) is not owned by `obj`.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "*",
        "description": "If both `obj` and `opt_name` are specified then either the owned property will be returned or `opt_default` will be returned.  If `obj` is `undefined` a partial function will be returned that will accept an object to always pull the same property name (`opt_name`) from and an optional different default value.  If `opt_name` was not specified or is `undefined` a partial function will be returned that will accept a name for a property to always pull from the same object (`obj`) and a different default value."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "getAt",
      "code": "function getAt(root, path, opt_defaultValue) {\n  var test = testAt(root, path),\n      l = path.length;\n  return l ? test.length == l ? test.slice(-1)[0] : opt_defaultValue : root;\n}",
      "description": "Gets the value under the given `root` object and `path`.",
      "params": [
        {
          "name": "root",
          "description": "Object to start at as the root of the proposed `path`.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "An array of strings and/or numbers that represent the path to be traversed under `root`.",
          "type": "Array"
        },
        {
          "name": "opt_defaultValue",
          "description": "The value to be returned if the given `path` doesn't fully exists under `root`.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `path` is an empty array `root` will be returned.  Otherwise either the value found under the given `path` starting at `root` or `opt_defaultValue` if the `path` doesn't fully exist under `root`."
      },
      "requires": [
        "testAt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "getCookie",
      "code": "function getCookie(name, opt_defaultValue) {\n  if(typeOf(name) === 'RegExp') {\n    var ret = getCookie();\n    for(var key in ret) {\n      if(!name.test(key)) {\n        delete ret[key];\n      }\n    }\n  }\n  else if(name == undefined) {\n    var ret = {};\n    __DOCUMENT.cookie.replace(/(?:^|;\\s*)(.+?)(?=;\\s*|$)/g, function($0, $1) {\n      $1 = $1.match(/(.*?)=(.*)/);\n      ret[decodeURIComponent($1[1])] = decodeURIComponent($1[2]);\n    });\n  }\n  else {\n    name = __DOCUMENT.cookie.match(new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(name) + \"=(.*?)(?:;\\\\s*|$)\"));\n    if(name) {\n      var ret = decodeURIComponent(name[1]);\n    }\n  }\n  return ret == undefined ? opt_defaultValue : ret;\n}",
      "description": "Retrieves one or more cookies.",
      "params": [
        {
          "name": "name",
          "description": "Either the name of the cookie to get or a regular expression matching the names of all of the cookies to get.  If `undefined` or `null` is supplied that means all cookies should be retrieved.",
          "type": "string|RegExp|undefined|null",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_defaultValue",
          "description": "The default value to return in the case that `name` was a string but the corresponding cookie doesn't exist.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `name` is a string and matches the name of a cookie, that cookie's value will be returned as a string.  If `name` is a string but doesn't match the name of a cookie `opt_defaultValue` will be returned.  If `name` is of type `RegExp` an object containing all of the cookies with names that match the specified regular expression will be returned.  If `name` is `undefined` or `null` an object containing all of the cookies will be returned.  If an object is returned each key will represent the name of each cookie and each value will be the value of that cookie."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "groupBy",
      "code": "",
      "description": "Takes an array and groups the items together based on a given hasher function.",
      "params": [
        {
          "name": "arr",
          "description": "Array containing the items to be grouped by the `hasher` function.",
          "type": "Array"
        },
        {
          "name": "hasher",
          "description": "If a function, it will be passed a value which will be used to group the items in `arr`.  If an array or a string it will be seen as the path within each item in `arr` to the property by which to group each item.",
          "type": "Function|Array|string"
        },
        {
          "name": "opt_initial",
          "description": "Object that will be augmented and returned.  The values at the keys produced by `hasher` will be arrays containing all of the corresponding items from `arr`.  If not specified the default is a new empty object.",
          "type": "*",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "*",
        "description": "`opt_initial` with all of the keys specified by `hasher` corresponding to arrays containing those values that come from `arr`."
      },
      "requires": [
        "countBy"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var names = ['Andrew','Chris','Stacey','Whitney'];\nvar obj = YourJS.groupBy(names, function(name) { return name.length; });\ntest(obj[5].concat(obj[6],obj[7]).join(','), 'Chris,Andrew,Stacey,Whitney');"
        }
      ]
    },
    {
      "name": "gt",
      "code": "",
      "description": "Determines if one value is greater than another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is less than `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is greater than `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is greater than `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is greater than `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "gte",
      "code": "",
      "description": "Determines if one value is greater than or equal to another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is less than or equal to `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is greater than or equal to `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is greater than or equal to `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is greater than or equal to `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "has",
      "code": "var has = alias(__EMPTY_OBJECT.hasOwnProperty, 'call');",
      "description": "Every object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose property will be tested.",
          "type": "Object"
        },
        {
          "name": "name",
          "description": "Name of the property to test.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating whether the object has the specified property as own (not inherited) property."
      },
      "requires": [
        "alias"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "hasAt",
      "code": "function hasAt(root, path) {\n  return path.length > 0 && testAt(root, path).length === path.length;\n}",
      "description": "Tests to see if the given `path` exists under a specific `root` object.",
      "params": [
        {
          "name": "root",
          "description": "Object to start at as the root of the proposed `path`.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "An array of strings and/or numbers that represent the path to be tested under `root`.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if the specified `path` is found under `root`, otherwise `false`."
      },
      "requires": [
        "testAt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "hasCookie",
      "code": "function hasCookie(name) {\n  return (';' + __DOCUMENT.cookie).replace(/;\\s+/g, ';').indexOf(';' + encodeURIComponent(name) + '=') >= 0;\n}",
      "description": "Determines if there is a cookie with the specified name.",
      "params": [
        {
          "name": "name",
          "description": "The name of the proposed cookie.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if a cookie with the specified `name` is found."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "hashID",
      "code": "function hashID(intID, opt_intHash, opt_strAlpha) {\n  intID = !(intID >= 0) ? 0 : Math.round(intID);\n  opt_intHash = Math.max(0, Math.min(Math.round(opt_intHash || 0), 9007199254740991));\n  opt_strAlpha = opt_strAlpha || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\n  var encodedID = '';\n  var FULL_ALPHA_LENGTH = opt_strAlpha.length;\n\n  do {\n    var newAlpha = '';\n    for (var x, i = opt_intHash; opt_strAlpha; i += opt_intHash) {\n      newAlpha += opt_strAlpha.charAt(x = i % opt_strAlpha.length);\n      opt_strAlpha = opt_strAlpha.slice(0, x) + opt_strAlpha.slice(x + 1);\n    }\n    opt_strAlpha = newAlpha;\n\n    encodedID = opt_strAlpha.charAt(intID % FULL_ALPHA_LENGTH) + encodedID;\n  } while(intID = ~~(intID / FULL_ALPHA_LENGTH));\n  return encodedID;\n}",
      "description": "Creates a string representation of an ID (non-negative integer) based on the given hash value and alphabet.",
      "params": [
        {
          "name": "intID",
          "description": "Non-negative integer that will be turned into a string.",
          "type": "number"
        },
        {
          "name": "opt_intHash",
          "description": "Non-negative integer that will be used to offset the characters used to represent `intID`.",
          "type": "number",
          "optional": true,
          "default": "0"
        },
        {
          "name": "opt_strAlpha",
          "description": "All of the characters that can be used to represent `intID`.  Defaults to the digits 0 to 9 followed by A to Z followed by a to z.",
          "type": "string",
          "optional": true,
          "default": "\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\""
        }
      ],
      "return": {
        "type": "string",
        "description": "The string representation of `intID` based on the hash and the alphabet."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "hasKeys",
      "code": "function hasKeys(obj, keys) {\n  function hasKeys(obj) {\n    obj = Object(obj);\n    for (var i = keys.length; i--; ) {\n      if (!has(obj, keys[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return obj == undefined ? hasKeys : hasKeys(obj);\n}",
      "description": "Tests to see if all of the given property names are owned by the specified object.",
      "params": [
        {
          "name": "obj",
          "description": "If `undefined` or `null`, a partial function waiting for this value will be returned.  Otherwise this will be the object from which the specified keys will be deleted.",
          "type": "Object|null|undefined"
        },
        {
          "name": "keys",
          "description": "Array of keys to see if they are owned by `obj`.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `obj` is `undefined` or `null` this will be a partial function which will simply accept the given `obj`.  The return value of the partial function is the same as the return value of this function in the case that `obj` is not `undefined` or `null`.  If all of the keys are owned by `obj`, `true` will be returned, otherwise `false`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "htmlify",
      "code": "function htmlify(str, opt_keepWhitespace) {\n  str = str.replace(/&/g, '&amp;')\n           .replace(/</g, '&lt;')\n           .replace(/>/g, '&gt;')\n           .replace(/\"/g, '&quot;')\n           .replace(/'/g, '&#x27;')\n           .replace(/`/g, '&#x60;');\n  return opt_keepWhitespace\n    ? str.replace(/\\r?\\n|\\r/g, '<br />')\n         .replace(/\\t/g, '    ')\n         .replace(/^ | (?= )| $/g, '&nbsp;')\n    : str;\n}",
      "description": "Converts a normal string into a string that can be treated as raw HTML.",
      "params": [
        {
          "name": "str",
          "description": "The string to be converted to raw HTML.",
          "type": "string"
        },
        {
          "name": "optKeepWhitespace",
          "description": "If set to `true` the returned string will convert multiple, consecutive spaces to non-breaking spaces followed by one normal space. If set to `true`, line breaks will be converted to `<br />`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "string",
        "description": "HTMLified version of `str`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "hypot",
      "code": "function hypot() {\n  var val, ret = 0, args = arguments, i = args.length;\n  while (i--) {\n    ret += (val = +args[i]) * val;\n  }\n  return Math.sqrt(ret);\n}",
      "description": "Determines the square root of the sum of the squares of the arguments passed.",
      "params": [
        {
          "name": "numX",
          "description": "Each of the numbers that will be squared and summed together.",
          "type": "number",
          "rest": true
        }
      ],
      "return": {
        "type": "number",
        "description": "The square root of the sum of the squares of the arguments passed."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.hypot(3,4), 5);"
        }
      ]
    },
    {
      "name": "ifExcludes",
      "code": "",
      "description": "If the second argument is not in the first argument (array) the third argument is passed back, otherwise the fourth argument (or if not given the first argument) is passed back.",
      "params": [
        {
          "name": "arrControls",
          "description": "Array of values to test `subject` against.",
          "type": "Array"
        },
        {
          "name": "subject",
          "description": "Value to see if it is in `arrControls`.",
          "type": "*"
        },
        {
          "name": "falseValue",
          "description": "Value to be returned if `subject` is not found within `arrControls`.",
          "type": "*"
        },
        {
          "name": "opt_trueValue",
          "description": "Value to be returned if `subject` is found within `arrControls`.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`falseValue` will be returned if `subject` is not found within `arrControls`.  Otherwise, if `opt_trueValue` is given it will be returned, but if not given `arrControls` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifFail",
      "code": "",
      "description": "Tests `subject` against `control` and if it results in a `false`-ish value `falsyValue` will be passed back.  Otherwise, if `opt_truthyValue` is given it will be passed back, but if not `subject` will be passed back.",
      "params": [
        {
          "name": "subject",
          "description": "Value to test.",
          "type": "*"
        },
        {
          "name": "control",
          "description": "If this is a function it will be called with `subject` being the only argument.  Otherwise, this regular expression will be tested against `subject`.",
          "type": "Function|RegExp"
        },
        {
          "name": "falsyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `false`-ish value.",
          "type": "*"
        },
        {
          "name": "opt_truthyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `true`-ish value.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`falsyValue` will be returned if testing `subject` against `control` results in a `false`-ish value.  Otherwise, if `opt_truthyValue` is given it will be returned, but if not given `subject` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifFails",
      "code": "",
      "description": "Tests `subject` against `control` and if it results in a `false`-ish value `falsyValue` will be passed back.  Otherwise, if `opt_truthyValue` is given it will be passed back, but if not `control` will be passed back.",
      "params": [
        {
          "name": "control",
          "description": "If this is a function it will be called with `subject` being the only argument.  Otherwise, this regular expression will be tested against `subject`.",
          "type": "Function|RegExp"
        },
        {
          "name": "subject",
          "description": "Value to test.",
          "type": "*"
        },
        {
          "name": "falsyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `false`-ish value.",
          "type": "*"
        },
        {
          "name": "opt_truthyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `true`-ish value.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`falsyValue` will be returned if testing `subject` against `control` results in a `false`-ish value.  Otherwise, if `opt_truthyValue` is given it will be returned, but if not given `control` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifIn",
      "code": "",
      "description": "If the first argument is in the second argument (array) the third argument is passed back, otherwise the fourth argument (or if not given the first argument) is passed back.",
      "params": [
        {
          "name": "subject",
          "description": "Value to see if it is in `arrControls`.",
          "type": "*"
        },
        {
          "name": "arrControls",
          "description": "Array of values to test `subject` against.",
          "type": "Array"
        },
        {
          "name": "trueValue",
          "description": "Value to be returned if `subject` is found within `arrControls`.",
          "type": "*"
        },
        {
          "name": "opt_falseValue",
          "description": "Value to be returned if `subject` is not found within `arrControls`.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`trueValue` will be returned if `subject` is found within `arrControls`.  Otherwise, if `opt_falseValue` is given it will be returned, but if not given `subject` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifIncludes",
      "code": "",
      "description": "If the second argument is in the first argument (array) the third argument is passed back, otherwise the fourth argument (or if not given the first argument) is passed back.",
      "params": [
        {
          "name": "arrControls",
          "description": "Array of values to test `subject` against.",
          "type": "Array"
        },
        {
          "name": "subject",
          "description": "Value to see if it is in `arrControls`.",
          "type": "*"
        },
        {
          "name": "trueValue",
          "description": "Value to be returned if `subject` is found within `arrControls`.",
          "type": "*"
        },
        {
          "name": "opt_falseValue",
          "description": "Value to be returned if `subject` is not found within `arrControls`.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`trueValue` will be returned if `subject` is found within `arrControls`.  Otherwise, if `opt_falseValue` is given it will be returned, but if not given `arrControls` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifIs",
      "code": "var ifIs = Function(\n      'I,O',\n      ',function(a,b,c,d){return?c:(arguments.length>3?d:a)}'\n        .replace(/(.+return)(.+)/, '~`_#%'.replace(/./g, '$$1$&$$2$$1$&$$2'))\n        .replace(/~/g, '!(@)') // ifIs() & ifNot()\n        .replace(/`/g, '!(I(b,a)>=0)') // ifIn() && ifOut\n        .replace(/_/g, '!(I(a,b)>=0)') // ifIncludes() && ifExcludes()\n        .replace(/#/g, '~b`b.test(a):b(a))') // ifPass() && ifFail()\n        .replace(/%/g, '~a`a.test(b):a(b))') // ifPasses() && ifFails()\n        .replace(/~(.)`/g, '!(O.toString.call($1)===\"[object RegExp]\"?') // Fix ifPass(), ifPasses(), ifFail() & ifFails()\n        .replace(/!([^!]+(!|$))/g, ' $1')\n        .replace(/@/g, 'a!==a?b!==b:a===0?1/a===1/b:a===b') // Fix ifIs() & ifNot() (including NaNs and 0s)\n        .replace(/,(.+)/, 'return[$1]')\n    )(indexOf, __EMPTY_OBJECT),\n    ifNot = ifIs[1],\n    ifIn = ifIs[2],\n    ifOut = ifIs[3],\n    ifIncludes = ifIs[4],\n    ifExcludes = ifIs[5],\n    ifPass = ifIs[6],\n    ifFail = ifIs[7],\n    ifPasses = ifIs[8],\n    ifFails = ifIs[9];\nifIs = ifIs[0];",
      "description": "If the first and second arguments are the same the third argument is passed back, otherwise the fourth argument (or if not given the first argument) is passed back.",
      "params": [
        {
          "name": "subject",
          "description": "Value to test.",
          "type": "*"
        },
        {
          "name": "control",
          "description": "Value that is being tested against.",
          "type": "*"
        },
        {
          "name": "trueValue",
          "description": "Value to be returned if `control` and `subject` are the same.",
          "type": "*"
        },
        {
          "name": "opt_falseValue",
          "description": "Value to be returned if `control` and `subject` are different.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`trueValue` will be returned if `control` is `subject`.  Otherwise, if `opt_falseValue` is given it will be returned, but if not given `subject` will be returned."
      },
      "requires": [
        "ifFail",
        "ifFails",
        "ifIn",
        "ifNot",
        "ifOut",
        "ifPass",
        "ifPasses",
        "indexOf",
        "ifIncludes",
        "ifExcludes"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifNot",
      "code": "",
      "description": "If the first and second arguments are different the third argument is passed back, otherwise the fourth argument (or if not given the first argument) is passed back.",
      "params": [
        {
          "name": "subject",
          "description": "Value to test.",
          "type": "*"
        },
        {
          "name": "control",
          "description": "Value that is being tested against.",
          "type": "*"
        },
        {
          "name": "falseValue",
          "description": "Value to be returned if `control` and `subject` are different.",
          "type": "*"
        },
        {
          "name": "opt_trueValue",
          "description": "Value to be returned if `control` and `subject` are the same.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`opt_trueValue` will be returned if `control` is different from `subject`.  Otherwise, if `falseValue` is given it will be returned, but if not given `subject` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifOut",
      "code": "",
      "description": "If the first argument is not in the second argument (array) the third argument is passed back, otherwise the fourth argument (or if not given the first argument) is passed back.",
      "params": [
        {
          "name": "subject",
          "description": "Value to see if it is in `arrControls`.",
          "type": "*"
        },
        {
          "name": "arrControls",
          "description": "Array of values to test `subject` against.",
          "type": "Array"
        },
        {
          "name": "falseValue",
          "description": "Value to be returned if `subject` is not found within `arrControls`.",
          "type": "*"
        },
        {
          "name": "opt_trueValue",
          "description": "Value to be returned if `subject` is found within `arrControls`.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`falseValue` will be returned if `subject` is not found within `arrControls`.  Otherwise, if `opt_trueValue` is given it will be returned, but if not given `subject` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifPass",
      "code": "",
      "description": "Tests `subject` against `control` and if it results in a `true`-ish value `truthyValue` will be passed back.  Otherwise, if `opt_falsyValue` is given it will be passed back, but if not `subject` will be passed back.",
      "params": [
        {
          "name": "subject",
          "description": "Value to test",
          "type": "*"
        },
        {
          "name": "control",
          "description": "If this is a function it will be called with `subject` being the only argument.  Otherwise, this regular expression will be tested against `subject`.",
          "type": "Function|RegExp"
        },
        {
          "name": "truthyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `true`-ish value.",
          "type": "*"
        },
        {
          "name": "opt_falsyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `false`-ish value.",
          "type": "*",
          "optional": true,
          "default": "subject"
        }
      ],
      "return": {
        "type": "*",
        "description": "`truthyValue` will be returned if testing `subject` against `control` results in a `true`-ish value.  Otherwise, if `opt_falsyValue` is given it will be returned, but if not given `subject` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ifPasses",
      "code": "",
      "description": "Tests `subject` against `control` and if it results in a `true`-ish value `truthyValue` will be passed back.  Otherwise, if `opt_falsyValue` is given it will be passed back, but if not `control` will be passed back.",
      "params": [
        {
          "name": "control",
          "description": "If this is a function it will be called with `subject` being the only argument.  Otherwise, this regular expression will be tested against `subject`.",
          "type": "Function|RegExp"
        },
        {
          "name": "subject",
          "description": "Value to test",
          "type": "*"
        },
        {
          "name": "truthyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `true`-ish value.",
          "type": "*"
        },
        {
          "name": "opt_falsyValue",
          "description": "Value to be returned if testing `subject` against `control` results in a `false`-ish value.",
          "type": "*",
          "optional": true,
          "default": "control"
        }
      ],
      "return": {
        "type": "*",
        "description": "`truthyValue` will be returned if testing `subject` against `control` results in a `true`-ish value.  Otherwise, if `opt_falsyValue` is given it will be returned, but if not given `control` will be returned."
      },
      "requires": [
        "ifIs"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "imul",
      "code": "function imul() {\n  // Using the lo/hi version because the 0x001fffff/0xffc00000 version doesn't\n  // always give the correct answer if the operands are placed in reverse order.\n  for (var a, aLo, bLo, args = arguments, i = args.length, b = ~~args[--i]; i-- > 0; ) {\n    a = b;\n    b = args[i];\n    aLo = a & 0xffff;\n    bLo = b & 0xffff;\n    b = ((aLo * bLo) + (((((a >>> 16) & 0xffff) * bLo + aLo * ((b >>> 16) & 0xffff)) << 16) >>> 0) | 0);\n  }\n  return b;\n}",
      "description": "Determines the 32-bit product of the arguments passed similar to the way it would be calculated in C.",
      "params": [
        {
          "name": "numX",
          "description": "All of the numbers for which you would like to calculate the 32-bit product.",
          "type": "number",
          "rest": true
        }
      ],
      "return": {
        "type": "number",
        "description": "The C-like 32-bit product of all of the numbers passed in."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var a = -1102240083;\nvar b = ~~29839843293842639.463;\ntest(YourJS.imul(a,b,a,b,a)+','+YourJS.imul(a,a,a,b,b), '26852608,26852608');"
        }
      ]
    },
    {
      "name": "includes",
      "code": "function includes(subject, target, opt_start) {\n  subject = indexOf(subject, target, opt_start);\n  return 'number' === typeof subject ? subject >= 0 : (subject !== undefined);\n}",
      "description": "Determines whether or not a `target` is present within a given string, array or object.  Unlike `Array.prototype.includes()`, this function differentiates between `-0` and `0`.",
      "params": [
        {
          "name": "subject",
          "description": "The array, object or string in which `target` should be searched for.",
          "type": "Array|Object|string"
        },
        {
          "name": "target",
          "description": "The target value to search for within `subject`.",
          "type": "*"
        },
        {
          "name": "opt_start",
          "description": "The position at which to start the search for strings or arrays.  This will be ignored for objects.  Negative values will be calculated from the end.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean value indicating if `target` is present within `subject` at or after `opt_start`."
      },
      "requires": [
        "indexOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Array test",
          "code": "test(YourJS.includes([0,NaN,-0,undefined], -0), true);"
        }
      ]
    },
    {
      "name": "index",
      "code": "var index = (function(kNames, vNames) {\n  return function (subject, target, callback) {\n    forOf(subject, function (value, key) {\n      if (value = callback.call(target, value, key, subject)) {\n        for (var kName, vName, i = 0; kName = kNames[i], vName = vNames[i]; i++) {\n          if (has(value, kName) && has(value, vName)) {\n            target[value[kName]] = value[vName];\n            i = 2;\n          }\n        }\n      }\n    });\n    return target;\n  };\n})(\n  ['k', 0, 'key'],\n  ['v', 1, 'value', false]\n);",
      "description": "Indexes the `target` object based on the items found in `subject` and the `callback` function.",
      "params": [
        {
          "name": "subject",
          "description": "Array or object to traverse.",
          "type": "Array|Object"
        },
        {
          "name": "target",
          "description": "Object that will be augmented based on the items traversed in `subject`.",
          "type": "Object"
        },
        {
          "name": "callback",
          "description": "Function called for each item within `subject`.  In order to augment `target`, the return value must be an object (or array) that either has the `key` and `value` properties defined, `0` and `1` (for an array) values defined, or `k` and `v` properties defined.  All other types of values returned from this function will be ignored.",
          "type": "Function"
        }
      ],
      "return": {
        "type": "Object|Array",
        "description": "A reference to `target`."
      },
      "requires": [
        "forOf",
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "indexBy",
      "code": "",
      "description": "Traverses an array and returns an object with the values from the array placed in the specified indices.",
      "params": [
        {
          "name": "arr",
          "description": "Values to be placed in the returned object.",
          "type": "Array"
        },
        {
          "name": "indexer",
          "description": "If a function, it will be passed a value which will be used to index the items in `arr`.  If an array or a string it will be seen as the path within each item in `arr` to the property by which to index each item.",
          "type": "Function|Array|string"
        },
        {
          "name": "opt_initial",
          "description": "The object that will be augmented and returned.",
          "type": "Object",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "Array",
        "description": "`opt_initial` with additional properties names coming from the return values of `indexer` and the items found in `arr`."
      },
      "requires": [
        "countBy"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var a = ['a','b'], o = YourJS.indexBy(a, function(v){return v});\ntest(\n  [o.b,o.a].join(','),\n  'b,a'\n);"
        }
      ]
    },
    {
      "name": "indexOf",
      "code": "function indexOf(subject, target, opt_start) {\n  var k, i, item, t = typeOf(subject), isNaN = target !== target, isNegZero = target === 0 && 1 / target < 0;\n  if (t === 'String') {\n    return subject.indexOf(target, opt_start);\n  }\n  else if (t === 'Array') {\n    opt_start = ~~opt_start;\n    if (opt_start < 0) {\n      opt_start = Math.max(0, subject.length + opt_start);\n    }\n\n    for (i = subject.length; i-- > opt_start;) {\n      item = subject[i];\n      if (isNaN ? item !== item : (isNegZero ? item === 0 && 1 / item < 0 : (target === item))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  t = Object.keys(subject);\n  for (i = t.length; i--;) {\n    item = subject[k = t[i]];\n    if (isNaN ? item !== item : (isNegZero ? item === 0 && 1 / item < 0 : (target === item))) {\n      return k;\n    }\n  }\n}",
      "description": "Gets the index of a specified target value in a string, array or an object.  Unlike `Array.prototype.indexOf()`, this function works for finding `NaN` and differentiates between `-0` and `0`.",
      "params": [
        {
          "name": "subject",
          "description": "The array, object or string in which `target` should be searched for.",
          "type": "Array|Object|string"
        },
        {
          "name": "target",
          "description": "The target value to search for within `subject`.",
          "type": "*"
        },
        {
          "name": "opt_start",
          "description": "The position at which to start the search for strings or arrays.  This will be ignored for objects.  Negative values will be calculated from the end.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number|string|undefined",
        "description": "If `subject` is an array or a string this will be a integer representing the first position at which `target` is found within `subject` or this will be `-1` which represents that `target` was not found.  If `subject` is an object this will be key at which `target` was first found (based on `Object.keys()`) or `undefined` if `target` was not found."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Array test",
          "code": "test(YourJS.indexOf([0,NaN,-0,undefined], -0), 2);"
        }
      ]
    },
    {
      "name": "indexOfDiff",
      "code": "function indexOfDiff(str1, str2) {\n  var splitLen = Math.ceil(Math.min(str1.length, str2.length) / 2),\n      s1_1 = str1.slice(0, splitLen), s2_1 = str2.slice(0, splitLen);\n  return str1 != str2\n    ? splitLen\n      ? s1_1 != s2_1\n        ? splitLen - 1 && indexOfDiff(s1_1, s2_1)\n        : (indexOfDiff(str1.slice(splitLen), str2.slice(splitLen)) + splitLen)\n      : 0\n    : -1;\n}",
      "description": "Determine where 2 strings begin to differ from each other.",
      "params": [
        {
          "name": "str1",
          "description": "A string to be compared to another string.",
          "type": "string"
        },
        {
          "name": "str2",
          "description": "A string to be compared to `str1`.",
          "type": "string"
        }
      ],
      "return": {
        "type": "number",
        "description": "If `str1` matches `str2`, `-1` will be returned. In all other cases, the first index at which the corresponding character in `str1` is not the same as that found in `str2` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test([\n  YourJS.indexOfDiff('', ''),  // -> -1\n  YourJS.indexOfDiff('Cool', 'Cool'),  // -> -1\n  YourJS.indexOfDiff('Cool beans', 'Cool'),  // -> 4\n  YourJS.indexOfDiff('Cool beans', 'Cool jeans'),  // -> 5\n  YourJS.indexOfDiff(Math.PI + '', '3.14159')  // -> 7\n].join(', '), '-1, -1, 4, 5, 7');"
        }
      ]
    },
    {
      "name": "info",
      "code": "function info() {\n  return { name: __VARIABLE_NAME, version: __VERSION, toString: toString };\n}",
      "required": true,
      "description": "Gets the information for this version of YourJS.",
      "return": {
        "type": "Object",
        "description": "An object containing a `name` property and a `version` property."
      },
      "requires": [
        "toString"
      ],
      "params": [],
      "tests": []
    },
    {
      "name": "insert",
      "code": "eval('Intoc,aa,c'.replace(/([^,]*)((.),.)/g, 'function insert$1($2,b){a.splice(0==b&&0>1/b?a.length:b,0,c);return $3}'));",
      "description": "Inserts a value into an array at the given position.",
      "params": [
        {
          "name": "array",
          "description": "Array into which a value will be inserted.",
          "type": "Array"
        },
        {
          "name": "value",
          "description": "Value to insert into `array`.",
          "type": "*"
        },
        {
          "name": "position",
          "description": "Position at which to insert the value within `array`.  A negative value will mean that the position is counted from the end of `array`.  A position of `-0` means that `value` will be added to the end of `array`.",
          "type": "number"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A reference to `array`.  This is useful when chaining."
      },
      "requires": [
        "insertInto"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.insert([2,4],3,1)), '[2,3,4]');"
        }
      ]
    },
    {
      "name": "insertInto",
      "code": "",
      "description": "Inserts a value into an array at the given position.",
      "params": [
        {
          "name": "value",
          "description": "Value to insert into `array`.",
          "type": "*"
        },
        {
          "name": "array",
          "description": "Array into which a value will be inserted.",
          "type": "Array"
        },
        {
          "name": "position",
          "description": "Position at which to insert the value within `array`.  A negative value will mean that the position is counted from the end of `array`.  A position of `-0` means that `value` will be added to the end of `array`.",
          "type": "number"
        }
      ],
      "return": {
        "type": "*",
        "description": "A reference to `value`.  This is useful when chaining."
      },
      "requires": [
        "insert"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "result = YourJS.insertInto(3,arr = [2,4],1);\ntest(JSON.stringify([arr, result]), '[[2,3,4],3]');"
        }
      ]
    },
    {
      "name": "int16",
      "code": "",
      "description": "Takes a number and converts it to a twos-complement 16-bit signed integer.",
      "params": [
        {
          "name": "number",
          "description": "Number to be converted to a twos-complement 16-bit signed integer.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the specified number as a twos-complement 16-bit signed integer."
      },
      "requires": [
        "int8"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.int16(65600.819), 64)"
        }
      ]
    },
    {
      "name": "int32",
      "code": "",
      "description": "Takes a number and converts it to a twos-complement 32-bit signed integer.",
      "params": [
        {
          "name": "number",
          "description": "Number to be converted to a twos-complement 32-bit signed integer.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the specified number as a twos-complement 32-bit signed integer."
      },
      "requires": [
        "int8"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.int32(-4294967400.42), -104)"
        }
      ]
    },
    {
      "name": "int8",
      "code": "// Creates the following functions:  int8(), uint8(), int16(), uint16(), int32(), and uint32()\n// Works in IE10+\neval('uUi32I32uUi16I16uUi8I8'.replace(/(u?)([UI]i?)(\\d\\d?)/g, 'var $1int$3;(function(a){$1int$3=function(x){return a[0]=x,a[0]}})(new $2nt$3Array(1));'));",
      "description": "Takes a number and converts it to a twos-complement 8-bit signed integer.",
      "params": [
        {
          "name": "number",
          "description": "Number to be converted to a twos-complement 8-bit signed integer.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the specified number as a twos-complement 8-bit signed integer."
      },
      "requires": [
        "int16",
        "int32",
        "uint8",
        "uint16",
        "uint32"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.int8(304.8), 48)"
        }
      ]
    },
    {
      "name": "intersect",
      "code": "function intersect(array1, array2) {\n  return diffArrays(array1, diffArrays(array1, array2));\n}",
      "description": "Gets a new array that will be the intersection of two arrays.",
      "params": [
        {
          "name": "array1",
          "description": "First array to be intersected with the second array.",
          "type": "Array"
        },
        {
          "name": "array2",
          "description": "Second array to be intersected with the first array.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array with all of the values that `array1` and `array2` share while each value only appears as many times as the minimum amount of times it is found in either array."
      },
      "requires": [
        "diffArrays"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.intersect([1,2,2,2,3,3,4,5], [2,2,3,4,4,5])), '[2,2,3,4,5]');"
        }
      ]
    },
    {
      "name": "invert",
      "code": "function invert(obj, opt_initial) {\n  for (var result = opt_initial || {}, pairs = entries(obj), i = 0, l = pairs.length; i < l; i++) {\n    result[pairs[i][1]] = pairs[i][0];\n  }\n  return result;\n}",
      "description": "Creates the inverse of an object by making a new object where the keys are the values and the values are the keys.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose keys and values will be inverted and returned.",
          "type": "*"
        },
        {
          "name": "opt_initial",
          "description": "Object to which the value/key pairs should be added.  If not given an empty object will be used.",
          "type": "*",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "*",
        "description": "Adds the value/key pairs found in `obj` to `opt_initial` where all of the keys added will be the values from `obj` and all of the corresponding values will be the keys."
      },
      "requires": [
        "entries"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "is",
      "code": "// // Original is():\n// function is() {\n//   for (\n//     var a, b, args = arguments, i = args.length;\n//     a = args[--i], b = args[i - 1], i && (a === a ? a === 0 ? 1 / a === 1 / b : a === b : b !== b);\n//   );\n//   return i < 1;\n// }\neval('>Not<='.replace(/(\\w*)(.=?)/g, 'function is$1(){for(var a,b,d=arguments,c=d.length;a=d[--c],b=d[c-1],c&&(a===a?0===a?1/a===1/b:a===b:b!==b););return 1$2c}'));",
      "description": "Tests to see if two or more values are exactly the same. This is similar to `===` but will also indicate that `NaN` is `NaN` and will indicate that `-0` is not `0`.",
      "params": [
        {
          "name": "x",
          "description": "A value.",
          "type": "*"
        },
        {
          "name": "y",
          "description": "Value to be compared to `x` for equality.",
          "type": "*"
        },
        {
          "name": "otherValues",
          "description": "Any additional values to be compared to `x` and `y`.",
          "type": "*",
          "optional": true,
          "rest": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if all of the parameters passed in are exactly the same, otherwise `false` is returned."
      },
      "requires": [
        "slice",
        "isNot"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  YourJS.is(-0, 0),\n  false\n);"
        }
      ]
    },
    {
      "name": "isArguments",
      "code": "eval('var Arguments,Array,Boolean,Date,Function,Null,Number,Object,RegExp,String,Undefined,Unknown'.replace(/[A-Z]\\w+/g, 'is$&'));\n'Arguments Array Boolean Date Function null Number Object RegExp String undefined *unknown'.replace(/\\*?(\\w)(\\w+)/g, function(all, first, rest) {\n  eval('(function(t){is' + first.toUpperCase() + rest + '=function(v){return t(v)===\"' + all + '\"}})')(typeOf);\n});",
      "description": "Determines if the given value is of type `Arguments` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Arguments` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Arguments` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "typeOf",
        "isArray",
        "isBoolean",
        "isDate",
        "isFunction",
        "isNull",
        "isNumber",
        "isObject",
        "isRegExp",
        "isUndefined",
        "isUnknown",
        "isString"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "(function() {\n  test(\n    [YourJS.isArguments(arguments), YourJS.isArguments([])].join(','),\n    'true,false'\n  );\n})();"
        }
      ]
    },
    {
      "name": "isArray",
      "code": "",
      "description": "Determines if the given value is of type `Array` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Array` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Array` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "(function() {\n  test(\n    [YourJS.isArray(arguments), YourJS.isArray([])].join(','),\n    'false,true'\n  );\n})();"
        }
      ]
    },
    {
      "name": "isArrayLike",
      "code": "function isArrayLike(o) {\n  var l, i, t = nativeType(o);\n  return t === 'Array'\n      || (!!o\n        && !o.nodeName\n        && typeof(l = o.length) === 'number'\n        && 'Function' !== t && 'String' !== t\n        && (!l || (l > 0 && (i = l - 1) % 1 == 0 && i in o)));\n}",
      "description": "Determines if an object is an array or at least array-like.",
      "params": [
        {
          "name": "o",
          "description": "A value to test and see if it array-like.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating if the object was an array or array-like."
      },
      "requires": [
        "nativeType"
      ],
      "required": false,
      "tests": [
        {
          "name": "3-in-1",
          "code": "test(\n  [YourJS.isArrayLike([]), YourJS.isArrayLike(document.body.childNodes), YourJS.isArrayLike('Hello')]+'',\n  [true, true, false]+''\n)"
        }
      ]
    },
    {
      "name": "isBitable",
      "code": "function isBitable(value) {\n  return ~~value == Math.trunc(value);\n}",
      "description": "Tests to see if a number can be the operand of a bitwise operator without losing integral precision.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it can be an operand for a bitwise operator without losing integral precision.",
          "type": "number"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` will not lose integral precision when used as an operand for a bitwise operator.  Otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isBitable(2), YourJS.isBitable(Infinity), YourJS.isBitable(2.1), YourJS.isBitable(Math.pow(2,31)-1), YourJS.isBitable(Math.pow(2,31))].join(','),\n  'true,false,true,true,false'\n);"
        }
      ]
    },
    {
      "name": "isBoolean",
      "code": "",
      "description": "Determines if the given value is of type `Boolean` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Boolean` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Boolean` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isBoolean(0), YourJS.isBoolean(false)].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isComposite",
      "code": "function isComposite(num) {\n  return num > 1 && !isPrime(num);\n}",
      "description": "Determines if a number is a positive integer that is divisible by other integers apart from `1` and itself.",
      "params": [
        {
          "name": "num",
          "description": "Number to be tested.",
          "type": "number"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `num` is divisible by another integer other than `1` and itself, otherwise `false`."
      },
      "requires": [
        "isPrime"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isDate",
      "code": "",
      "description": "Determines if the given value is of type `Date` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Date` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Date` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isDate(0), YourJS.isDate(new Date)].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isEmpty",
      "code": "function isEmpty(value) {\n  var isNotArrayLike = !isArrayLike(value = Object(value));\n  for (var k in value) {\n    if (has(value, k) && (isNotArrayLike || ~~k == k)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "description": "Determines if an array, arguments list, other type of list or collection is empty. Also can be used on objects to ensure that it doesn't have any properties explicitly set.",
      "params": [
        {
          "name": "value",
          "description": "Value to be checked.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `false` if `value` is an empty array, arguments list, node list, element collection, or string. Returns `false` if `value` has no properties of its own defined. In all other cases, `true` is returned."
      },
      "requires": [
        "isArrayLike",
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Check Empty Array",
          "code": "var arr = new Array();\narr.length = 123;\ntest(YourJS.isEmpty(arr), true);"
        }
      ]
    },
    {
      "name": "isError",
      "code": "function isError(value, opt_testForAnyError) {\n  return typeOf(value).slice(opt_testForAnyError ? -5 : 0) == 'Error';\n}",
      "description": "Determines if a value is an `Error` object.",
      "params": [
        {
          "name": "value",
          "description": "Value to be tested.",
          "type": "*"
        },
        {
          "name": "opt_testForAnyError",
          "description": "Indicates whether or not any type of object whose type name ends with `\"Error\"` will count as an error object.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `opt_testForAnyError` is `false`-ish or not given and `value` is an `Error` object.  `true` if `opt_testForAnyError` is `true`-ish and the type name of `value` ends with `\"Error\"`.  Otherwise `false`."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isFalsy",
      "code": "function isFalsy(value, opt_strict) {\n  return !value || (!opt_strict && (isArrayLike(value) || value.constructor == Object) && isEmpty(value));\n}",
      "description": "Basically used to determine if something is falsy or is an empty collection of sorts.",
      "params": [
        {
          "name": "value",
          "description": "Value to check.",
          "type": "*"
        },
        {
          "name": "opt_strict",
          "description": "Ordinarilly `isFalsy()` will check if a value is falsy or is an empty collection. If this argument is `true`-ish `isFalsy()` will not check `value` to see if it is an empty collection but will only return the equivalent of `!value`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `false` if `value` is an empty array, arguments list, node list, element collection, or string. Returns `false` if `value` is an object of type `Object` which has no properties of its own defined. Returns `false` if `value` is falsy. In all other cases, `true` is returned."
      },
      "requires": [
        "isArrayLike",
        "isEmpty"
      ],
      "required": false,
      "tests": [
        {
          "name": "Check Falsy Array",
          "code": "var arr = new Array();\narr.length = 123456789;\ntest(YourJS.isFalsy(arr), true);"
        }
      ]
    },
    {
      "name": "isFinite",
      "code": "function isFinite(value) {\n  return 'number' == typeof value && __GLOBAL.isFinite(value);\n}",
      "description": "Tests a value to see if it is a number that is also finite.",
      "params": [
        {
          "name": "value",
          "description": "The value to be tested to see if it is a number and is finite.",
          "type": "number|*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is a number and is finite, otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isFinite(2), YourJS.isFinite(Infinity), YourJS.isFinite('3')].join(','),\n  'true,false,false'\n);"
        }
      ]
    },
    {
      "name": "isFloat",
      "code": "function isFloat(value) {\n  return ('number' == typeof value) && !!(value % 1);\n}",
      "description": "Determines if a value is a floating point number.",
      "params": [
        {
          "name": "value",
          "description": "Value to be tested.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is a floating point number, otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isFullOf",
      "code": "function isFullOf(arrOrObj, tester, opt_trueOnEmpty) {\n  var result = true, isStrTester = typeOf(tester) == 'String';\n  var count = forOf(arrOrObj, function(value, key, arrOrObj, end) {\n    if (isStrTester ? typeOf(value) != tester : !tester(value, key, arrOrObj)) {\n      result = false;\n      end();\n    }\n  });\n  return result && (count > 0 || !!opt_trueOnEmpty);\n}",
      "description": "Determines if an array, array-like object, or an object is full of items that match a specific type or tester function.",
      "params": [
        {
          "name": "arrOrObj",
          "description": "Array, array-like object, or object whose items will be tested.",
          "type": "Array|Object"
        },
        {
          "name": "tester",
          "description": "If a string is specified it will be assumed to be the type that all values in `arrOrObj` must match.  Otherwise this must be a function that will accept (1) the item value, (2) the item index, and (3) a reference to `arrOrObj` and the return value of this function will coerced to a boolean to determine if the value matched.",
          "type": "string|Function"
        },
        {
          "name": "opt_trueOnEmpty",
          "description": "Indicates whether or not an empty `arrOrObj` will allow this call to `isFullOf()` to evaluate to `true`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if all of the items in `arrOrObj` match `tester` or if `arrOrObj` is empty and `opt_trueOnEmpty` is `true`-ish.  Otherwise `false`."
      },
      "requires": [
        "forOf",
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Positive Array Type Test",
          "code": "test(YourJS.isFullOf([2,3,4,5], 'Number'), true);"
        },
        {
          "name": "Simple Positive Object Type Test",
          "code": "test(YourJS.isFullOf({d:/5/,c:/q/,e:/z/,a:/d/}, 'RegExp'), true);"
        }
      ]
    },
    {
      "name": "isFunction",
      "code": "",
      "description": "Determines if the given value is of type `Function` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Function` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Function` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isFunction(new (function(){})), YourJS.isFunction((function(){}))].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isInRange",
      "code": "function isInRange(value, lowerBound, upperBound, opt_excludeBounds) {\n  return opt_excludeBounds\n    ? lowerBound < value && value < upperBound\n    : (lowerBound <= value && value <= upperBound);\n}",
      "description": "Determines if a value is within a given range.",
      "params": [
        {
          "name": "value",
          "description": "Value to be checked.",
          "type": "number|string"
        },
        {
          "name": "lowerBounds",
          "description": "Lower bounds against which `value` will be checked.",
          "type": "number|string"
        },
        {
          "name": "upperBounds",
          "description": "Upper bounds against which `value` will be checked.",
          "type": "number|string"
        },
        {
          "name": "opt_excludeBounds",
          "description": "Indicates whether or not equality to the bounds should prevent the `value` from being considered within the range.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is greater than or equal `lowerBound` and less than or equal `upperBound` (equality test is ignored if `opt_excludeBounds` is `true`-ish), otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isInt",
      "code": "function isInt(value) {\n  return ('number' == typeof value) && value % 1 == 0;\n}",
      "description": "Determines if a value is an integer.",
      "params": [
        {
          "name": "value",
          "description": "Value to be tested.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is an integer, otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isKind",
      "code": "function isKind(value) {\n  value = kindsOf(value);\n  for (\n    var args = slice(arguments), argc = args.length, i = 1;\n    i < argc && indexOf(value, args[i]) < 0;\n    i++\n  );\n  return i < argc;\n}",
      "description": "Checks to see if a value is of a specific kind.",
      "params": [
        {
          "name": "value",
          "description": "Value to determine if it matches any of the type names given.",
          "type": "*"
        },
        {
          "name": "kindName",
          "description": "Possible kind names to match `value` against.",
          "type": "string",
          "rest": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating if the kinds of `value` matched against any of the `kindName` arguments passed."
      },
      "requires": [
        "slice",
        "kindsOf",
        "indexOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.isKind([], 'Array'), true)"
        }
      ]
    },
    {
      "name": "isKindFor",
      "code": "function isKindFor() {\n  var args = slice(arguments),\n    argc = args.length,\n    negate = argc > 1 && 'boolean' === typeof args[argc - 1] && (argc-- , args.pop());\n  return function (value) {\n    return isKind.apply(isKind, [value].concat(args)) !== negate;\n  };\n}",
      "description": "Creates a partial isKind() function.",
      "params": [
        {
          "name": "kindName",
          "description": "One or more kind names to check against values.",
          "type": "string",
          "optional": false,
          "rest": true
        },
        {
          "name": "opt_negate",
          "description": "If specified the returned function's return value will always be negated.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A function that can be used to see if any value passed to it is one of the kind names passed in as `kindName`. The return value will indicate if one of the kind names matches the kind of the value passed to it. If `opt_negate` is `true` the return value of this function will be the opposite."
      },
      "requires": [
        "slice",
        "isKind"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isLeapYear",
      "code": "function isLeapYear(opt_year) {\n  if ('number' != typeof opt_year) {\n    opt_year = (opt_year == undefined ? new Date : opt_year).getFullYear();\n  }\n  return opt_year % (opt_year % 100 ? 4 : 400) == 0;\n}",
      "description": "Determine if the specified year is a leap year.",
      "params": [
        {
          "name": "opt_year",
          "description": "The year to be tested.  If a date is specified the year from that date will be used.  If nothing is specified the current year will be used.",
          "type": "Date|number",
          "optional": true,
          "default": "new Date()"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `year` is a leap year, otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isLowerCase",
      "code": "",
      "description": "Determines if a string doesn't have upper cased characters.",
      "params": [
        {
          "name": "str",
          "description": "The value to be checked.",
          "type": "string"
        },
        {
          "name": "opt_allowNoCasing",
          "description": "If `true`, characters without casing found in `str` will be viewed as lower cased characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` only has cased characters that are lower cased or if `opt_allowNoCasing` is `true` and `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isMixCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isMixCase",
      "code": "eval('Mix   Lower Upper No'.replace(/\\w+/g, function(name, i) {\n  return 'function is' + name + 'Case(s,n){s=0 in arguments?s+\"\":\"\";return(s=(s==s.toLowerCase()?6:0)+(s==s.toUpperCase()?12:0))==' + i + '||(!!n&&s>12);}';\n}));",
      "description": "Determines if a string has both upper cased and lower cased characters.",
      "params": [
        {
          "name": "str",
          "description": "The value to be checked.",
          "type": "string"
        },
        {
          "name": "opt_allowNoCasing",
          "description": "If `true`, characters without casing found in `str` will be viewed as mixed cased characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` has mixed cased characters or if `opt_allowNoCasing` is `true` and `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isLowerCase",
        "isUpperCase",
        "isNoCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isNaN",
      "code": "function isNaN(value) {\n  return value !== value;\n}",
      "description": "Determines whether or not a value is actually `NaN`.  Different from the global `isNaN` function because it only tests for the presence of the `NaN` value.",
      "params": [
        {
          "name": "value",
          "description": "Value to test to see if it is `NaN`.",
          "type": "number|*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "If `value` is `NaN` then `true` is returned, otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isNaN({}), YourJS.isNaN(Infinity), YourJS.isNaN(NaN)].join(','),\n  'false,false,true'\n);"
        }
      ]
    },
    {
      "name": "isNegative",
      "code": "function isNegative(value, opt_includeNegZero) {\n  return value < 0 || (!!opt_includeNegZero && 1 / value < 0);\n}",
      "description": "Determines if a value is negative.",
      "params": [
        {
          "name": "value",
          "description": "The value to test to see if it is negative.",
          "type": "number"
        },
        {
          "name": "opt_includeNegZero",
          "description": "Value indicating whether or not `-0` should be counted as negative.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is negative or if `value` is `-0` and `opt_includeNegZero` is `true`-ish.  Otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isNegative(-2), YourJS.isNegative(-Infinity), YourJS.isNegative(-0), YourJS.isNegative(-0, true)].join(','),\n  'true,true,false,true'\n);"
        }
      ]
    },
    {
      "name": "isNil",
      "code": "function isNil(value) {\n  return value == undefined;\n}",
      "description": "Determines if a value is either `null` or `undefined`.",
      "params": [
        {
          "name": "value",
          "description": "The value to be checked.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if value is either `null` or `undefined`. Otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isNoCase",
      "code": "",
      "description": "Determines if a string only has characters without casing.",
      "params": [
        {
          "name": "str",
          "description": "The value to be checked.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isMixCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isNot",
      "code": "",
      "description": "Tests to see if two or more values are not exactly the same. This is similar to `!==` but will also work with `NaN` and can differentiate between `-0` and `0`.",
      "params": [
        {
          "name": "x",
          "description": "A value.",
          "type": "*"
        },
        {
          "name": "y",
          "description": "Value to be compared to `x` for inequality.",
          "type": "*"
        },
        {
          "name": "otherValues",
          "description": "Any additional values to be compared to `x` and `y`.",
          "type": "*",
          "optional": true,
          "rest": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if any of the parameters passed are not exactly the same, otherwise `false` is returned."
      },
      "requires": [
        "is"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.isNot(0,-0), true)"
        }
      ]
    },
    {
      "name": "isNull",
      "code": "",
      "description": "Determines if the given value is `null` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is `null` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is `null` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isNull(undefined), YourJS.isNull(null)].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isNumber",
      "code": "",
      "description": "Determines if the given value is of type `Number` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Number` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Number` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isNumber('1'), YourJS.isNumber(1)].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isNumeric",
      "code": "function isNumeric(value) {\n  return  'string' == typeof value && !value != __GLOBAL.isFinite(Number(value));\n}",
      "description": "Indicates if a value is a numeric string.",
      "params": [
        {
          "name": "value",
          "description": "Value to test.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean indicating whether or not `value` is a numeric string."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple True",
          "code": "test(YourJS.isNumeric('34.532'), true);"
        },
        {
          "name": "Simple False",
          "code": "test(YourJS.isNumeric('D34.532'), false);"
        }
      ]
    },
    {
      "name": "isObject",
      "code": "",
      "description": "Determines if the given value is of type `Object` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `Object` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `Object` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isObject(new (function(){})), YourJS.isObject({})].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isoDate",
      "code": "function isoDate(opt_date) {\n  opt_date = opt_date || new Date;\n  return opt_date.getUTCFullYear() + \"-\"\n    + (\"0\" + (opt_date.getUTCMonth() + 1) + \"-\").slice(-3)\n    + (\"0\" + opt_date.getUTCDate() + \"T\").slice(-3)\n    + (\"0\" + opt_date.getUTCHours() + \":\").slice(-3)\n    + (\"0\" + opt_date.getUTCMinutes() + \":\").slice(-3)\n    + (\"0\" + opt_date.getUTCSeconds() + \".\").slice(-3)\n    + (\"00\" + opt_date.getUTCMilliseconds() + \"Z\").slice(-4);\n}",
      "description": "Gets the date in the ISO-8601 standard format: `YYYY-MM-DDTHH:mm:ss.sssZ`",
      "params": [
        {
          "name": "opt_date",
          "description": "Date to convert to ISO-8601 format.  If not given the current date/time is used.",
          "type": "Date",
          "optional": true,
          "default": "new Date()"
        }
      ],
      "return": {
        "type": "string",
        "description": "`opt_date` as a string in the ISO-8601 format: `YYYY-MM-DDTHH:mm:ss.sssZ`"
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.isoDate(new Date(Date.UTC(2010,9,8,7,6,5,4))), '2010-10-08T07:06:05.004Z');"
        }
      ]
    },
    {
      "name": "isOf",
      "code": "function isOf(value, opt_negate, opt_traverseArray) {\n  var parts, xs = [];\n\n  parts = (value = (opt_traverseArray && nativeType(value) === 'Array') ? value : [value]).map(function (x, i) {\n    return (x !== x ? 'v!==v' : 'v===x').replace('x', xs[i] = 'x' + i);\n  });\n\n  return Function(\n    xs.join(','),\n    ('return function(v){return' + (opt_negate ? '!' : '') + '(' + parts.join('||') + ')}')\n  ).apply(0, value);\n}",
      "description": "Creates functions for testing if a value \"is\" (or \"is not\") a value.",
      "params": [
        {
          "name": "value",
          "description": "The value that the returned function will always be used to check against.",
          "type": "*"
        },
        {
          "name": "opt_negate",
          "description": "Determines if the returned function will always check if passed values are NOT `value`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        },
        {
          "name": "opt_traverseArray",
          "description": "If `value` is an array, the returned function will check the passed value against all of the items within `value`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "Function that accepts one argument which will be checked against `value`.  The function will return a boolean value when called indicating if it matches `value` or not (also depending on the value of `opt_negate`)."
      },
      "requires": [
        "nativeType"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var nan = YourJS.isOf([NaN], false, true);\nvar nnan = YourJS.isOf(NaN, true);\ntest(JSON.stringify([nan(NaN), nnan(NaN), nan(0), nnan(0)]), '[true,false,false,true]');"
        }
      ]
    },
    {
      "name": "isPositive",
      "code": "function isPositive(value, opt_includeZero) {\n  return value > 0 || (!!opt_includeZero && 1 / value > 0);\n}",
      "description": "Determines if a value is positive.",
      "params": [
        {
          "name": "value",
          "description": "Value to be tested as to whether or not it is positive.",
          "type": "number"
        },
        {
          "name": "opt_includeZero",
          "description": "Value indicating whether or not `0` should be counted as positive.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is negative or if `value` is `-0` and `opt_includeNegZero` is `true`-ish.  Otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isPositive(2), YourJS.isPositive(Infinity), YourJS.isPositive(0), YourJS.isPositive(0, true)].join(','),\n  'true,true,false,true'\n);"
        }
      ]
    },
    {
      "name": "isPrime",
      "code": "function isPrime(num) {\n  if(!isSafeInt(num)) {\n    throw new TypeError(\"expected a finite integer\");\n  }\n  if(num < 2) {\n    return false;\n  }\n  if(num < 4) {\n    return true;\n  }\n  if(num % 2 == 0 || num % 3 == 0) {\n    return false;\n  }\n  for(var max = parseInt(Math.sqrt(num)) + 2, check = 6; check <= max; check += 6) {\n    if(num % (check - 1) == 0 || num % (check + 1) == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
      "description": "Determines if a number is a prime integer.",
      "params": [
        {
          "name": "num",
          "description": "Number to be tested.",
          "type": "number"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `num` is a positive integer that is only divisible by itself and `1`.  Otherwise `false`."
      },
      "requires": [
        "isSafeInt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isPrimitive",
      "code": "function isPrimitive(arg) {\n  var type = typeof arg;\n  return arg == undefined || (type != \"object\" && type != \"function\");\n}",
      "description": "Determines if something is a primitive or not. If not a primitive it must be some form of object.",
      "params": [
        {
          "name": "arg",
          "description": "The argument which will be determined as being either a primitive (eg. boolean, number, string, etc.) or a non-primitive.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` will be returned if `arg` is simply a primitive, otherwise `false` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isPrototype",
      "code": "function isPrototype(obj) {\n  var c = obj && obj.constructor;\n  return (c && 'function' === typeof c) ? c.prototype === obj : false;\n}",
      "description": "Determines if an object is a prototype object.",
      "params": [
        {
          "name": "obj",
          "description": "Object to check to see if it is a prototype.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "If `obj` is a prototype object `true` is returned, otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isRegExp",
      "code": "",
      "description": "Determines if the given value is of type `RegExp` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `RegExp` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `RegExp` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isRegExp(new Date), YourJS.isRegExp(/d/)].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isRegExpMatch",
      "code": "function isRegExpMatch(rgx, opt_str, opt_onlyCheckStart) {\n  rgx = RegExp(rgx.source + '|([\\\\S\\\\s])', (rgx + '').replace(/[\\s\\S]+\\/|g/g, '') + 'g');\n  function f(str, opt_checkStartOnly) {\n    rgx.lastIndex = undefined;\n    opt_checkStartOnly = 1 in arguments ? opt_checkStartOnly : opt_onlyCheckStart;\n    var isMatch = false, match, keepGoing = 1;\n    while ((match = rgx.exec(str)) && keepGoing) {\n      isMatch = slice(match, -1)[0] == undefined;\n      keepGoing = isMatch && !opt_checkStartOnly;\n    }\n    return isMatch;\n  }\n  return opt_str == undefined ? f : f(opt_str, opt_onlyCheckStart);\n}",
      "description": "Determine whether or not a RegExp matches an entire string (or the start of a string).",
      "params": [
        {
          "name": "rgx",
          "description": "The regular expression to be used.",
          "type": "RegExp"
        },
        {
          "name": "opt_str",
          "description": "If specified, `rgx` will be matched against the string to see if the regular expression matches from the beginning. If not specified, a function will be returned that will be used to match against `rgx` whenever it is called.",
          "type": "string",
          "optional": true
        },
        {
          "name": "opt_onlyCheckStart",
          "description": "If `true`, `rgx` must only match the beginning of `opt_str`. If `false`, `rgx` must match the entire string `opt_str`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `opt_str` is given and is not `null` or `undefined`, a boolean will be returned. If `opt_onlyCheckStart` is `true`-ish the value returned will indicate if `rgx` simply matched from the beginning of `opt_str`. If `opt_onlyCheckStart` is `false`-ish, the value returned will indicate if `rgx` matched all of `opt_str`. If `opt_str` is not given or `null` or `undefined` a function to match against `rgx` will be returned which will accept a string as the 1st argument that will act as `opt_str` would have and a 2nd optional argument which will act as `opt_onlyCheckStart` would have and will return a boolean indicating if `rgx` matches `str`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSafeInt",
      "code": "var isSafeInt;\n(function(MAX_POSITIVE_INT) {\n  isSafeInt = function(value) {\n    return 'number' == typeof value && value % 1 == 0 && Math.abs(value) <= MAX_POSITIVE_INT;\n  };\n})(Math.pow(2,53) - 1);",
      "description": "Determines if the argument that is passed in is an integer in the range of `-9007199254740991` and `9007199254740991`.",
      "params": [
        {
          "name": "value",
          "description": "Value to test out.",
          "type": "number"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean indicating if `value` is an integer within the range of `-9007199254740991` and `9007199254740991`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple Positive Test",
          "code": "test(YourJS.isSafeInt(2384928359223), true);"
        },
        {
          "name": "Simple Negative Test",
          "code": "test(YourJS.isSafeInt(-238492234898359223), false);"
        },
        {
          "name": "Test Int",
          "code": "test(YourJS.isSafeInt(2.9223), false);"
        }
      ]
    },
    {
      "name": "isSameDay",
      "code": "",
      "description": "Determines if one date is in the same year, month and day as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month and day will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameFridayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Friday to Thursday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Friday to Thursday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameHour",
      "code": "",
      "description": "Determines if one date is in the same year, month, day, and hour as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, day, and hour will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameMinute",
      "code": "",
      "description": "Determines if one date is in the same year, month, day, hour, and minute as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, day, hour, and minute will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameMondayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Monday to Sunday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Monday to Sunday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameMonth",
      "code": "",
      "description": "Determines if one date is in the same year and month as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year and month will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var now = new Date;\nvar d = new Date(now.getFullYear(), now.getMonth(), (32 - now.getDate()) % 28 || 1);\ntest(YourJS.isSameMonth(now, d), true);"
        }
      ]
    },
    {
      "name": "isSameSaturdayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Saturday to Friday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Saturday to Friday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameSecond",
      "code": "",
      "description": "Determines if one date is in the same year, month, day, hour, minute, and second as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, day, hour, minute, and second will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameSundayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Sunday to Saturday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Sunday to Saturday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameThursdayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Thursday to Wednesday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Thursday to Wednesday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameTuesdayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Tuesday to Monday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Tuesday to Monday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameWednesdayWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Wednesday to Tuesday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Wednesday to Tuesday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameWeek",
      "code": "",
      "description": "Determines if one date is in the same year, month, and week (Sunday to Saturday) as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year, month, and week (Sunday to Saturday) will be returned."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSameYear",
      "code": "// Creates the following 56 functions:\n// isSameYear(), startOfYear(), endOfYear(), spanOfYear(), isSameMonth(), startOfMonth(), endOfMonth(), spanOfMonth(), isSameDay(), startOfDay(), endOfDay(), spanOfDay(), isSameHour(), startOfHour(), endOfHour(), spanOfHour(), isSameMinute(), startOfMinute(), endOfMinute(), spanOfMinute(), isSameSecond(), startOfSecond(), endOfSecond(), spanOfSecond(), isSameWeek(), startOfWeek(), endOfWeek(), spanOfWeek(), isSameSundayWeek(), startOfSundayWeek(), endOfSundayWeek(), spanOfSundayWeek(), isSameMondayWeek(), startOfMondayWeek(), endOfMondayWeek(), spanOfMondayWeek(), isSameTuesdayWeek(), startOfTuesdayWeek(), endOfTuesdayWeek(), spanOfTuesdayWeek(), isSameWednesdayWeek(), startOfWednesdayWeek(), endOfWednesdayWeek(), spanOfWednesdayWeek(), isSameThursdayWeek(), startOfThursdayWeek(), endOfThursdayWeek(), spanOfThursdayWeek(), isSameFridayWeek(), startOfFridayWeek(), endOfFridayWeek(), spanOfFridayWeek(), isSameSaturdayWeek(), startOfSaturdayWeek(), endOfSaturdayWeek(), spanOfSaturdayWeek()\neval('Year Month Day Hour Minute Second Week Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' ').map(\n  function(unit, i) {\n    var code = 'b@Month(11) b.(1);a.(32);a.Date(0) b@Hours(23) b@Minutes(59) b@Seconds(59) b@Milliseconds(999)'.replace(/@/g, '.(0);a.').replace(/\\.(\\w*)\\((?=\\S+\\.(\\w+)\\S+|)/g, '.set$1$2(').split(' ');\n    if (i > 5) {\n      var offset = i > 6 ? 14 - i : 7;\n      code.push('b.setDate(b.getDate()-(b.getDay()+'\n        + offset + ')%7);a.setDate(a.getDate()-(a.getDay()+'\n        + offset + ')%7+6)');\n      if (i > 6) {\n        unit += 'Week';\n      }\n      i = 2;\n    }\n    code = 'function #(a){var b=new Date(a);a=new Date(a);@;return [b,a]}'.replace('@', code.slice(i).join(';'));\n    return code.replace('){', ',c){if(void 0===c)return function(c){return #(a,c)};').replace(/\\ba\\.set;/g, '').replace('[b,a]', 'b<=c&&c<=a').replace(/#/g, 'isSame' + unit)\n      + code.replace(/\\ba\\.set;|\\[(b),a\\]/g, '$1').replace('#', 'startOf' + unit)\n      + code.replace(/\\bb\\.set;|\\[b,(a)\\]/g, '$1').replace('#', 'endOf' + unit)\n      + code.replace('#', 'spanOf' + unit);\n  }\n).join(''));",
      "description": "Determines if one date is in the same year as another date.",
      "params": [
        {
          "name": "date1",
          "description": "The date to be compared to `date2`.",
          "type": "Date"
        },
        {
          "name": "date2",
          "description": "The date to be compared to `date1`.  If `undefined` or not specified then a partial function will be returned which will accept `date2` as its only parameter.",
          "type": "Date",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `date2` is not given or is `undefined` a partial function will be returned which will accept `date2` as its only parameter.  If `date1` and `date2` are specified then a boolean indicating whether or not they are in the same year will be returned."
      },
      "requires": [
        "isSameMonth",
        "startOfYear",
        "startOfWeek",
        "startOfWednesdayWeek",
        "startOfTuesdayWeek",
        "startOfThursdayWeek",
        "startOfSundayWeek",
        "startOfFridayWeek",
        "startOfHour",
        "startOfMinute",
        "startOfMondayWeek",
        "startOfMonth",
        "startOfSaturdayWeek",
        "startOfSecond",
        "startOfDay",
        "isSameSaturdayWeek",
        "isSameWednesdayWeek",
        "isSameWeek",
        "isSameSecond",
        "isSameSundayWeek",
        "isSameDay",
        "isSameFridayWeek",
        "isSameThursdayWeek",
        "isSameHour",
        "isSameMinute",
        "isSameMondayWeek",
        "isSameTuesdayWeek",
        "endOfDay",
        "endOfFridayWeek",
        "endOfHour",
        "endOfMinute",
        "endOfTuesdayWeek",
        "endOfThursdayWeek",
        "endOfSundayWeek",
        "endOfSecond",
        "endOfSaturdayWeek",
        "endOfMonth",
        "endOfMondayWeek",
        "endOfWednesdayWeek",
        "endOfWeek",
        "endOfYear",
        "spanOfYear",
        "spanOfWeek",
        "spanOfWednesdayWeek",
        "spanOfTuesdayWeek",
        "spanOfMondayWeek",
        "spanOfMonth",
        "spanOfSaturdayWeek",
        "spanOfSecond",
        "spanOfSundayWeek",
        "spanOfThursdayWeek",
        "spanOfMinute",
        "spanOfHour",
        "spanOfFridayWeek",
        "spanOfDay"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSpace",
      "code": "var isSpace = isRegExpMatch(/[ \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/);",
      "description": "Test for space characters starting at the beginning of a string.",
      "params": [
        {
          "name": "str",
          "description": "The string to be tested.",
          "type": "string"
        },
        {
          "name": "opt_onlyCheckStart",
          "description": "If `true`, only the beginning of the string is checked to see if it starts with a space character. If `false`, all of the string is checked to see if it only contains space characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if `opt_onlyCheckStart` is `true`-ish and `str` starts with a space character or if `opt_onlyCheckStart` is `false`-ish and `str` only contains space characters. Otherwise `false` is returned."
      },
      "requires": [
        "isRegExpMatch"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isString",
      "code": "",
      "description": "Determines if the given value is of type `String` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is of type `String` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is of type `String` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isString(['sdfs']), YourJS.isString('sdfs')].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isType",
      "code": "function isType(value) {\n  value = typeOf(value);\n  for (var a = arguments, i = a.length; --i && a[i] != value; );\n  return i > 0;\n}",
      "description": "Determines if a value is of a specific type or one of a list of specific types.",
      "params": [
        {
          "name": "value",
          "description": "Value to determine if it matches any of the type names given.",
          "type": "*"
        },
        {
          "name": "typeName",
          "description": "Possible type names to match `value` against.",
          "type": "string",
          "rest": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating if the type of `value` matched against any of the `typeName` arguments passed."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isTypeFor",
      "code": "function isTypeFor() {\n  var args = slice(arguments),\n    argc = args.length,\n    negate = argc > 1 && 'boolean' === typeof args[argc - 1] && (argc-- , args.pop());\n  return function (value) {\n    value = typeOf(value);\n    for (var i = 0; i < argc && args[i] != value; i++);\n    return i < argc !== negate;\n  };\n}",
      "description": "Creates a partial `isType()` function.",
      "params": [
        {
          "name": "typeNames",
          "description": "One or more type names to check against values.",
          "type": "string",
          "rest": true,
          "optional": false
        },
        {
          "name": "opt_negate",
          "description": "If specified the returned function's return value will always be negated.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A function that can be used to see if any value passed to it is one of the type names passed in as `typeNames`.  The return value will indicate if one of the type names matches the type of the value passed to it.  If `opt_negate` is `true` the return value of this function will be the opposite."
      },
      "requires": [
        "slice",
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isUndefined",
      "code": "",
      "description": "Determines if the given value is `undefined` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is `undefined` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is `undefined` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isUndefined(null), YourJS.isUndefined(undefined)].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isUnknown",
      "code": "",
      "description": "Determines if the given value is `Unknown` as specified by `typeOf()`.",
      "params": [
        {
          "name": "value",
          "description": "Value to see if it is `Unknown` according to `typeOf()`.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is `Unknown` according to `typeOf()`.  Otherwise `false`."
      },
      "requires": [
        "isArguments"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [YourJS.isUnknown({}), YourJS.isUnknown(new (function(){}))].join(','),\n  'false,true'\n);"
        }
      ]
    },
    {
      "name": "isUpperCase",
      "code": "",
      "description": "Determines if a string doesn't have lower cased characters.",
      "params": [
        {
          "name": "str",
          "description": "The value to be checked.",
          "type": "string"
        },
        {
          "name": "opt_allowNoCasing",
          "description": "If `true`, characters without casing found in `str` will be viewed as upper cased characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` only has cased characters that are upper cased or if `opt_allowNoCasing` is `true` and `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isMixCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isValidVarName",
      "code": "function isValidVarName(varName) {\n  try {\n    Function((varName + '').replace(/[\\{\\[\\s\\xA0,\\/\\.=]|^$/g, '!'), '');\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n}",
      "description": "Determines if a string can be used as a variable name in JavaScript.",
      "params": [
        {
          "name": "varName",
          "description": "The string to be tested to see if it is a valid variable name.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if the string value of `varName` is a valid variable name in JavaScript, otherwise `false`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isWhitespace",
      "code": "var isWhitespace = isRegExpMatch(/[\\t-\\r\\x1C- \\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u205F\\u3000]/);",
      "description": "Test for whitespace characters starting at the beginning of a string.",
      "params": [
        {
          "name": "str",
          "description": "The string to be tested.",
          "type": "string"
        },
        {
          "name": "opt_onlyCheckStart",
          "description": "If `true`, only the beginning of the string is checked to see if it starts with a whitespace character. If `false`, all of the string is checked to see if it only contains whitespace characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if `opt_onlyCheckStart` is `true`-ish and `str` starts with a whitespace character or `if opt_onlyCheckStart` is `false`-ish and `str` only contains whitespace characters. Otherwise `false` is returned."
      },
      "requires": [
        "isRegExpMatch"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "join",
      "code": "function join(arr, opt_delimiter, opt_beforeEach, opt_afterEach) {\n  opt_beforeEach = opt_beforeEach || '';\n  opt_afterEach = opt_afterEach || '';\n  return arr.length\n    ? opt_beforeEach + arr.join(\n        opt_afterEach\n        + (opt_delimiter != undefined ? opt_delimiter : ',')\n        + opt_beforeEach\n      ) + opt_afterEach\n    : '';\n}",
      "description": "Glues the values of an array together to form a string.",
      "params": [
        {
          "name": "arr",
          "description": "The array containing the values to be glued together.",
          "type": "Array"
        },
        {
          "name": "opt_delimiter",
          "description": "The string to delimit each value in `arr`.",
          "type": "string",
          "optional": true,
          "default": "\",\""
        },
        {
          "name": "opt_beforeEach",
          "description": "The string to prepend to each value in `arr`.",
          "type": "string",
          "optional": true,
          "default": "\"\""
        },
        {
          "name": "opt_afterEach",
          "description": "The string to append to each value in `arr`.",
          "type": "string",
          "optional": true,
          "default": "\"\""
        }
      ],
      "return": {
        "type": "string",
        "description": "A string representation of `arr` with all of the values prefixed by `opt_beforeEach`, suffixed by `opt_afterEach` and separated by `opt_delimiter`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "joinPath",
      "code": "function joinPath(arrPath) {\n  return arrPath.map(function (x) {\n    return (x + '').replace(/\\\\|\\./g, '\\\\$&');\n  }).join('.');\n}",
      "description": "Joins the values of an array to make a path string.",
      "params": [
        {
          "name": "arrPath",
          "description": "The array containing the path that should be converted to a string.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "string",
        "description": "The string version of `arrPath` where the path is joined by dots and where any dots in the path are escaped."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  YourJS.joinPath([1,2,'3.4',5]),\n  '1.2.3\\\\.4.5'\n)"
        }
      ]
    },
    {
      "name": "jsonp",
      "code": "function jsonp(url, callback, opt_callbackParamName) {\n  for (\n    var parent = __DOCUMENT.getElementsByTagName('head')[0] || __DOCUMENT.body,\n        script = __DOCUMENT.createElement('script'),\n        callbackName = '__jsonp';\n    has(__GLOBAL, callbackName = (callbackName + Math.random()).replace('.', ''));\n  );\n  __GLOBAL[callbackName] = function() {\n    delete __GLOBAL[callbackName];\n    callback.apply(this, arguments);\n  };\n  script.src = (url + '&'\n    + encodeURIComponent(opt_callbackParamName || 'callback')\n    + '=' + callbackName).replace(/(^[^\\?&]*)&/, '$1?');\n  script.type = 'text/JavaScript';\n  parent.appendChild(script);\n  return script;\n}",
      "description": "Adds a JSON-P script to the page to be executed once the script has been retrieved.",
      "params": [
        {
          "name": "url",
          "description": "URL of the JSON-P script without the callback parameter provided.",
          "type": "string"
        },
        {
          "name": "callback",
          "description": "Function to be called by the JSON-P script.",
          "type": "Function"
        },
        {
          "name": "opt_callbackParamName",
          "description": "Name of the parameter that will be passed the callback function's name.",
          "type": "string",
          "optional": true,
          "default": "\"callback\""
        }
      ],
      "return": {
        "type": "HTMLScriptElement",
        "description": "The script element that is added to the page."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "keepAspectRatio",
      "code": "function keepAspectRatio(width, height, targetWidth, targetHeight, opt_maximize) {\n  targetWidth = Math[opt_maximize ? 'max' : 'min'](targetHeight * width / height, targetWidth);\n  return { width: targetWidth, height: targetWidth * height / width };\n}\n",
      "description": "Maximizes the dimensions while keeping the same aspect ratio.",
      "params": [
        {
          "name": "width",
          "description": "The base width.",
          "type": "number"
        },
        {
          "name": "height",
          "description": "The base height.",
          "type": "number"
        },
        {
          "name": "tagetWidth",
          "description": "The target width.",
          "type": "number"
        },
        {
          "name": "targetHeight",
          "description": "The target height.",
          "type": "number"
        },
        {
          "name": "opt_maximize",
          "description": "If `false`-ish, the minimum dimensions will be found where at least one of the dimensions matches the corresponding target dimension. If `true`-ish, the maximum dimensions will be found where at least one of the dimensions matches the corresponding target dimension.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Object",
        "description": "Object containing the minimum or maximum calculated width and height while keeping the same aspect ratio provided.  Eg. `{ height: 400, width: 320 }`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "keys",
      "code": "function keys(value, opt_onlyNonEnums) {\n  var enumKeys = Object.keys(value = Object(value));\n  return opt_onlyNonEnums == undefined\n    ? enumKeys\n    : (value = Object.getOwnPropertyNames(value), opt_onlyNonEnums)\n      ? value.filter(function (key) { return indexOf(enumKeys, key) < 0; })\n      : value;\n}",
      "description": "Gets the keys of a specified value.",
      "params": [
        {
          "name": "value",
          "description": "Value for which you would like the property names retrieved.",
          "type": "*"
        },
        {
          "name": "opt_onlyNonEnums",
          "description": "If specified and is not `null` or `undefined` but is `false`-ish, all of the property names (enumerable or not) will be returned.  If this is `true`-ish only the non-enumerable property names will be returned.  If this is not given or is `null` or `undefined` all of the enumerable property names will be returned.",
          "type": "boolean",
          "optional": true,
          "default": ""
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of all of the keys of `arrOrObj`."
      },
      "requires": [
        "indexOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Array Test",
          "code": "var arr = [4,6];\narr[5] = 2;\ntest(JSON.stringify(YourJS.keys(arr)), '[\"0\",\"1\",\"5\"]');"
        },
        {
          "name": "Simple Object Test",
          "code": "function Person(name){this.name = name;}\nPerson.prototype.gender = 'Unknown';\ntest(JSON.stringify(YourJS.keys(new Person('Billie'))), '[\"name\"]');"
        }
      ]
    },
    {
      "name": "keysMatch",
      "code": "function keysMatch(obj1) {\n  for (var j, keys2, keys1 = Object.keys(Object(obj1)).sort(), args = arguments, i = args.length; --i; ) {\n    keys2 = Object.keys(Object(args[i])).sort();\n    j = keys1.length;\n    if (j !== keys2.length) {\n      return false;\n    }\n    while (j--) {\n      if (keys1[j] !== keys2[j]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}",
      "description": "Tests two or more objects to make sure they have the same keys.",
      "params": [
        {
          "name": "obj1",
          "description": "First object whose keys will be compared to the keys of the other objects passed in.",
          "type": "*"
        },
        {
          "name": "objX",
          "description": "The other objects whose keys will be compared to the keys of `obj1`.",
          "type": "*",
          "rest": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean value indicating whether or not the keys of the objects that were passed in matched each other."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "kindsOf",
      "code": "",
      "description": "Retrieves all of the associated type names for a value.",
      "params": [
        {
          "name": "value",
          "description": "Value for which to get all of the associated type names.",
          "type": "*"
        }
      ],
      "return": {
        "type": "Array<string>",
        "description": "An array of all of the types that `value` is."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "last",
      "code": "var last = nth(-1);",
      "description": "Gets the last element in an array or an array-like object.",
      "params": [
        {
          "name": "array",
          "description": "Array or array-like object from which to retrieve the last value.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "*",
        "description": "The last value in `array`."
      },
      "requires": [
        "nth"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "lcm",
      "code": "function lcm(int1, int2) {\n  return Math.abs(int1 * int2) / gcd(int1, int2);\n}",
      "description": "Finds the smallest integer that is evenly divisible by the two specified integers.",
      "params": [
        {
          "name": "int1",
          "description": "The first of two integers that will be evenly divisible by the returned least common multiple.",
          "type": "number"
        },
        {
          "name": "int2",
          "description": "The second of two integers that will be evenly divisible by the returned least common multiple.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The smallest integer that is evenly divisible by `int1` and `int2`."
      },
      "requires": [
        "gcd"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.lcm(2*5*7, 4*5*9*13), 4*5*7*9*13);"
        }
      ]
    },
    {
      "name": "limit",
      "code": "function limit(fn, opt_callLimit, opt_errorMessage) {\n  if (opt_callLimit == undefined) {\n    opt_callLimit = 1;\n  }\n  return function() {\n    if (opt_callLimit-- > 0) {\n      return fn.apply(this, arguments);\n    }\n    else if (opt_errorMessage) {\n      throw new Error(opt_errorMessage);\n    }\n  };\n}",
      "description": "Creates a wrapper function which when called will call the given function, but only a maximum amount of times as specified.",
      "params": [
        {
          "name": "fn",
          "description": "The function which will only be called a limited amount of times.",
          "type": "Function"
        },
        {
          "name": "opt_callLimit",
          "description": "The maximum amount of times the returned wrapper function can be called.",
          "type": "number",
          "optional": true,
          "default": "1"
        },
        {
          "name": "opt_errorMessage",
          "description": "If given, once the call limit is reached every subsequent call to the returned wrapper function will throw an error with this message.  If not given no error will be thrown.",
          "type": "string"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function that is limited in the amount of times it will call `fn`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "log",
      "code": "var log;\n(function(CACHE_LOG_INVERSE_BASE) {\n  log = function(x, opt_base) {\n    opt_base = opt_base || Math.E;\n    return Math.log(x)\n      * (\n        CACHE_LOG_INVERSE_BASE[opt_base] = CACHE_LOG_INVERSE_BASE.hasOwnProperty(opt_base)\n          ? CACHE_LOG_INVERSE_BASE[opt_base]\n          : (5 / Math.log(Math.pow(opt_base, 5)))\n      );\n  };\n})({});",
      "description": "Gets the logarithm of any number in the specified base.  NOTE:  this function works best for values that don't rely on a base of `Math.E`.  If you want to find natural log it would be best to simply use `Math.log()`.",
      "params": [
        {
          "name": "x",
          "description": "The number for which the logarithm will be calculated.",
          "type": "number"
        },
        {
          "name": "base",
          "description": "The base of the calculated logarithm.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The logarithm of `x` for the specified `base`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.log(1000, 10), 3);"
        }
      ]
    },
    {
      "name": "log10",
      "code": "",
      "description": "Gets the base 10 logarithm of a number.",
      "params": [
        {
          "name": "x",
          "description": "A number.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The base 2 logarithm of the given number. If the number is negative, `NaN` is returned."
      },
      "requires": [
        "log2"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.log10(2), 0.3010299956639812);"
        }
      ]
    },
    {
      "name": "log2",
      "code": "// Math.log2() and Math.log10() don't exist in IE.\neval('102'.replace(/..?/g, 'function log$&(x){return Math.log(x)*Math.LOG$&E}'));",
      "description": "Gets the base 2 logarithm of a number.",
      "params": [
        {
          "name": "x",
          "description": "A number.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The base 2 logarithm of the given number. If the number is negative, `NaN` is returned."
      },
      "requires": [
        "log10"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.log2(3), 1.584962500721156);"
        }
      ]
    },
    {
      "name": "loop",
      "code": "function loop(array, opt_reverse) {\n  var first = array[opt_reverse ? 'pop' : 'shift']();\n  if (array.length) {\n    array[opt_reverse ? 'unshift' : 'push'](first);\n  }\n  return first;\n}",
      "description": "Progressively loops the values within an array on each iteration while at the same time retrieving one of the end values of the specified array.",
      "params": [
        {
          "name": "array",
          "description": "Array from which to pull the value which will also be modified because the value will then be placed on the opposite end.",
          "type": "Array"
        },
        {
          "name": "opt_reverse",
          "description": "Boolean indicating that instead of retrieving the first value, the last value should be retrieved and then placed at the beginning of `array`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `opt_reverse` is `true`-ish the last value in `array` will be returned and also placed at the beginning of `array`.  Otherwise the first value in `array` will be returned and also placed at the end of `array`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "lowerCase",
      "code": "eval('LlowUupp'.replace(/(.)(.(..))/g, 'function $2erCase(s){return(arguments.length?s+\"\":\"\").to$1$3erCase()}'));",
      "description": "Takes a value that will then be lower-cased.",
      "params": [
        {
          "name": "value",
          "description": "The string or value to be lower-cased.",
          "type": "string|*"
        }
      ],
      "return": {
        "type": "string",
        "description": "`value` coerced to a string with all of the characters lower-cased."
      },
      "requires": [
        "upperCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "lowerFirst",
      "code": "// Generates lowerFirst(), lowerRest(), upperFirst(), and upperRest()\neval(\"function st(s){return s.slice(0,1)erCase()\".replace(/(\\w+ )(.{13}(.{8})....)(.+)/g,\"$1lowerFir$2.toLow$4+$31);}$1lowerRe$2+$31).toLow$4;}$1upperFir$2.toUpp$4+$31);}$1upperRe$2+$31).toUpp$4}\"));",
      "description": "Lower-cases the first character of a string.",
      "params": [
        {
          "name": "string",
          "description": "String that should be returned with the first character lower-cased.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "`string` with the first character lower-cased and any remaining characters kept as is."
      },
      "requires": [
        "lowerRest",
        "upperFirst",
        "upperRest"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "lowerRest",
      "code": "",
      "description": "Lower-cases all characters after the first one.",
      "params": [
        {
          "name": "string",
          "description": "String that should be returned making sure that all characters after the first are lower-cased.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "`string` with the first character as is followed by all the rest lower-cased."
      },
      "requires": [
        "lowerFirst"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "lt",
      "code": "// Generates xorBits, orBits, andBits, add, subtract, multiply, divide, rem, lt, gt, eq, ne, lte, gte, eqs and nes\neval('xorBits^orBits|andBits&add+subtract-multiply*divide/rem%lt<gt>eq==ne!=lte<=gte>=eqs===nes!=='.replace(/(\\w+)(\\W+)/g, 'function $1(a,b){return arguments.length-1?a$2b:function(b){return b$2a}}'));",
      "description": "Determines if one value is less than another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is greater than `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is less than `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is less than `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is less than `value1`."
      },
      "requires": [
        "gt",
        "eq",
        "ne",
        "lte",
        "gte",
        "eqs",
        "nes",
        "xorBits",
        "orBits",
        "andBits",
        "add",
        "subtract",
        "multiply",
        "divide",
        "rem"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "lte",
      "code": "",
      "description": "Determines if one value is less than or equal to another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is greater than or equal to `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is less than or equal to `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is less than or equal to `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is less than or equal to `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "map",
      "code": "/*\n// Original code for map(), mapKeys() and mapPairs():\nfunction map(obj, fn, opt_thisObj) {\n  for (\n    var k, isArray = isArrayLike(obj), result = isArray ? [] : {}, arrKeys = Object.keys(obj), i = 0, l = arrKeys.length;\n    i < l;\n  ) {\n    k = arrKeys[i++];\n    result[k] = fn.call(opt_thisObj, obj[k], isArray ? +k : k, obj);\n  }\n  return result;\n}\nfunction mapKeys(obj, fn, opt_thisObj) {\n  for (\n    var k, isArray = isArrayLike(obj), result = isArray ? [] : {}, arrKeys = Object.keys(obj), i = 0, l = arrKeys.length;\n    i < l;\n  ) {\n    k = arrKeys[i++];\n    result[fn.call(opt_thisObj, obj[k], isArray ? +k : k, obj)] = obj[k];\n  }\n  return result;\n}\nfunction mapPairs(obj, fn, opt_thisObj) {\n  for (\n    var r, k, isArray = isArrayLike(obj), result = isArray ? [] : {}, arrKeys = Object.keys(obj), i = 0, l = arrKeys.length;\n    i < l;\n  ) {\n    k = arrKeys[i++];\n    if (r = fn.call(opt_thisObj, obj[k], isArray ? +k : k, obj)) {\n      result[r[0]] = r[1];\n    }\n  }\n  return result;\n}\n*/\nvar mapPairs, mapKeys, map = Function('I', \"return[@a=e[f++],d[a]=#;return d},@a=e[f++],d[#]=b[a];return d},@if(a=e[f++],a=#)d[a[0]]=a[1];return d}]\".replace(/@/g,\"function(b,g,h){for(var a,c=I(b),d=c?[]:{},e=Object.keys(b),f=0,k=e.length;f<k;)\").replace(/#/g,\"g.call(h,b[a],c?+a:a,b)\"))(isArrayLike);\nmapPairs = map[2];\nmapKeys = map[1];\nmap = map[0];",
      "description": "Creates a new array or object with the results of calling a provided function on every item or property in the given object.",
      "params": [
        {
          "name": "objectOrArray",
          "description": "The array, array-like structure or object whose items or properties will be traversed by `callback`.",
          "type": "Array|Object"
        },
        {
          "name": "callback",
          "description": "Function that produces a replacement item or property for each corresponding one `objectOrArray`.  The first argument passed will be current value of the item or property.  The second argument will be the index or property name.  The third argument will be a reference to `objectOrArray`.  The return value will be used to replace each item or property.",
          "type": "Function"
        },
        {
          "name": "opt_thisArg",
          "description": "Value to use as this when executing `callback`.",
          "type": "*",
          "optional": true,
          "default": "global"
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "If `objectOrArray` is an array-like structure then a new array with the modified contents will be returned.  Otherwise a new object with the modified contents will be returned."
      },
      "requires": [
        "isArrayLike",
        "mapKeys",
        "mapPairs"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Array",
          "code": "var result = YourJS.map([-2,-1,0,1,2,3,4,5,6,7], (v, i, a) => `${i}: ${i+v*v-a.length}`);\nvar expected = [-2,-1,0,1,2,3,4,5,6,7].map((v, i, a) => `${i}: ${i+v*v-a.length}`);\ntest(result+'', expected+'');"
        },
        {
          "name": "Simple Object",
          "code": "var obj = {a:1,b:2,c:3};\nvar f = (v, k, o) => [v,k,k+v,o[k]];\nvar s = (a,b)=>a[0]<b[0]?-1:1;\nvar result = Object.entries(YourJS.map(obj, f)).sort(s);\nvar expected = Object.entries(obj).map(([k,v])=>[k,f(v,k,obj)]).sort(s);\ntest(JSON.stringify(result), JSON.stringify(expected));"
        }
      ]
    },
    {
      "name": "mapKeys",
      "code": "",
      "description": "Creates a new array or object corresponding to the array-like structure or object supplied where the keys to the new array or object are determined by a callback function.",
      "params": [
        {
          "name": "objectOrArray",
          "description": "The array, array-like structure or object whose items or properties will be traversed by `callback`.",
          "type": "Array|Object"
        },
        {
          "name": "callback",
          "description": "Function that produces replacement keys for each key of `objectOrArray`.  The first argument passed will be current value of the item or property.  The second argument will be the index or property name.  The third argument will be a reference to `objectOrArray`.  The return value will be used as the corresponding key to be set in the array or object returned by `mapKeys()`.",
          "type": "Function"
        },
        {
          "name": "opt_thisArg",
          "description": "Value to use as this when executing `callback`.",
          "type": "*",
          "optional": true,
          "default": "global"
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "If `objectOrArray` is an array-like structure then a new array with the modified keys will be returned.  Otherwise a new object with the modified keys will be returned."
      },
      "requires": [
        "map"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple - Array",
          "code": "var arr = [5,6,7,8,9];\nvar result = YourJS.mapKeys(arr, (v, k) => v + k);\nvar expected = arr.reduce((carry, v, k) => {\n  carry[v + k] = v;\n  return carry;\n}, []);\ntest(result + '', expected + '');"
        }
      ]
    },
    {
      "name": "mapPairs",
      "code": "",
      "description": "Creates a new array or object corresponding to the array-like structure or object supplied where the keys and values to the new array or object are determined by a callback function.",
      "params": [
        {
          "name": "objectOrArray",
          "description": "The array, array-like structure or object whose items or properties will be traversed by `callback`.",
          "type": "Array|Object"
        },
        {
          "name": "callback",
          "description": "Function that produces a key and value pair that will be used to define each item or property in the structure (`Array` or `Object`) corresponding to `objectOrArray`.  The first argument passed will be current value of the item or property.  The second argument will be the index or property name.  The third argument will be a reference to `objectOrArray`.  If the return value is `false`-ish the property or item will not be added to the object returned by `mapPairs()`.  Otherwise the return value should be an array where the first value is the key and the second value is the value of the item or property that should be added to the object returned by `mapPairs()`.",
          "type": "Function"
        },
        {
          "name": "opt_thisArg",
          "description": "Value to use as this when executing `callback`.",
          "type": "*",
          "optional": true,
          "default": "global"
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "If `objectOrArray` is an array-like structure then a new array with the modified keys and values will be returned.  Otherwise a new object with the keys and values will be returned."
      },
      "requires": [
        "map"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple - Object",
          "code": "var obj = { first: 'Chris', last: 'West' };\nvar result = YourJS.mapPairs(obj, (v, k) => [k + 'Name', v + 'ly']);\ntest(\n  result.firstName + ' ' + result.lastName + ' ' + result.first + ' ' + obj.lastName,\n  obj.first + 'ly ' + obj.last + 'ly ' + 'undefined undefined'\n);"
        }
      ]
    },
    {
      "name": "matchAll",
      "code": "eval('exec:a,fmatch:f,a'.replace(/(\\w+):(.,.)/g, 'function $1All($2,d){a=new RegExp(a.source,(a.flags||(a+\"\").replace(/[^]+\\\\//,\"\")).replace(\"g\",\"\")+\"g\");for(var b,g=0,c=[],e=0;b=a.exec(f);e===a.lastIndex&&++a.lastIndex,e=a.lastIndex)d&&(b=d(b,++g)),void 0!==b&&c.push(b);return c.length?c:null}'));",
      "description": "Gets all of the matches found when matching a regular expression against a string.",
      "params": [
        {
          "name": "str",
          "description": "String against which the regular expression should be matched.",
          "type": "string"
        },
        {
          "name": "rgx",
          "description": "Regular expression to match against `str`.",
          "type": "RegExp"
        },
        {
          "name": "opt_fnMapper",
          "description": "If specified the return value of this function will always be appended to the array which will be returned by `matchAll()` unless `undefined` is the return value.  The 1st argument passed will be an array representing the matches array that was found.  The 2nd argument passed will be the amount of times this mapper has been called.",
          "type": "function(Array,number)",
          "optional": true
        }
      ],
      "return": {
        "type": "Array|null",
        "description": "If `rgx` matched a substring in `str` at least once and `opt_fnMapper` wasn't used, an array of all of the matches will be returned. Each match will at least have `match[0]`, `match.index` (the starting index of the found match within `str`), `match.source` (`rgx`) and `match.input` (`str`). If capture groups were specified in `rgx`, each will be found in its corresponding index starting with `match[1]`. If no matches were found, `null` is returned."
      },
      "requires": [
        "execAll"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Test",
          "code": "var result = YourJS.matchAll('Hello world!', /([a-z])(\\w+)/i);\ntest(\n  JSON.stringify([result[0][1], result[0][2], result[1][1], result[1][2], result.length]),\n  '[\"H\",\"ello\",\"w\",\"orld\",2]'\n);"
        }
      ]
    },
    {
      "name": "max",
      "code": "",
      "description": "Get the (first) maximum value in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the maximum value that should be found.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "*",
        "description": "The (first) maximum value within `array`."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "maxBy",
      "code": "",
      "description": "Get the (first) maximum value in an array determined by `valuer`.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the maximum value that should be found.",
          "type": "Array"
        },
        {
          "name": "valuer",
          "description": "If this is a function it will be passed each item in `array` and the corresponding values will be used to rank the items.  In all other cases this will be used as a path within each item in `array` whose property at that path will be used to rank the item.",
          "type": "Function|Array|number|string"
        }
      ],
      "return": {
        "type": "*",
        "description": "The (first) maximum value within `array`."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "maxIndex",
      "code": "",
      "description": "Get the index of the (first) maximum value in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the maximum value that should be found and for which the corresponding index should be returned.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "number",
        "description": "The index of the (first) maximum value within `array`.  If `array` is empty `-1` will be returned."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "maxIndexBy",
      "code": "",
      "description": "Get the index of the (first) maximum value in an array determined by `valuer`.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the maximum value that should be found and for which the corresponding index should be returned.",
          "type": "Array"
        },
        {
          "name": "valuer",
          "description": "If this is a function it will be passed each item in `array` and the corresponding values will be used to rank the items.  In all other cases this will be used as a path within each item in `array` whose property at that path will be used to rank the item.",
          "type": "Function|Array|number|string"
        }
      ],
      "return": {
        "type": "number",
        "description": "The index of the (first) maximum value within `array`.  If `array` is empty `-1` will be returned."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "min",
      "code": "",
      "description": "Get the (first) minimum value in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum value that should be found.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "*",
        "description": "The (first) minimum value within `array`."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minBy",
      "code": "",
      "description": "Get the (first) minimum value in an array determined by `valuer`.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum value that should be found.",
          "type": "Array"
        },
        {
          "name": "valuer",
          "description": "If this is a function it will be passed each item in `array` and the corresponding values will be used to rank the items.  In all other cases this will be used as a path within each item in `array` whose property at that path will be used to rank the item.",
          "type": "Function|Array|number|string"
        }
      ],
      "return": {
        "type": "*",
        "description": "The (first) minimum value within `array`."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minIndex",
      "code": "// requires getAt()\n// Generates minIndex, minIndexBy, min, minBy, maxIndex, maxIndexBy, max, maxBy, minMax, minMaxBy, minMaxIndex and minMaxIndexBy\neval(\n  \"minIndex t.min!min a[t.min]!maxIndex t.max!max a[t.max]!minMax{min:a[t.min],max:a[t.max]}!\".replace(\n    /(\\w+)([^!]+)!/g,\n    \" By,i\".replace(\n      /\\W|(..)(..)/g,\n      \"@ $$1$1(a$2){var t=#$1(a$2);return$$2}\"\n    )\n  ).replace(\n    /.+/,\n    '$&var #,#By;#=@(G){#=@(h){for(var a,c,e,f,g,b=0,k=h.length;b<k;b++)a=h[b],b?a<c?(c=a,e=b):a>f&&(f=a,g=b):(c=f=a,e=g=b);return{min:e%,max:g%}};#By=@(h,a){var t=typeof a;a=\"string\"===t||\"number\"===t?[a]:a;for(var c,e,f,g,b,k=\"@\"===t,d=0,l=h.length;d<l;d++)c=k?a(h[d]):G(h[d],a),d?c<e?(e=c,f=d):c>g&&(g=c,b=d):(e=g=c,f=b=d);return{min:f%,max:b%}}}'\n  ).replace(/#/g, 'minMaxIndex').replace(/@/g, 'function').replace(/(.)%/g, '$1===undefined?-1:$1')\n)(getAt)",
      "description": "Get the index of the (first) minimum value in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum value that should be found and for which the corresponding index should be returned.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "number",
        "description": "The index of the (first) minimum value within `array`.  If `array` is empty `-1` will be returned."
      },
      "requires": [
        "getAt",
        "min",
        "minBy",
        "minIndexBy",
        "minMax",
        "minMaxBy",
        "minMaxIndex",
        "minMaxIndexBy",
        "maxIndex",
        "maxIndexBy",
        "max",
        "maxBy"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minIndexBy",
      "code": "",
      "description": "Get the index of the (first) minimum value in an array determined by `valuer`.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum value that should be found and for which the corresponding index should be returned.",
          "type": "Array"
        },
        {
          "name": "valuer",
          "description": "If this is a function it will be passed each item in `array` and the corresponding values will be used to rank the items.  In all other cases this will be used as a path within each item in `array` whose property at that path will be used to rank the item.",
          "type": "Function|Array|number|string"
        }
      ],
      "return": {
        "type": "number",
        "description": "The index of the (first) minimum value within `array`.  If `array` is empty `-1` will be returned."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minMax",
      "code": "",
      "description": "Get the (first) minimum value and the (first) maximum value in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum value and the maximum value that should be found.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "*",
        "description": "An object containing a `min` property which will be the (first) minimum value in `array`.  The object will also contain a `max` property which will be the (first) maximum value in `array`.  If `array` is empty `undefined` will be the value of the `min` and `max` properties."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minMaxBy",
      "code": "",
      "description": "Get the (first) maximum value in an array determined by `valuer`.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum and maximum values that should be found.",
          "type": "Array"
        },
        {
          "name": "valuer",
          "description": "If this is a function it will be passed each item in `array` and the corresponding values will be used to rank the items.  In all other cases this will be used as a path within each item in `array` whose property at that path will be used to rank the item.",
          "type": "Function|Array|number|string"
        }
      ],
      "return": {
        "type": "*",
        "description": "An object containing a `min` property which will be the (first) minimum value in `array`.  The object will also contain a `max` property which will be the (first) maximum value in `array`.  If `array` is empty `undefined` will be the value of the `min` and `max` properties."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minMaxIndex",
      "code": "",
      "description": "Get the index of the (first) minimum value and the index of the (first) maximum value in an array.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum and maximum values that should be found and for which the corresponding indices should be returned.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Object",
        "description": "An object containing a `min` property which will be the index of the (first) minimum value in `array`.  The object will also contain a `max` property which will be the index of the (first) maximum value in `array`.  If `array` is empty `-1` will be the value of the indices."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "minMaxIndexBy",
      "code": "",
      "description": "Get the index of the (first) minimum value and the index of the (first) maximum value in an array determined by `valuer`.",
      "params": [
        {
          "name": "array",
          "description": "Array which contains the minimum and maximum values that should be found and for which the corresponding indices should be returned.",
          "type": "Array"
        },
        {
          "name": "valuer",
          "description": "If this is a function it will be passed each item in `array` and the corresponding values will be used to rank the items.  In all other cases this will be used as a path within each item in `array` whose property at that path will be used to rank the item.",
          "type": "Function|Array|number|string"
        }
      ],
      "return": {
        "type": "Object",
        "description": "An object containing a `min` property which will be the index of the (first) minimum value in `array`.  The object will also contain a `max` property which will be the index of the (first) maximum value in `array`.  If `array` is empty `-1` will be the value of the indices."
      },
      "requires": [
        "minIndex"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "mixin",
      "code": "",
      "description": "Adds a new function to the YourJS object and to `YourJSChain`'s prototype.",
      "params": [
        {
          "name": "fn",
          "description": "The function to add to the YourJS object.",
          "type": "Function"
        },
        {
          "name": "name",
          "description": "The name to give to the function under the YourJS object and under the `YourJSChain`'s prototype.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean value indicating if the function could be added."
      },
      "requires": [
        "chain"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "mod",
      "code": "function mod(dividend, divisor) {\n  return (dividend % divisor + divisor) % divisor;\n}",
      "description": "Get the remainder after dividing 2 numbers while making sure the remainder is always between 0 and the divisor..",
      "params": [
        {
          "name": "dividend",
          "description": "Number to be divided.",
          "type": "number"
        },
        {
          "name": "divisor",
          "description": "Number to divide by.",
          "type": "number"
        }
      ],
      "return": {
        "description": "Remainder after dividing the dividend by the divisor.",
        "type": "number"
      },
      "tests": [
        {
          "name": "Basic Integer",
          "code": "test(YourJS.mod(5, 3), 5 % 3)"
        },
        {
          "name": "Negative Integer",
          "code": "test(YourJS.mod(-6, 5), 4)"
        }
      ],
      "requires": [],
      "required": false
    },
    {
      "name": "modDate",
      "code": "var modDate;\n(function (MAP) {\n  modDate = function (date, options) {\n    if (options.clone) {\n      date = new Date(date);\n    }\n    for (var setter, getter, isSetOnly, k, v, keys = Object.keys(options), i = keys.length; i--;) {\n      v = options[k = keys[i]];\n      isSetOnly = /^\\$/.test(k);\n      k.replace(/^\\$|\\b(ms)$|s$/g, '$1')\n        .replace(/^((milli)?sec(ond)?|min(ute)?|hour)$/, '$&s')\n        .replace(/./, function (a) { return a.toUpperCase(); })\n        .replace(/^(DOW|dow)([0-6])?$|^.+$/i, function (k, dow, offset) {\n          if (dow) {\n            dow = (date.getDay() + -(offset || 0) + 7) % 7;\n            v = ((v % 7) + 7) % 7;\n            date.setDate(date.getDate() + (isSetOnly ? v - dow : ((dow + v) % 7 - dow)));\n          }\n          else {\n            k = MAP[k] || k;\n            if ('function' === typeof date[setter = 'set' + k] && 'function' === typeof date[getter = 'get' + k]) {\n              date[setter](!isSetOnly ? date[getter]() + v : v);\n            }\n          }\n        });\n    }\n    return date;\n  };\n})({ Ms: 'Milliseconds', Day: 'Date', Year: 'FullYear', Secs: 'Seconds', Mins: 'Minutes' });",
      "description": "Modifies a `Date` object with either offsets or specific times.",
      "params": [
        {
          "name": "date",
          "description": "The date to be modified.",
          "type": "Date"
        },
        {
          "name": "objOptions",
          "description": "The object which specifies how to modify `date`.  The properties will be read and used to modify `date` (or a copy of `date` if `objOptions` is `true`-ish).  For example to offset the year by 2 years into the future you can specify `{ year: 2 }`.  To actually set a specific unit of time you can prefix the name of the property with `$`.  For example if this is `{ $day: 3, $month: 6 }` then the month will be set to July (because the month property of a `Date` object is zero-based) and the day of the month will be set to `3`.  Valid properties are `year` (or `fullYear`), `month`, `day` (or `date`), `hour`, `minute` (or `min`), `second` (or `sec`), or `millisecond` (or `ms`).  You can also use the plural form of those property names.  Another set of properties is `dow` or `dow0` (Sunday to Saturday), `dow1` (Monday to Sunday), `dow2` (Tuesday to Monday), `dow3` (Wednesday to Tuesday), `dow4` (Thursday to Wednesday), `dow5` (Friday to Thursday) and `dow6` (Saturday to Friday), all of which allow for setting the day of the week.  Additionally you can prefix those names with a `$` to actually set the value instead of simply offsetting those values.",
          "type": "Object",
          "optional": false
        }
      ],
      "return": {
        "type": "Date",
        "description": "If `objOptions.clone` is `true`-ish then a copy of `date` will be modified and returned.  Otherwise the same `date` that was passed will be modified and returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Set Year",
          "code": "var d1 = new Date;\nvar d2 = new Date(+d1);\nd1.setFullYear(2005);\nYourJS.modDate(d2, { $year: 2005 });\ntest(d1+ +d1, d2 + +d2);"
        },
        {
          "name": "Offset Year",
          "code": "var d1 = new Date;\nvar d2 = new Date(+d1);\nd1.setFullYear(d1.getFullYear() + 5);\nYourJS.modDate(d2, { year: 5 });\ntest(d1+ +d1, d2 + +d2);"
        },
        {
          "name": "Offset Milliseconds",
          "code": "var d1 = new Date;\nvar d2 = new Date(+d1);\nd1.setMilliseconds(d1.getMilliseconds() - 12345);\nYourJS.modDate(d2, { ms: -12345 });\ntest(d1+ +d1, d2 + +d2);"
        },
        {
          "name": "Offset Milliseconds #2",
          "code": "var d1 = new Date;\nvar d2 = new Date(+d1);\nd1.setMilliseconds(d1.getMilliseconds() - 54321);\nYourJS.modDate(d2, { milliseconds: -54321 });\ntest(d1+ +d1, d2 + +d2);"
        },
        {
          "name": "Offset day of the week",
          "code": "var d1 = new Date;\nvar d2 = new Date(d1);\nYourJS.modDate(d1, { dow: 6 });\nvar dow = d2.getDay();\nd2.setDate(d2.getDate() - dow + (dow + 6) % 7);\ntest(d1+ +d1, d2 + +d2);"
        }
      ]
    },
    {
      "name": "modEach",
      "code": "function modEach(obj, fn, opt_mapReturns) {\n  forOf(obj, function(v, k, obj) {\n    v = fn(v, k, obj);\n    if (opt_mapReturns) {\n      obj[k] = v;\n    }\n  });\n  return obj;\n}",
      "description": "Takes an array or an object and traverses all of its key/value pairs allowing for modifications while in the end returning a reference to that same array or object.",
      "params": [
        {
          "name": "obj",
          "description": "Array or object that will be traversed.",
          "type": "Array|Object"
        },
        {
          "name": "fn",
          "description": "Function that can make changes for each value within `obj`.  For each value within `obj` this function will be called with (1) the value, (2) the key and (3) a reference to `obj`.",
          "type": "Function"
        },
        {
          "name": "opt_mapReturns",
          "description": "Indicates whether or no the return value from `fn` should be assigned to that corresponding key for `obj`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Array|Object",
        "description": "A reference to `obj`."
      },
      "requires": [
        "forOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "modRegExp",
      "code": "function modRegExp(rgx, modifiers) {\n  var flags = (rgx + '').replace(/[\\s\\S]+\\//, '');\n  modifiers.replace(/([-+!]?)(\\w)/g, function(index, op, flag) {\n    index = flags.indexOf(flag)\n    flags = op == '-' || (op == '!' && index >= 0)\n      ? flags.replace(flag, '')\n      : index < 0\n        ? flags + flag\n        : flags;\n  });\n  return new RegExp(rgx.source, flags);\n}\n",
      "description": "Creates a new copy of a regular expression with modified flags.",
      "params": [
        {
          "name": "rgx",
          "description": "The regular expression to be duplicated with modified flags.",
          "type": "RegExp"
        },
        {
          "name": "modifiers",
          "description": "Specifies how to modify the flags of the duplicate of `rgx`. The standard flags are of course `g` for global, `i` for ignoreCase and `m` for multiline. In some environments other flags are also available. In order to assure that the duplicate will have specified flag you can just add the flag character (optionally you can prefix it with a `+`) to the string. In order to assure that the duplicate will exclude a specified flag you can enter - followed by the flag character in this string. In order to toggle the flag in the duplicate you can prefix the flag character with !. For example `\"g-i!m\"` (which is the same as `\"+g-i!m\"`) will ensure the `g` flag is included, ensure the `i` flag is excluded and toggle `m`.",
          "type": "string",
          "optional": true
        }
      ],
      "return": {
        "type": "RegExp",
        "description": "Returns a duplicate of `rgx` with modified flags as specified by the `modifiers` string."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "modURL",
      "code": "function modURL(opt_url, options) {\n  var URL = __GLOBAL.URL;\n  var url = opt_url || __GLOBAL.location.href;\n  try {\n    url = new URL(url);\n  }\n  catch (a) {\n    a = __DOCUMENT.createElement('a');\n    a.href = url;\n    url = new URL(a.href);\n  }\n  // Loop through input options...\n  for (var optionKey in options) {\n    if (has(options, optionKey)) {\n      var optionValue = options[optionKey];  // input option\n      if (optionKey === 'search') {\n        var hasSearchFunc = 'function' === typeof optionValue;\n        if (hasSearchFunc) {\n          optionValue = optionValue(parseQS(url[optionKey]));\n        }\n        if ('object' === typeof optionValue) {\n          var urlSearch = parseQS(url[optionKey]), arrNewSearch = [];\n          // If options.search was not a function then loop through the search\n          // params of the URL to be modified and only keep the ones that are\n          // not specified to be changed via options.search.\n          if (!hasSearchFunc) {\n            for (var qsKey in urlSearch) {\n              if (has(urlSearch, qsKey) && !has(optionValue, qsKey)) {\n                arrNewSearch.push([qsKey, urlSearch[qsKey]]);\n              }\n            }\n          }\n          // Loop through the search params that are to be added or modified and\n          // add any that are not specified as null or undefined\n          for (var searchKey in optionValue) {\n            if (has(optionValue, searchKey)) {\n              var searchValue = optionValue[searchKey];\n              var newSearchValue = 'function' === typeof searchValue ? searchValue(urlSearch[searchKey], urlSearch) : searchValue;\n              if (newSearchValue != undefined) {\n                (nativeType(newSearchValue) === 'Array' ? newSearchValue : [newSearchValue]).forEach(function(searchValue) {\n                  arrNewSearch.push([searchKey, searchValue]);\n                });\n              }\n            }\n          }\n          optionValue = arrNewSearch.reduce(function(search, pair) {\n            return search + (search ? '&' : '?') + escape(pair[0]) + '=' + escape(pair[1]);\n          }, '');\n        }\n      }\n      url[optionKey] = 'function' === typeof optionValue ? optionValue(url[optionKey]) : optionValue;\n    }\n  }\n  return url.href;\n}",
      "description": "Modify a URL.",
      "params": [
        {
          "name": "opt_url",
          "description": "URL to modify and return.  If `undefined` or `null` is specified this will default to the page's location.",
          "type": "string",
          "optional": true,
          "default": "location.href"
        },
        {
          "name": "options",
          "description": "An object indicating how to modify `opt_url`.  Each property name should correspond to a valid `URL` property name.  If a function is given as a property name it will be executed and the return value will be used as that property of the URL.  Specifying a function for the `\"search\"` property will cause the function to be called with an object representing the current search parameters and the return result will be used to indicate what the new search parameters will be.  Specifying an object for the `\"search\"` property will provide the ability to set individual search parameters with values or callback functions.  If `options.search` is an object and has any properties set to `undefined` or `null` this will indicate that those properties should be removed, but any search parameters that are not defined as properties of `options.search` will remain.",
          "type": "Object"
        }
      ],
      "return": {
        "type": "string",
        "description": "The modified form of `opt_url`."
      },
      "requires": [
        "has",
        "escape",
        "parseQS",
        "nativeType"
      ],
      "required": false,
      "tests": [
        {
          "name": "Add a search param with a function",
          "code": "var url = 'https://example.com/path/to/file?a=1&b=2';\nvar expected = 'https://example.com/path/to/file?a=2&b=3&c=5';\nvar result = YourJS.modURL(url, {\n  search: function(input) {\n    input.c = (input.a = +input.a + 1) + (input.b = +input.b + 1);\n    return input;\n  }\n});\ntest(result, expected);"
        },
        {
          "name": "Change search params with a function",
          "code": "var url = 'https://example.com/path/to/file?a=3&b=4';\nvar expected = 'https://example.com/path/to/file?c=7';\nvar result = YourJS.modURL(url, {\n  search: function(input) {\n    return { c: +input.a + +input.b };\n  }\n});\ntest(result, expected);"
        }
      ]
    },
    {
      "name": "multiply",
      "code": "",
      "description": "Finds the product of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be multiplied by `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to be multiplied by `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given the product of the two will be returned.  Otherwise a partial function will be returned which when called will accept one number and will return the number passed to the partial function multiplied by `number1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "multOf",
      "code": "function multOf(factor, target, opt_roundOut) {\n  return Math[(target < 0 || 1 / target < 0) === !opt_roundOut ? 'ceil' : 'floor'](target / factor) * factor;\n}",
      "description": "Gets a multiple of a number that approximates another number.",
      "params": [
        {
          "name": "factor",
          "description": "The number to get a multiple of.",
          "type": "number"
        },
        {
          "name": "target",
          "description": "The number that the multiple of should approximate.",
          "type": "number"
        },
        {
          "name": "opt_roundOut",
          "description": "If `true`-ish the return value will be at least the same as `target` or further away from `0` than `target`, otherwise it will be `target` or closer to `0` than `target`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "A multiple of `factor` that approximates `target`.  If `opt_roundOut` is `true`-ish this will be a value that is either `target` or a little further away from `0` than `target`.  If `opt_roundOut` is `false`-ish this will be a value that is either `target` or a little closer to `0` than `target`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "nativeType",
      "code": "function nativeType(x) {\n  return __EMPTY_OBJECT.toString.call(x).slice(8, -1);\n}",
      "description": "Gets the native type name of a primitive or an object.  Unlike YourJS.typeOf(), the types are solely determined by the system.",
      "params": [
        {
          "name": "value",
          "description": "Primitive or object whose native type name will be returned.",
          "type": "*"
        }
      ],
      "return": {
        "type": "string",
        "description": "The native type name of the specified value.  All type names start with an uppercase character."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Test basics",
          "code": "test(\n  JSON.stringify([5, NaN, true, null, undefined, 'cool', {}, [], new function(){}, /z/].map(YourJS.nativeType)),\n  '[\"Number\",\"Number\",\"Boolean\",\"Null\",\"Undefined\",\"String\",\"Object\",\"Array\",\"Object\",\"RegExp\"]'\n);"
        }
      ]
    },
    {
      "name": "ne",
      "code": "",
      "description": "Determines if one value is not equal to (`!=`) another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is not equal to (`!=`) `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is not equal to (`!=`) `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is not equal to (`!=`) `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is not equal to (`!=`) `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "nes",
      "code": "",
      "description": "Determines if one value is strictly not equal to (`!==`) another value.",
      "params": [
        {
          "name": "value1",
          "description": "Value to be checked to see if it is strictly not equal to (`!==`) `value2`.",
          "type": "*"
        },
        {
          "name": "value2",
          "description": "Value to be checked to see if it is strictly not equal to (`!==`) `value1`.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `value1` and `value2` are given a boolean indicating if `value1` is strictly not equal to (`!==`) `value2` will be returned.  Otherwise a partial function will be returned which when called will accept one value and will return a boolean indicating if that value is strictly not equal to (`!==`) `value1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "noConflict",
      "code": "var noConflict;\n(function(previousValue, alreadyRun) {\n  noConflict = function() {\n    if (!alreadyRun) {\n      alreadyRun = 1;\n      __GLOBAL[__VARIABLE_NAME] = previousValue;\n    }\n    return YourJS;\n  };\n})(__GLOBAL[__VARIABLE_NAME]);",
      "description": "Reverts the global variable to which `YourJS` is initially assigned by the library back to its value prior to defining YourJS.",
      "params": [],
      "return": {
        "type": "Object",
        "description": "`YourJS` object."
      },
      "requires": [],
      "required": true,
      "tests": [
        {
          "name": "Simple",
          "code": "YourJS2 = YourJS;\nJS = YourJS.noConflict();\ntest(JS === YourJS2 && YourJS === undefined, true);"
        }
      ]
    },
    {
      "name": "not",
      "code": "function not(x) { return !x; }",
      "description": "Apply the boolean negation operator to a value.",
      "params": [
        {
          "name": "x",
          "description": "The value to use boolean negation on.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `x` was `false`-like or `false` if `x` was `true`-like."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "now",
      "code": "function now() { return new Date; }\nnow.valueOf = function() { return +new Date; };",
      "description": "Gets the a `Date` object representing the current date/time.",
      "params": [],
      "return": {
        "type": "Date",
        "description": "A `Date` object representing the current date/time.  Executing arithmetic on this function without invoking it will result in getting the number of milliseconds since January 1, 1970 GMT (eg. `+YourJS.now === Date.now()`)."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.now().toISOString(), (new Date).toISOString());"
        },
        {
          "name": "Arithmetic Feature",
          "code": "test(+YourJS.now, +new Date);"
        }
      ]
    },
    {
      "name": "nth",
      "code": "function nth(arrayOrN, opt_n) {\n  return opt_n != undefined\n    ? arrayOrN[opt_n < 0 ? arrayOrN.length + opt_n : opt_n]\n    : function(array) {\n      return array[arrayOrN < 0 ? array.length + arrayOrN : arrayOrN];\n    };\n}",
      "description": "Gets the value at the specified position in an array or an array-like object.",
      "params": [
        {
          "name": "arrayOrN",
          "description": "If an array or an array-like object is given this will be the object from which the value will be immediately retrieved.  If this is a number, this will be interpreted as `opt_n`, the position from which all values passed into the returned partial function will be retrieved.",
          "type": "Array|number"
        },
        {
          "name": "opt_n",
          "description": "If given and `arrayOrN` is an array or an array-like object, this will be the position from which the value should be retrieved.  If this is a negative number the position will be calculated from the end of `arr`.  If `arrayOrN` is a number this will become that value.",
          "type": "number"
        }
      ],
      "return": {
        "type": "Function|*",
        "description": "If `arrayOrN` is an array or an array-like object the value at position `n` will be returned.  Otherwise if `arrayOrN` is a number a partial function that will already have the value of `opt_n` and will be awaiting the array will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var arr = [5,8,2,13];\ntest(YourJS.nth(arr, 3), arr[3]);"
        },
        {
          "name": "Negative Position",
          "code": "var arr = [5,8,2,13];\ntest(YourJS.nth(arr, -3), arr.slice(-3)[0]);"
        },
        {
          "name": "Simple Partial",
          "code": "var arr = [5,8,2,13], arr2 = [1,2,3,4,5,6,7];\nvar first = YourJS.nth(0), last = YourJS.nth(-1);\ntest(JSON.stringify([first(arr),last(arr),first(arr2),last(arr2)]), '[5,13,1,7]');"
        }
      ]
    },
    {
      "name": "only",
      "code": "function only(opt_subject, keys, opt_initial) {\n  function f(subject, opt_initial) {\n    var result = {};\n    var arrKeys = 'function' === typeof keys\n      ? entries(subject).reduce(function (carry, kv) {\n        if (keys(kv[0], kv[1])) {\n          carry.push(kv[0]);\n        }\n        return carry;\n      }, [])\n      : keys;\n    return arrKeys.reduce(function (result, key) {\n      if (has(subject, key)) {\n        result[key] = subject[key];\n      }\n      return result;\n    }, opt_initial || {});\n  }\n\n  return keys ? f(opt_subject, opt_initial) : ((keys = opt_subject), f);\n}",
      "description": "Creates a new object with only the specified keys copied from the specified object to this new object.",
      "params": [
        {
          "name": "opt_subject",
          "description": "If `undefined` this indicates that a partial function will be returned.  Otherwise this is the object from which the properties should be copied.",
          "type": "Object|undefined"
        },
        {
          "name": "keys",
          "description": "If this is an array it must be the keys of the subject to be copied to the new object.  If this is a function it will be called for each key/value pair (receiving the key as argument 1 and the value as argument 2) and whenever the return value is `true`-ish the key/value pair will be copied to the new object.",
          "type": "Array|Function"
        },
        {
          "name": "opt_initial",
          "description": "If given this is the object that will be returned and into which the properties will be copied.",
          "type": "*",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `opt_subject` was given `opt_initial` with the specified keys copied into it will be returned.  Otherwise a partial function will be returned which will accept (1) the mandatory object from which to copy the properties and (2) the optional initial object that will be augmented and returned."
      },
      "requires": [
        "has",
        "entries"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.only({a:1,b:2}, ['a','c'])), '{\"a\":1}');"
        },
        {
          "name": "Simple Copy Number Values",
          "code": "test(JSON.stringify(YourJS.only({a:\"1\",b:2}, (k,v) => \"number\" === typeof v)), '{\"b\":2}');"
        }
      ]
    },
    {
      "name": "orBits",
      "code": "",
      "description": "Finds the bitwise `or` of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be `or`ed against `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to be `or`ed against `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given a bitwise `or` will be executed on both and returned.  Otherwise a partial function will be returned which when called will accept one number and will return a number which is the result of using bitwise `or` on `number1` and the number passed to this partial function."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ordinalize",
      "code": "function ordinalize(num, opt_excludeNum) {\n  var abs = num < -num ? -num : num, ones = abs % 10;\n  return (opt_excludeNum ? '' : num) + ((abs % 100 - ones - 10 ? [0,'st','nd','rd'][ones] : 0) || 'th');\n}",
      "description": "Get the ordinal for an integer (`st`, `nd`, `rd`, or `th`).",
      "params": [
        {
          "name": "num",
          "description": "Number for which to get the ordinal.",
          "type": "number"
        },
        {
          "name": "opt_excludeNum",
          "description": "Indicates whether or not to exclude `num` from the return value.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "string",
        "description": "If `opt_excludeNum` is `false`-ish a string version of `num` with the appropriate ordinal string will be returned.  If `opt_excludeNum` is `true`-ish just the ordinal corresponding to `num` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "pacman",
      "code": "function pacman(x, inclusive, exclusive) {\n  exclusive -= inclusive;\n  return ((x - inclusive) % exclusive + exclusive) % exclusive + inclusive;\n}",
      "description": "Confines a number to a specified range by looping number that are too large back to the beginning of the range and numbers that are too small back to the end of the range (just like in Pacman).",
      "params": [
        {
          "name": "x",
          "description": "The number that you want to confine to the specified range.",
          "type": "number"
        },
        {
          "name": "inclusive",
          "description": "An extreme of the range to which to confine `x`.  This number IS included in the range of valid numbers.",
          "type": "number"
        },
        {
          "name": "exclusive",
          "description": "An extreme of the range to which to confine `x`.  This number IS NOT included in the range of valid numbers.  If `x` is equal to this number, `inclusive` will be returned from this function.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "A number representing `x` within the range `inclusive` and `exclusive` where `x` can be `inclusive` but cannot be `exclusive`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "padEnd",
      "code": "function padEnd(str, maxLength, opt_fillString) {\n  str += '';\n\n  var filler, fillLen, stringLength = str.length;\n\n  return maxLength > stringLength\n    ? (\n        filler = (opt_fillString !== undefined ? opt_fillString + '' : '') || ' ',\n        fillLen = maxLength - stringLength,\n        str + (new Array(Math.ceil(fillLen / filler.length) + 1)).join(filler).slice(0, fillLen)\n      )\n    : str;\n}",
      "description": "Appends a string with a filler string so that the length of the string is always at least a certain length.",
      "params": [
        {
          "name": "str",
          "description": "The string to append a filler string to.",
          "type": "string"
        },
        {
          "name": "maxLength",
          "description": "The maximum length allowed for the returned string. If this is less than `str.length`, this will be set to `str.length`.",
          "type": "number"
        },
        {
          "name": "opt_fillString",
          "description": "The string to repeatedly append to `str` until the length reaches `maxLength`.",
          "type": "string",
          "optional": true,
          "default": "\" \""
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns `str` with the filler string appended to it as many times as necessary until `maxLength` is reached."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "padStart",
      "code": "function padStart(str, maxLength, opt_fillString) {\n  str += '';\n\n  var filler, fillLen, stringLength = str.length;\n\n  return maxLength > stringLength\n    ? (\n        filler = (opt_fillString !== undefined ? opt_fillString + '' : '') || ' ',\n        fillLen = maxLength - stringLength,\n        (new Array(Math.ceil(fillLen / filler.length) + 1)).join(filler).slice(0, fillLen) + str\n      )\n    : str;\n}",
      "description": "Prepends a string with a filler string so that the length of the string is always at least a certain length.",
      "params": [
        {
          "name": "str",
          "description": "The string to prepend a filler string to.",
          "type": "string"
        },
        {
          "name": "maxLength",
          "description": "The maximum length allowed for the returned string. If this is less than `str.length`, this will be set to `str.length`.",
          "type": "number"
        },
        {
          "name": "opt_fillString",
          "description": "The string to repeatedly prepend to `str` until the length reaches `maxLength`.",
          "type": "string",
          "optional": true,
          "default": "\" \""
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns `str` with the filler string prepended to it as many times as necessary until `maxLength` is reached."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "pair",
      "code": "function pair(pairs, opt_objToAugment) {\n  opt_objToAugment = opt_objToAugment || {};\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    opt_objToAugment[pairs[i][0]] = pairs[i][1];\n  }\n  return opt_objToAugment;\n}",
      "description": "Takes an array of arrays (each inner array being a key-value pair) and returns the object with the keys and values set accordingly.",
      "params": [
        {
          "name": "pairs",
          "description": "An array of arrays where the inner arrays are key-value pairs.  The keys and values will be assigned to `opt_objToAugment`.",
          "type": "Array<Array>"
        },
        {
          "name": "opt_objToAugment",
          "description": "If specified this is the object that will be augmented according to the keys and values found in `pairs`.",
          "type": "Object",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "Object",
        "description": "A reference to `opt_objToAugment`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "parseQS",
      "code": "function parseQS(url) {\n  var vars = {};\n  url.replace(/\\?[^#]+/, function(query) {\n    query.replace(/\\+/g, ' ').replace(/[\\?&]([^=&#]+)(?:=([^&#]*))?/g, function(m, key, value, arrIndicator, alreadyDefined, lastValue) {\n      key = decodeURIComponent(key);\n      arrIndicator = key.slice(-2) == '[]';\n      value = value && decodeURIComponent(value);\n      alreadyDefined = has(vars, key);\n      lastValue = vars[key];\n      vars[key] = (arrIndicator || alreadyDefined)\n        ? typeOf(lastValue) == 'Array'\n          ? lastValue.concat([value])\n          : alreadyDefined\n            ? [lastValue, value]\n            : [value]\n        : value;\n    });\n  });\n  return vars;\n}",
      "description": "Parses a URL to get the parameters specified in the query string.",
      "params": [
        {
          "name": "url",
          "description": "The URL to parse.",
          "type": "string"
        }
      ],
      "return": {
        "type": "Object",
        "description": "An object in which the keys are the keys of the parameters found in `url` and the values are the corresponding values found in `url`. If a parameter key is specified twice or ends in `\"[]\"`, that property will be an array of all of the found values for that key."
      },
      "requires": [
        "has",
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var url = 'http://google.com?q=my+search+terms';\ntest(YourJS.parseQS(url).q, 'my search terms');"
        }
      ]
    },
    {
      "name": "partial",
      "code": "function partial(fn, arrPresetArgs, opt_presetFromRight) {\n  return opt_presetFromRight\n    ? function() { return fn.apply(this, slice(arguments).concat(arrPresetArgs)); }\n    : function() { return fn.apply(this, arrPresetArgs.concat(slice(arguments))); };\n}",
      "description": "Creates a copy of a function with the left-most arguments preset.",
      "params": [
        {
          "name": "fn",
          "description": "The function whose left-most arguments should be preset.",
          "type": "Function"
        },
        {
          "name": "arrPresetArgs",
          "description": "An array containing all of the arguments to always be passed to the returned version of `fn`.",
          "type": "Array",
          "optional": false
        },
        {
          "name": "opt_presetFromRight",
          "description": "Boolean indicating if the preset arguments should always be passed after all other arguments.  If `false` all preset arguments will precede the other arguments passed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function which essentially acts as `fn` with the `arrPresetArgs` already being sent.  The arguments in `arrPresetArgs` will be sent as the left-most arguments if `opt_presetFromRight` is not specified or `false`-ish, otherwise they will be sent as the right-most arguments."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "partialAny",
      "code": "function partialAny(fn, objArgPresets) {\n  var objThis, objThisGiven, arrPresets = [];\n  forIn(objArgPresets, function(value, key) {\n    if (key == 'this') {\n      objThis = value;\n      objThisGiven = 1;\n    }\n    else if (isFinite(key = +key) && key == ~~key) {\n      arrPresets.push([key, value]);\n    }\n  });\n  arrPresets.sort(function(a, b) {\n    a = 1 / a[0];\n    b = 1 / b[0];\n      return (a < 0 && b < 0) ? b - a : (a - b);\n  });\n  return function() {\n    for (var preset, arrArgs = slice(arguments), i = arrPresets.length; i--; ) {\n      preset = arrPresets[i];\n      arrArgs.splice(preset[0] || (1/preset[0] < 0 ? Infinity : 0), 0, preset[1]);\n    }\n    return fn.apply(objThisGiven ? this : objThis, arrArgs);\n  };\n}",
      "description": "Creates a partial function where the arguments in any position can be set.  Also allows for setting the value of `this`.",
      "params": [
        {
          "name": "fn",
          "description": "Function to return a partial version of.",
          "type": "Function"
        },
        {
          "name": "objArgPresets",
          "description": "Object whose properties will be used to preset the arguments within the partial function.  Each property name that is a positive integer will be used to fill in arguments from the left while property names that are negative integers (including `-0`) will be used to fill in arguments from the right.  If a property is named `this` it will be used to specify the `this` context object of the partial function.",
          "type": "Object",
          "optional": false
        }
      ],
      "return": {
        "type": "Function",
        "description": "A partial version of `fn` with the arguments specified in `objArgPresets` already set."
      },
      "requires": [
        "slice",
        "forIn"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "paste",
      "code": "function paste(str, newPart, startIndex, opt_endIndex) {\n  str = cut(str, startIndex, opt_endIndex == undefined ? startIndex : opt_endIndex);\n  return str.slice(0, startIndex) + newPart + str.slice(startIndex);\n}",
      "description": "Pastes a string into another string while possibly replacing part of the string being pasted into.",
      "params": [
        {
          "name": "str",
          "description": "String to be modified.",
          "type": "string"
        },
        {
          "name": "newPart",
          "description": "String to be pasted into `str`.",
          "type": "string"
        },
        {
          "name": "startIndex",
          "description": "Index within `str` indicating where to paste `newPart`.",
          "type": "number"
        },
        {
          "name": "opt_endIndex",
          "description": "Index within `str` indicating where the end of `newPart` will end.",
          "type": "number",
          "optional": true,
          "default": "startIndex"
        }
      ],
      "return": {
        "type": "string",
        "description": "A copy of `str` modified so that `newPart` is pasted into it from `startIndex` to `opt_endIndex`."
      },
      "requires": [
        "cut"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "pluck",
      "code": "function pluck(arr, propName) {\n  for (var item, negPropName = propName < 0 && ~~propName === propName, result = [], i = arr.length; i--;) {\n    item = arr[i];\n    if (has(arr, i)) {\n      result[i] = item == undefined\n        ? item\n        : item[(negPropName && isFinite(item.length)) ? propName + item.length : propName];\n    }\n  }\n  return result;\n}",
      "description": "Creates a copy of the given array making each item the value of the given property name.",
      "params": [
        {
          "name": "arr",
          "description": "Array to copy.",
          "type": "Array"
        },
        {
          "name": "propName",
          "description": "Name of the property of each array item that will replace the corresponding array item.  If this is a negative number and the array items are arrays this will be used as the index counting from the end of those arrays.",
          "type": "string|number",
          "optional": false
        }
      ],
      "return": {
        "type": "Array",
        "description": "Copy of `arra` where each item is replaced by one of its properties as specified by `propName`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Length property",
          "code": "var arr = ['My', 'name', 'is', 'John', 'Smith.'];\nvar lengths = [2,4,2,4,6];\ntest(YourJS.pluck(arr, 'length').join(''), lengths.join(''));"
        }
      ]
    },
    {
      "name": "poll",
      "code": "function poll(fnTest, fnOnFound, opt_interval, opt_timeout) {\n  var isDone, iteration = 0, self = this, start = new Date;\n  opt_timeout = opt_timeout == undefined ? Infinity : opt_timeout;\n  opt_interval = opt_interval == undefined ? 100 : opt_interval;\n  function cancel() {\n    isDone = true;\n  }\n  function fnTestWrapper() {\n    try {\n      var result = fnTest.call(self, cancel, ++iteration);\n      if (result) {\n        isDone = result;\n        fnOnFound.call(self, result, iteration);\n        result;\n      }\n      return !!result;\n    }\n    catch (e) {\n      throw e;\n    }\n    finally {\n      if (!isDone && (new Date - start) < opt_timeout) {\n        setTimeout(fnTestWrapper, opt_interval);\n      }\n    }\n  }\n  return fnTestWrapper();\n}",
      "description": "Periodically tests for a condition to be met before executing some code.",
      "params": [
        {
          "name": "fnTest",
          "description": "Polling function which will be executed every `opt_interval` until it returns a `true`-ish value or the `opt_timeout` time elapses.  The arguments passed will be (1) a prevention function that when called will prevent further tests from occurring and (2) the number of times this function was called.  Calling the prevention function will only prevent subsequent polls from happening, it will not indicate that the test was a success or failure.",
          "type": "Function"
        },
        {
          "name": "fnOnFound",
          "description": "Function to execute once `fnTest` evaluates to a `true`-ish value.  The arguments passed will be (1) the return value from the success call to `fnTest` and (2) the number of times `fnTest` was called.",
          "type": "Function"
        },
        {
          "name": "opt_interval",
          "description": "Amount of milliseconds to wait between tests.",
          "type": "number",
          "optional": true,
          "default": "100"
        },
        {
          "name": "opt_timeout",
          "description": "Amount of milliseconds to wait timing out the poll.",
          "type": "number",
          "optional": true,
          "default": "Infinity"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Indicating if the first call to `fnTest` was a success."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var done, cool;\nsetTimeout(function(){done = true}, 500);\nYourJS.poll(function(prevent, iter){console.log(iter);return done;}, function() {cool = true});\nsetTimeout(function(){ test(cool, true) }, 1000);"
        }
      ]
    },
    {
      "name": "postURL",
      "code": "function postURL(url, opt_data, opt_target, opt_ownerDocument) {\n  opt_ownerDocument = opt_ownerDocument || __DOCUMENT;\n\n  var body = opt_ownerDocument.body,\n    form = extend(opt_ownerDocument.createElement(\"FORM\"), {\n      method: 'POST',\n      action: url\n    });\n  if (opt_target) {\n    form.target = opt_target;\n  }\n  form.style.display = \"none\";\n\n  // If opt_data is an array treat it as an array of key/value pairs, otherwise\n  // get an array of key/value pairs and traverse them all.\n  (Array.isArray(opt_data) ? opt_data : entries(opt_data)).forEach(function (pair) {\n    form.appendChild(extend(opt_ownerDocument.createElement(\"TEXTAREA\"), {\n      name: pair[0],\n      value: 'object' === typeof pair[1] ? JSON.stringify(pair[1]) : pair[1]\n    }));\n  });\n\n  body.appendChild(form);\n  form.submit();\n  body.removeChild(form);\n  return form;\n}",
      "description": "Takes a URL and goes to it using the POST method.",
      "params": [
        {
          "name": "url",
          "description": "The URL with the GET parameters to go to.",
          "type": "string"
        },
        {
          "name": "opt_data",
          "description": "Data to be passed when posting to the URL.  If this is an array, it should be an array of arrays where the inner arrays' first elements are keys and the second elements are values.  If this is an object, the keys are interpreted as the keys and the values as values.  If the values are some type of object or array they will be JSON stringified.",
          "type": "Array|Object",
          "optional": true
        },
        {
          "name": "opt_target",
          "description": "If specified it will be used as the target frame for where to POST to.",
          "type": "string",
          "optional": true,
          "default": "'_self'"
        },
        {
          "name": "opt_ownerDocument",
          "description": "If specified it will be the `ownerDocument` under which the form will be created to POST `url` to.",
          "type": "HTMLDocument",
          "optional": true,
          "default": "window.document"
        }
      ],
      "return": {
        "type": "HTMLFormElement",
        "description": "The HTML form element that is temporarily to created to post to the specified URL."
      },
      "requires": [
        "entries",
        "extend"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "prefix",
      "code": "function prefix(str, strPrefix, opt_rgxTester) {\n  return str == undefined\n    ? function(str) { return prefix(str, strPrefix, opt_rgxTester); }\n    : (opt_rgxTester ? !opt_rgxTester.test(str) : str.indexOf(strPrefix))\n      ? strPrefix + str\n      : str;\n}",
      "description": "Always ensures that a string starts with a specific substring.",
      "params": [
        {
          "name": "str",
          "description": "This will be the string to which the prefix will be prepended unless the test proves that it doesn't need to be prepended.  Specifying `undefined` or `null` will cause a partial function to be returned.",
          "type": "string|undefined|null"
        },
        {
          "name": "strPrefix",
          "description": "This will be the prefix to add to `str` if it needs to be added.",
          "type": "string",
          "optional": false,
          "default": ""
        },
        {
          "name": "opt_rgxTester",
          "description": "Regular expression to test against the string to be prefixed.  If the string tests negative against this regular expression `strPrefix` will be prepended to the beginning of it.",
          "type": "RegExp",
          "optional": true
        }
      ],
      "return": {
        "type": "string|function(string)",
        "description": "If `str` is not given a partial function will be returned which will await the string value of `str`.  If `opt_rgxTester` isn't given, the `str` will be returned and it will be prefixed with `strPrefix` if it isn't already at the beginning of it.  If `opt_rgxTester` is given and `str` tests negative against it `str` prefixed with `strPrefix` will be returned.  Otherwise `str` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var path1 = 'google.com', path2 = 'http://bing.com';\ntest(\n  YourJS.prefix(path1, 'http://') + ' ' + YourJS.prefix(path2, 'http://'),\n  'http://google.com http://bing.com'\n);"
        },
        {
          "name": "Partial",
          "code": "var path1 = 'google.com/', path2 = 'http://bing.com/';\nvar prefixHTTP = YourJS.prefix(undefined, 'http://');\ntest(\n  prefixHTTP(path1) + ' ' + prefixHTTP(path2),\n  'http://google.com/ http://bing.com/'\n);"
        },
        {
          "name": "Partial #2",
          "code": "var path1 = 'google.com/', path2 = 'https://bing.com/';\nvar prefixHTTP = YourJS.prefix(undefined, 'http://', /^https?:\\/\\//);\ntest(\n  prefixHTTP(path1) + ' ' + prefixHTTP(path2),\n  'http://google.com/ https://bing.com/'\n);"
        }
      ]
    },
    {
      "name": "prop",
      "code": "function prop(obj, opt_name) {\n  function getProp(name) {\n    name = obj[name];\n    return 'function' == typeof name ? name.call(obj) : name;\n  }\n  obj = obj || Object(obj);\n  return arguments.length > 1 ? getProp(opt_name) : getProp;\n}",
      "description": "Gets the value of a property.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose property will be retrieved.",
          "type": "Object"
        },
        {
          "name": "opt_name",
          "description": "Name of the property to get.  If `obj[opt_name]` references a function it will be called to get the property value.",
          "type": "string",
          "optional": true
        }
      ],
      "return": {
        "type": "Function|*",
        "description": "If both `obj` and `opt_name` are given, the property `obj[opt_name]` will be returned.  If `opt_name` is not given a partial function is returned which will await the value of `opt_name`.  If the property to be returned is a function it will be evaluated and the return value will be returned instead."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var obj = { name: 'John', age: 42,\n  summary: function() { return this.name + ' is ' + this.age; } };\nvar prop = YourJS.prop(obj);\ntest(JSON.stringify([YourJS.prop(obj, 'name'), prop('age'), prop('summary')]),\n     '[\"John\",42,\"John is 42\"]');"
        }
      ]
    },
    {
      "name": "propOf",
      "code": "function propOf(name, opt_obj) {\n  function getPropOf(obj) {\n    var prop = (obj || Object(obj))[name];\n    return 'function' == typeof prop ? prop.call(obj) : prop;\n  };\n  return arguments.length > 1 ? getPropOf(opt_obj) : getPropOf;\n}",
      "description": "Gets the value of a property.",
      "params": [
        {
          "name": "name",
          "description": "Name of the property to get.  If `obj[opt_name]` references a function it will be called to get the property value.",
          "type": "string",
          "optional": false
        },
        {
          "name": "opt_obj",
          "description": "Object whose property will be retrieved.",
          "type": "Object",
          "optional": true
        }
      ],
      "return": {
        "type": "Function|*",
        "description": "If both `opt_obj` and `name` are given, the property `opt_obj[name]` will be returned.  If `opt_obj` is not given a partial function is returned which will await the value of `opt_obj`.  If the property to be returned is a function it will be evaluated and the return value will be returned instead."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var obj = { name: 'John', age: 42,\n  summary: function() { return this.name + ' is ' + this.age; } };\nvar ageOf = YourJS.propOf('age');\ntest(JSON.stringify([YourJS.propOf('name', obj), ageOf(obj), YourJS.propOf('summary', obj)]),\n     '[\"John\",42,\"John is 42\"]');"
        }
      ]
    },
    {
      "name": "quoteRegExp",
      "code": "function quoteRegExp(str, opt_flagsOrMakeRegExp) {\n  var ret = str.replace(/[[\\](){}.+*^$|\\\\?-]/g, '\\\\$&');\n  return (opt_flagsOrMakeRegExp === '' || opt_flagsOrMakeRegExp)\n    ? new RegExp(ret, opt_flagsOrMakeRegExp === true ? '' : opt_flagsOrMakeRegExp)\n    : ret;\n}",
      "description": "Turn any string into a regular expression that matches the exact string without worrying about encoding the metacharacters yourself.",
      "params": [
        {
          "name": "str",
          "description": "The string that should be modified so that any characters that would normally serve as metacharacters in a regular expression will be escaped.",
          "type": "string"
        },
        {
          "name": "flagsOrMakeRegExp",
          "description": "If not specified or if `false`, it will cause just the escaped version of `str` to be returned. If `true`, it will be as if the empty string was passed in. A string represents the flags to be set in the returned regular expression.",
          "type": "boolean|string",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "RegExp|string",
        "description": "If `flagsOrMakeRegExp` is `true` a regular expression without flags will be returned. If `flagsOrMakeRegExp` is a non-empty string, a regular expression with the specified characters representing the corresponding flags will be returned. In all other cases just the escaped string that can be used as a regular expression will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "radians",
      "code": "function radians(degrees) {\n  return degrees * Math.PI / 180;\n}",
      "description": "Converts degrees to radians.",
      "params": [
        {
          "name": "degrees",
          "description": "The number representing degrees of an angle which will be converted to radians.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The equivalent of `degrees` in radians."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "random",
      "code": "function random(arrOrMinOrMax, opt_max, opt_round) {\n  if ('number' == typeof arrOrMinOrMax) {\n    if ('boolean' == typeof opt_max) {\n      opt_round = opt_max;\n      opt_max = undefined;\n    }\n    if (opt_max === undefined) {\n      opt_max = arrOrMinOrMax;\n      arrOrMinOrMax = 0;\n    }\n    arrOrMinOrMax = Math.random() * (opt_max - arrOrMinOrMax) + arrOrMinOrMax;\n    return opt_round ? Math.trunc(arrOrMinOrMax) : arrOrMinOrMax;\n  }\n  return arrOrMinOrMax[random(0, arrOrMinOrMax.length, 1)];\n}",
      "description": "Either generates a random number or pulls a random value from an array.",
      "params": [
        {
          "name": "arrOrMinOrMax",
          "description": "If an array, a random item from it will be returned.  If this is a number and `opt_max` is either not given or boolean this will be seen as the maximum value.  Otherwise this will be seen as the minimum value that can be returned.",
          "type": "Array|number"
        },
        {
          "name": "opt_max",
          "description": "If this is a number it will be interpreted as the maximum value.  The maximum value will never be returned because a random number between the minimum value (inclusive) and the maximum value (exclusive) is always returned.  If this is a boolean it will be used as `opt_truncate` and the maximum will come from `arrOrMinOrMax` thus setting `0` to `arrOrMinOrMax`.",
          "type": "number|boolean",
          "optional": true
        },
        {
          "name": "opt_truncate",
          "description": "If `true`-ish and `arrOrMinOrMax` wasn't an array the returned value will be truncated.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `arrOrMinOrMax` is an array a random value from the array will be returned, otherwise a random number in the given range will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "range",
      "code": "function range(startOrStop, opt_stop, opt_step) {\n  if (arguments.length < 2) {\n    opt_stop = startOrStop;\n    startOrStop = 0;\n  }\n  for (var ret = [], t = (opt_step = opt_step || 1) > 0; t ? startOrStop < opt_stop : startOrStop > opt_stop; startOrStop += opt_step) {\n    ret.push(startOrStop);\n  }\n  return ret;\n}",
      "description": "Creates an array of numbers within a given range.",
      "params": [
        {
          "name": "startOrStop",
          "description": "The starting point of the range to return.  If this is the argument argument passed the value will be used as `opt_stop` and this will become `0`.",
          "type": "number"
        },
        {
          "name": "opt_stop",
          "description": "The non-inclusive boundary of the range.  This value will not be included in the returned array.  The value is pulled from `startOrStop` if not specified.",
          "type": "number",
          "optional": true,
          "default": "startOrStop"
        },
        {
          "name": "opt_step",
          "description": "The difference between each subsequent number in the range.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array.<number>",
        "description": "Returns an array of all of the numbers in the range. If `opt_step` >= `0` but `startOrStop` >= `opt_stop`, an empty array will be returned. Also, if `opt_step` <= `0`, but `startOrStop` <= `opt_stop`, an empty array will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple 1 Arg",
          "code": "test(YourJS.range(5).join(''), '01234');"
        },
        {
          "name": "Simple 2 Args",
          "code": "test(YourJS.range(5,10).join(','), '5,6,7,8,9');"
        },
        {
          "name": "Simple 3 Args",
          "code": "test(YourJS.range(10,5,-1).join('|'), '10|9|8|7|6');"
        }
      ]
    },
    {
      "name": "rearg",
      "code": "function rearg(fn, indices, opt_restIndex) {\n  var normalIndices = indices.map(function(v,i){return '$' + i;}).join(','),\n      modifiedIndices = indices.map(function(v, i) {\n        return '$' + (v == undefined ? i : v);\n      }).join(',');\n  return Function('f,s', 'return function(' + normalIndices + '){return f.apply(this, [' + modifiedIndices + '].concat(s(arguments,' + (opt_restIndex == undefined ? indices.length : opt_restIndex) + ')))}')(fn,slice);\n}",
      "description": "Creates a new wrapper function that will call the original the arguments in a different order.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be wrapped and called with the arguments in a different order.",
          "type": "Function"
        },
        {
          "name": "indices",
          "description": "Indices of the arguments to be passed.  If the you want `fn(a,b,c)` to always be called as `fn(c,a,b)` you can supply `[2,0,1]`.",
          "type": "Array.<number>"
        },
        {
          "name": "opt_restIndex",
          "description": "The starting index of the rest of the arguments that will be allowed to be passed in after those specified by `indices`.  If `Infinity`, no more arguments will be passed no matter how many are sent to the wrapper function.  If `undefined`, `indices.length` will be used.",
          "type": "number",
          "optional": true,
          "default": "indices.length"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The wrapper function that will call `fn` with the arguments in the specified order."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "rekey",
      "code": "// has(), isArrayLike()\nfunction rekey(obj, keyMap, opt_keepOriginals) {\n  obj = Object(obj);\n  // Allow for partial call...\n  if (obj == undefined) {\n    return function(obj) {\n      return rekey(obj, keyMap, opt_keepOriginals);\n    };\n  }\n\n  var isArray = isArrayLike(obj); \n  var newObj = isArray ? [] : {};\n  var excludedOriginals = [];\n  (\n    Array.isArray(keyMap)\n      ? keyMap\n      : Object.keys(keyMap).map(function (key) {\n          return [key, keyMap[key]];\n        })\n  ).forEach(function (pair) {\n    var oldKey = pair[0];\n    var oldKeyType = typeof oldKey;\n    var testId = oldKeyType === 'function' ? 1 : 'string,boolean,number'.indexOf(oldKeyType) >= 0 ? 2 : 0;\n    var newKey = pair[1];\n    var newKeyIsFunc = 'function' === typeof newKey;\n    for (var keyInObj in obj) {\n      if (has(obj, keyInObj = isArray ? +keyInObj : keyInObj)) {\n        if (testId ? testId === 1 ? oldKey(keyInObj) != undefined : oldKey == keyInObj : oldKey.test(keyInObj)) {\n          newObj[keyInObj.replace(testId ? /^[^]*$/ : oldKey, newKeyIsFunc ? newKey(keyInObj) : newKey)] = obj[keyInObj];\n          if (!opt_keepOriginals) {\n            excludedOriginals.push(keyInObj);\n          }\n        }\n      }\n    }\n  });\n  for (var keyInObj in obj) {\n    if (has(obj, keyInObj) && excludedOriginals.indexOf(isArray ? +keyInObj : keyInObj) < 0 && !has(newObj, keyInObj)) {\n      newObj[keyInObj] = obj[keyInObj];\n    }\n  }\n  return newObj;\n}",
      "description": "Modifies keys of an object or augments the object with more keys for the same values.",
      "params": [
        {
          "name": "obj",
          "description": "The object or array to be cloned, possibly augmented and changed.  If not given then a partial function will be returned by `rekey()`.",
          "type": "Array|Object"
        },
        {
          "name": "keyMap",
          "description": "Specifies how to update the clone of `obj`.  If this is an object the keys will correspond to the current keys and values will correspond to the new keys.  If this is an array then each value must be an array where the first item is used to match current keys and the second item is used to define the new keys.  An array at times may be preferred so that you can target one or more current keys using a function (which is passed just passed each current key and should return a value indicating whether it should be modified) or a regular expression.  If the property values or each array item's second value is a function, it will be called with the value of the current key that is to be modified or augmented and the return value will be used as the new key or additional key.",
          "type": "Array|Object"
        },
        {
          "name": "opt_keepOriginals",
          "description": "If `true` then the returned object or array will be an augmented version of `obj`.  Otherwise any keys that are found in `obj` because of `keyMap` values will simply be replaced according to the corresponding values in `keyMap`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function|Array|Object",
        "description": "If `obj` is `undefined` or `null` a partial function which will allow for `obj` to be defined will be returned.  If `obj` is array-like a new array will be returned.  Otherwise a new object will be returned.  In the case that an array or an object is returned the keys will be based on the keys from `obj` and the values determined by `keyMap`."
      },
      "requires": [
        "has",
        "isArrayLike"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var d = new Date();\ntest(\n  JSON.stringify(YourJS.rekey({ Fecha: d }, { Fecha: 'Date' })),\n  JSON.stringify({ Date: d })\n)"
        },
        {
          "name": "Simple Augment",
          "code": "var d = new Date();\nvar s = (a, b) => a[0] < b[0] ? -1 : 1;\ntest(\n  JSON.stringify(Object.entries(YourJS.rekey({ Fecha: d }, { Fecha: 'Date' }, true)).sort(s)),\n  JSON.stringify(Object.entries({ Fecha: d, Date: d }).sort(s))\n)"
        },
        {
          "name": "RegExp Names",
          "code": "var d = new Date();\nvar f = x => x + 'Name';\nvar s = (a, b) => a[0] < b[0] ? -1 : 1;\ntest(\n  JSON.stringify(Object.entries(YourJS.rekey({ first: 'Chris', last: 'West' }, [[/[^]*/, f]])).sort(s)),\n  JSON.stringify(Object.entries({ firstName: 'Chris', lastName: 'West' }).sort(s))\n)"
        }
      ]
    },
    {
      "name": "rem",
      "code": "",
      "description": "Finds the remainder after dividing two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be divided by `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to divide by `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given `number1` will be divided by `number2` and the remainder will be returned.  Otherwise a partial function will be returned which when called will accept one number and will return the remainder of dividing the number passed to the partial function by `number1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "removeAt",
      "code": "function removeAt(array, position) {\n  array.splice(position, 1);\n  return array;\n}",
      "description": "Removes a value from an array at the specified position.",
      "params": [
        {
          "name": "array",
          "description": "Array from which a value will be removed.",
          "type": "Array"
        },
        {
          "name": "position",
          "description": "Position within `array` from where the value should be removed.  If this is negative the position will be calculated from the end of `array`.",
          "type": "number"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A reference to `array`.  This is useful when chaining."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.removeAt([3,4,5,6,7,8,9], -2)), '[3,4,5,6,7,9]');"
        }
      ]
    },
    {
      "name": "removeCookie",
      "code": "function removeCookie(name, opt_options) {\n  var key, cookies, ret = getCookie(name);\n  if('string' == typeof ret) {\n    (cookies = {})[name] = ret;\n  }\n  else {\n    cookies = ret;\n  }\n  opt_options = opt_options || {};\n  for(key in cookies) {\n    if (has(cookies, key)) {\n      setCookie(key, '', {\n        path: opt_options.path,\n        domain: opt_options.domain,\n        secure: opt_options.secure,\n        expires: new Date(0)\n      });\n    }\n  }\n  return ret;\n}",
      "description": "Removes the specified cookie(s).",
      "params": [
        {
          "name": "name",
          "description": "Either the name of the cookie to remove or a regular expression matching the names of all of the cookies to remove.  If `undefined` or `null` is supplied that means all cookies should be removed.",
          "type": "string|RegExp|undefined|null",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_options",
          "description": "Object whose property values can be used to specify additional options.  If you want to specify the hosts for which the cookie will be removed you can set the `domain` property.  If a domain is specified, subdomains are always included.  If you want to specify the URL path from under which the cookie will be removed you can specify it in the `path` property.  If you want to remove a secure cookie while on a secure site (`https:`) you can set the `secure` property to `true`.",
          "type": "Object",
          "optional": true,
          "default": "{\"path\":\"/\"}"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `name` is a string and matches the name of a cookie, that cookie's value will be returned as a string.  If `name` is a string but doesn't match the name of a cookie `undefined` will be returned.  If `name` is of type `RegExp` an object containing all of the cookies with names that match the specified regular expression will be returned.  If `name` is `undefined` or `null` an object containing all of the cookies will be returned.  If an object is returned each key will represent the name of each removed cookie and each value will be the value of that removed cookie."
      },
      "requires": [
        "has",
        "getCookie",
        "setCookie"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "repair",
      "code": "function repair(obj, fnPairer, opt_initial) {\n  opt_initial = opt_initial || {};\n  forOf(obj, function(value, key) {\n    var result = fnPairer([key, value], obj);\n    if (result) {\n      opt_initial[result[0]] = result[1];\n    }\n  });\n  return opt_initial;\n}",
      "description": "Creates a object where the keys and values are based on key/value pair returned by the specified pairing function.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose key/value pairs will be sent to the pairing function.",
          "type": "*"
        },
        {
          "name": "fnPairer",
          "description": "Pairing function that will take (1) an array containing each key/value pair within `obj` and (2) a reference to `obj`.  If something is returned that is not `undefined` or `null` it should be an array containing the key/value pair to add to `opt_initial`.",
          "type": "Function"
        },
        {
          "name": "opt_initial",
          "description": "Object to return from `repair()` function which will contain the newly paired key/value pairs.  If not specified an empty object will be used.",
          "type": "*",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "*",
        "description": "A reference to `opt_initial` which has the key/value pairs returned by `fnPairer` added to it."
      },
      "requires": [
        "forOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "repay",
      "code": "function repay(input) {\n  var args = arguments;\n  return Function('s,i,a', 'return function(){return ' + (args.length - 1 ? 's(a)' : 'i') + '}')(slice, input, args);\n}",
      "description": "Produces a function that when called will simply return what was passed in.",
      "params": [
        {
          "name": "input",
          "description": "Zero or more arguments that will be returned by function made by this `repay` function.",
          "type": "*",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "Function",
        "description": "A function that when called will return all `input` arguments originally passed to the `repay` function.  If only one `input` was passed, calling this returned function will simply return that one `input` argument.  In all other cases an array containing all `input` arguments will be returned when this returned function is called."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "repeat",
      "code": "function repeat(string, count) {\n  return Array(count + 1).join(string);\n}",
      "description": "Creates a new string which is the given string repeated the specified number of times.",
      "params": [
        {
          "name": "string",
          "description": "String to be repeated.",
          "type": "string"
        },
        {
          "name": "count",
          "description": "Number of times that `string` should be repeated.",
          "type": "number"
        }
      ],
      "return": {
        "type": "string",
        "description": "A new string which will be `string` repeated `count` times."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.repeat('dumb-', 5) + YourJS.repeat('.', 3), 'dumb-dumb-dumb-dumb-dumb-...');"
        }
      ]
    },
    {
      "name": "replace",
      "code": "var replace;\n(function(breakError) {\n  function end() { throw breakError; }\n  replace = function(subject, target, replacer) {\n    var match, matches, i, l,\n        count = 0,\n        replacement = replacer,\n        targetType = typeOf(target = 'string' == typeof target ? [target] : target),\n        targetIsRegExp = targetType == 'RegExp',\n        isObject = !targetIsRegExp && targetType != 'Array',\n        rgx = targetIsRegExp ? target : new RegExp(\n          (isObject ? Object.keys(target) : target).map(function(v){return quoteRegExp(v);}).join('|'),\n          'g'\n        ),\n        result = subject;\n\n    try {\n      for (matches = matchAll(subject, rgx), i = 0, l = matches.length; i < l; i++) {\n        match = matches[i];\n        if (isObject) {\n          replacer = target[match];\n        }\n        if ('function' == typeof replacer) {\n          replacement = replacer.call(result, match, ++count, end);\n        }\n        result = result.slice(0, match.index) + replacement + result.slice(match.index + match[0].length);\n      }\n    }\n    catch (e) {\n      if (e != breakError) {\n        throw e;\n      }\n    }\n\n    return result;\n  };\n})({});",
      "description": "Replace targeted substrings with new strings.",
      "params": [
        {
          "name": "subject",
          "description": "String to be modified and returned.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "If this is a string each instance of this string will be found within `subject` and replaced by the result of `replacer`.  If this is an array each of the contents will be searched for within `subject` and replaced by the result of `replacer`.  If this is an object each key will be searched for and replaced by the result of the corresponding value.  If the corresponding value of an object's property is a function it will be executed the same way `replacer` would be.",
          "type": "Array|Object|string"
        },
        {
          "name": "replacer",
          "description": "If a function is supplied it will be called for each `target` found with argument 1 being the match array (including `match.input`, `match.index`, and `match.source`), argument 2 being the iteration count and argument 3 being a function that when executed will immediately stop replacing values.  If a string is supplied it will replace all instances of `target` within `subject`.  This parameter can be omitted and will be ignored if `target` is an object.",
          "type": "function(Array,number,Function)|string",
          "optional": false
        }
      ],
      "return": {
        "type": "string",
        "description": "`subject` with all of the targeted substrings replaced with new strings as specified either by `target` or `replacer`."
      },
      "requires": [
        "matchAll",
        "typeOf",
        "quoteRegExp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "replaceMany",
      "code": "function replaceMany(subject, target, replacement, opt_limit) {\n  var arr = subject.split(target);\n  var first = arr.slice(\n    0,\n    opt_limit = opt_limit == undefined ? Infinity : opt_limit < 0 ? ~~opt_limit - 1 : ~~opt_limit\n  );\n  var rest = arr.slice(opt_limit);\n  return first.join(replacement) + ((0 in first && 0 in rest) ? replacement : '') + rest.join(target + '');\n}",
      "description": "Replace multiple instances of a `target` string with a `replacement` string.",
      "params": [
        {
          "name": "subject",
          "description": "The string to be searched and modified.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "The string to look for and replace within `subject`.",
          "type": "string"
        },
        {
          "name": "replacement",
          "description": "The string to replace instances of `target` within `subject`.",
          "type": "string"
        },
        {
          "name": "opt_limit",
          "description": "The maximum number of occurrences of `target` to replace.  If negative it indicates how many occurrences of `target` from the end to not replace.  If not specified all occurrences will be replaced.",
          "type": "number",
          "optional": true,
          "default": "Infinity"
        }
      ],
      "return": {
        "type": "string",
        "description": "A new version of `subject` with a maximum of `opt_limit` number of occurrences of `target` replaced by `replacement`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.replaceMany('You awe vewy intewesting!', 'w', 'r', 2), 'You are very intewesting!');"
        },
        {
          "name": "Negative",
          "code": "test(YourJS.replaceMany('1+2+3+4+5+6', '+', '-', -2), '1-2-3-4+5+6');"
        }
      ]
    },
    {
      "name": "restParam",
      "code": "function restParam(fn, opt_start) {\n  opt_start = opt_start == undefined ? fn.length - 1 : opt_start;\n  return function() {\n    var args = slice(arguments);\n    return fn.apply(this, args.length < opt_start ? args : slice(args, 0, opt_start).concat([slice(args, opt_start)]));\n  }\n}",
      "description": "Creates a wrapper function that if called with more arguments than specified, those arguments will be passed in as an array in the final argument.",
      "params": [
        {
          "name": "fn",
          "description": "The function to call with the normal parameters followed by the rest parameter in its place as specified by `opt_start`.",
          "type": "Function"
        },
        {
          "name": "opt_start",
          "description": "The index within the arguments passed to the returned function that will start the summary of the rest parameter.",
          "type": "number",
          "optional": true,
          "default": "fn.length-1"
        }
      ],
      "return": {
        "type": "Function",
        "description": "Returns a function that when invoked will call `fn`, but if there are any that have an index greater or equal to `opt_start` they will be passed in as the last parameter which will be an array."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "reverse",
      "code": "function reverse(arrOrStr) {\n  return 'string' === typeof arrOrStr\n    ? arrOrStr.split('').reverse().join('')\n    : slice(arrOrStr).reverse();\n}",
      "description": "Takes an array (or an array-like object) or a string, copies it, and returns the copy in reverse order.",
      "params": [
        {
          "name": "arrOrStr",
          "description": "If this is an array or an array-like object a copy of it will be made as an array and then the copy will be reversed.  If this is a string a copy will be made with all of the characters put in reverse order.",
          "type": "Array|string"
        }
      ],
      "return": {
        "type": "Array|string",
        "description": "Returns a copy of `arrOrStr` in reverse order."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "root",
      "code": "function root(number, n) {\n  var result = Math.pow(Math.abs(number), 1 / n);\n  return (number < 0 && n % 2) ? -result : result;\n}",
      "description": "Determines the nth-root of a number.",
      "params": [
        {
          "name": "number",
          "description": "Number to be rooted.",
          "type": "number"
        },
        {
          "name": "n",
          "description": "The degree to which `number` should be rooted (eg. `3` for cube root).",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "`number` to the `n`th-root."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.root(625, 4), 5);"
        }
      ]
    },
    {
      "name": "round",
      "code": "eval('var ceil,floor,round');\n'ceil floor round'.replace(/\\w+/g, function(fnName, RGX_NUM_BOUNDS, RGX_EXTRA_DOT) {\n  RGX_NUM_BOUNDS = /^-?|$/g;\n  RGX_EXTRA_DOT = /(\\.\\d*)\\./;\n  eval('(function(x){' + fnName + '=x})')(function(num, opt_precision) {\n    opt_precision = opt_precision || 0;\n    var absPrecision = Math.abs(opt_precision);\n    var zeroesSub = '$&' + new Array(absPrecision + 2).join('0');\n    var rgxGrow = new RegExp('(\\\\.)(\\\\d{' + absPrecision + '})');\n    var rgxShrink = new RegExp('(\\\\d{' + absPrecision + '})(\\\\.)');\n    num = (num + '.').replace(RGX_NUM_BOUNDS, zeroesSub)\n      .replace(RGX_EXTRA_DOT, '$1')\n      .replace(opt_precision < 0 ? rgxShrink : rgxGrow, '$2$1');\n    num = (Math[fnName](+num) + '.').replace(RGX_NUM_BOUNDS, zeroesSub)\n      .replace(RGX_EXTRA_DOT, '$1')\n      .replace(opt_precision < 0 ? rgxGrow : rgxShrink, '$2$1');\n    return +num;\n  });\n});",
      "description": "Rounds with the specified precision.",
      "params": [
        {
          "name": "num",
          "description": "The number to be rounded.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number. Using the precision is similar to doing `Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision)`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` rounded with the specified precision."
      },
      "requires": [
        "ceil",
        "floor"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "roundIn",
      "code": "eval('var roundIn,roundOut;');\n'In<Out>'.replace(/(\\w+)(.)/g, function(_, fnEnding, op) {\n  eval('(function(c,f){round' + fnEnding + '=function(n,p){return(+n' + op + '0?c:f)(n,p)}})')(ceil, floor);\n});",
      "description": "Rounds a number towards `0`.",
      "params": [
        {
          "name": "num",
          "description": "Number to round towards `0`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number towards `0`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "`num` rounded towards `0`."
      },
      "requires": [
        "ceil",
        "floor",
        "roundOut"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "roundOut",
      "code": "",
      "description": "Rounds a number towards `0`.",
      "params": [
        {
          "name": "num",
          "description": "Number to round away from `0`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number away from `0`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "`num` rounded away from `0`."
      },
      "requires": [
        "roundIn"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "sameSign",
      "code": "function sameSign() {\n  for (\n    var args = arguments, b = args[0], mustBeNeg = b === b ? b < 0 || 1 / b < 0 : b, i = args.length;\n    b = args[--i], i && mustBeNeg === (b === b ? b < 0 || 1 / b < 0 : b);\n  );\n  return !i;\n}",
      "description": "Determines if two or more numbers have the same sign (negative or positive).",
      "params": [
        {
          "name": "number1",
          "description": "First number to be compared to all of the other passed numbers.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Second number to be compared to all of the other numbers passed.",
          "type": "number"
        },
        {
          "name": "numberX",
          "description": "All additional numbers, if any, to be compared to `number1`.",
          "type": "number",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if all of the numbers are positive or all of them are negative, otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "sample",
      "code": "// Done this way to account for partially or fully empty arrays\nfunction sample(arr, opt_count) {\n  var t, j, result = [], l = arr.length, i = l;\n  if (l) {\n    for (opt_count = Math.max(1, Math.min(opt_count || 1, l)); i--, result[i] = i;);\n    for (i = l; opt_count > l - i; ) {\n      j = Math.round(Math.random() * --i);\n      if (i && i != j) {\n        t = result[i];\n        result[i] = result[j];\n        result[j] = t;\n      }\n      if (has(arr, result[i])) {\n        result[i] = arr[result[i]];\n      }\n      else {\n        delete result[i];\n      }\n    }\n  }\n  return slice(result, -opt_count);\n}",
      "description": "Takes an array and returns a new array with some or all of the original values not usually in the same order.",
      "params": [
        {
          "name": "arr",
          "description": "Array to create a new sample array from.",
          "type": "Array"
        },
        {
          "name": "opt_count",
          "description": "Number of items to put in the sample array.  Cannot exceed `arr.length`.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array",
        "description": "Sample array of random elements picked from `arr`."
      },
      "requires": [
        "has",
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "scale",
      "code": "function scale(x, minX, maxX, minReturn, maxReturn) {\n  return (x - minX) * (maxReturn - minReturn) / (maxX - minX) + minReturn;\n}",
      "description": "Scales a number using an input range and and an output range to give a proportional output.",
      "params": [
        {
          "name": "x",
          "description": "The value to be scaled.",
          "type": "number"
        },
        {
          "name": "minX",
          "description": "The lower bound of `x`.",
          "type": "number"
        },
        {
          "name": "maxX",
          "description": "The upper bound of `x`.",
          "type": "number"
        },
        {
          "name": "minReturn",
          "description": "The lower bound of the return value which directly corresponds to `minX`.",
          "type": "number"
        },
        {
          "name": "maxReturn",
          "description": "The upper bound of the return value which directly corresponds to `maxX`.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `x` scaled based on the range of `minX` to `maxX` being proportional to `minReturn` to `maxReturn`.  If `x` is within the range of `minX` and `maxX` the return value will be within the range of `minReturn` and `maxReturn`.  If `x` is outside of the range of `minX` to `maxX` then the return value will also be outside of the `minReturn` to `maxReturn` range.  If `minReturn` and `maxReturn` are the same `minReturn` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.scale(0, 3, 5, 8, 10), 5);"
        }
      ]
    },
    {
      "name": "sec",
      "code": "eval('seccos;cscsin;cottan;'.replace(/(...)(?=(...)?;)/g, function(m, name, base, i) {\n  return 'function ' + name + '(a,b){return ' + (base ? '1/' : '') + 'Math.' + (base || name) + '(b?a*'+Math.PI/180+':a)}';\n}));",
      "description": "Determines the secant of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose secant value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The secant of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the secant of `angle` in degrees will be returned."
      },
      "requires": [
        "cos",
        "csc",
        "sin",
        "cot",
        "tan"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "set",
      "code": "function set(obj, opt_name, opt_value, opt_returnObj) {\n  var t1, t2,\n      needsObj = obj == undefined,\n      needsName = opt_name == undefined,\n      needsValue = arguments.length < 3;\n  if (needsObj || needsName || needsValue) {\n    t1 = ['b','a'];\n    t2 = { x: needsObj, y: needsName, z: needsValue };\n    return Function(\n      's,x,y,z',\n      'return function(a,b){return s(x,y,z)}'.replace(/x|y|z/g, function(m){return t2[m]?t1.pop():m}).replace(t1[0] ? '' : ',b', '')\n    )(set, obj, opt_name, opt_value, opt_returnObj);\n  }\n  t1 = obj[opt_name];\n  obj[opt_name] = opt_value;\n  return opt_returnObj ? obj : t1;\n}",
      "description": "Set the value of a property on an object.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose property will be set.",
          "type": "*|undefined"
        },
        {
          "name": "opt_name",
          "description": "Name of the property to be set.",
          "type": "string",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_value",
          "description": "Value to which the property will be set.",
          "type": "*",
          "optional": true,
          "default": ""
        },
        {
          "name": "opt_returnObj",
          "description": "If this is `true`-ish and a partial value is not to be returned then `obj` will be returned.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "If the first 3 arguments are given the previous property value will be returned unless `opt_returnObj` is `true`-ish in which case `obj` will be returned.  If one or more arguments are missing a partial function will be returned that will accept the remaining arguments.  The value of `opt_returnObj` will be ignored for partial functions."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "setAt",
      "code": "function setAt(root, path, value) {\n  var test = testAt(root, path),\n      i = path.length - 1,\n      setIt = i >= 0 && test.length >= i;\n  if (setIt = setIt && !isPrimitive(root = test[i - 1])) {\n    root[path[i]] = value;\n  }\n  return setIt;\n}",
      "description": "Tries to set a value at the given `path` under the given `root` object.",
      "params": [
        {
          "name": "root",
          "description": "Object to start at as the root of the proposed `path`.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "An array of strings and/or numbers that represent the path to be traversed under `root`.",
          "type": "Array"
        },
        {
          "name": "value",
          "description": "The value to be assigned under the specified `path` within the `root` object.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `value` is successfully set under the given path, otherwise `false`."
      },
      "requires": [
        "isPrimitive",
        "testAt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "setCookie",
      "code": "function setCookie(name, value, opt_options) {\n  opt_options = opt_options || {};\n  var maxAge = opt_options['max-age'] || opt_options.maxAge,\n    expires = maxAge ? +new Date + maxAge * 1000 : opt_options.expires,\n    path = opt_options.path,\n    domain = opt_options.domain,\n    secure = opt_options.secure;\n  __DOCUMENT.cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value)\n    + (expires ? \"; expires=\" + (new Date(expires)).toGMTString() : \"\")\n    + (path ? \"; path=\" + path : \"; path=/\")\n    + (domain ? \"; domain=\" + opt_options.domain : \"\")\n    + (secure ? \"; secure\" : \"\");\n  return hasCookie(name);\n}",
      "description": "Takes the name of a cookie and sets its value.",
      "params": [
        {
          "name": "name",
          "description": "Name of the cookie to set.",
          "type": "string"
        },
        {
          "name": "value",
          "description": "Value of the cookie to set.  If not a string, it will be coerced into a string.",
          "type": "string"
        },
        {
          "name": "opt_options",
          "description": "Object whose property values can be used to specify additional options.  If the cookie is meant to expire at a certain time you can set the `expires` property to a `Date` object or the number representation of such a date.  If you want to specify the maximum amount of seconds until the cookie expires you can set the `maxAge` (or `max-age`) property to the number of seconds.  If you want to specify the hosts to which the cookie will be sent you can set the `domain` property.  If a domain is specified, subdomains are always included.  If you want to specify the URL path that under which the cookie will be saved you can specify it in the `path` property.  If you want to set a secure cookie while on a secure site (`https:`) you can set the `secure` property to `true`.",
          "type": "Object",
          "optional": true,
          "default": "{path:'/'}"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean indicating whether or not the cookie was set."
      },
      "requires": [
        "hasCookie"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "shuffle",
      "code": "// Done this way to account for partially or fully empty arrays\nfunction shuffle(arr) {\n  for (var t, j, result = [], l = arr.length, i = l; i--, result[i] = i;);\n  for (i = l; i; ) {\n    j = Math.round(Math.random() * --i);\n    if (i && i != j) {\n      t = result[i];\n      result[i] = result[j];\n      result[j] = t;\n    }\n    if (has(arr, result[i])) {\n      result[i] = arr[result[i]];\n    }\n    else {\n      delete result[i];\n    }\n  }\n  return result;\n}",
      "description": "Creates a new array with the items in a random order.",
      "params": [
        {
          "name": "arr",
          "description": "Array to copy and shuffle.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "Shuffled copy of `arr`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "sign",
      "code": "function sign(x) {\n  x = +x;\n  return x ? x < 0 ? -1 : 1 : x;\n}",
      "description": "Determines whether a value is positive, negative, a form of zero (`-0` or `0`) or not a number.",
      "params": [
        {
          "name": "x",
          "description": "Value that should be interpreted as a number to determine if it is positive or negative.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `NaN` if `x` isn't recognized as a number.  If `x` is zero `x` will be returned.  If `x` is negative `-1` is returned, otherwise `1` is returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test([-Infinity,-3,0,95,Infinity,NaN].map(x => YourJS.sign(x)).join('|'), '-1|-1|0|1|1|NaN');"
        },
        {
          "name": "Negative Zero",
          "code": "test(YourJS.sign(-0), -0);"
        }
      ]
    },
    {
      "name": "signbit",
      "code": "function signbit(x) {\n  return x < 0 || 1 / x < 0;\n}",
      "description": "Specifies whether or not the number is negative (meaning it has a bit indicating the sign of the number).",
      "params": [
        {
          "name": "x",
          "description": "The value to be observed.",
          "type": "number"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if `x` is `-0` or less than `0`, otherwise returns `false`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  [-Infinity,-3.4,-0,0,6,Infinity,NaN].map(x => YourJS.signbit(x)).join('|'),\n  'true|true|true|false|false|false|false'\n);"
        }
      ]
    },
    {
      "name": "sin",
      "code": "",
      "description": "Determines the sine of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose sine value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The sine of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the sine of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "slice",
      "code": "var slice = alias(__EMPTY_ARRAY.slice, 'call');",
      "description": "Slice does not modify the original array, but instead returns a shallow copy of elements from the original array.",
      "params": [
        {
          "name": "array",
          "description": "Array or array-like object to shallow copy.",
          "type": "Array|Arguments|Object"
        },
        {
          "name": "begin",
          "description": "Zero-based index at which to begin extraction.  A negative index can be used, indicating an offset from the end of the sequence. `slice(array,-2)` extracts the last two elements in the sequence.  If `begin` is `undefined`, slice begins from index `0`.",
          "type": "number",
          "optional": true,
          "default": 0
        },
        {
          "name": "end",
          "description": "Zero-based index before which to end extraction. slice extracts up to but not including `end`.  For example, `slice(array,1,4)` extracts the second element through the fourth element (elements indexed 1, 2, and 3).  A negative index can be used, indicating an offset from the end of the sequence. `slice(array,2,-1)` extracts the third element through the second-to-last element in the sequence.  If `end` is omitted, `slice` extracts through the end of the sequence (`array.length`).  If `end` is greater than the length of the sequence, slice extracts through the end of the sequence (`array.length`).",
          "type": "number",
          "optional": true,
          "default": "array.length"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A new array containing the extracted elements."
      },
      "requires": [
        "alias"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "sortBy",
      "code": "function sortBy(array, criteria, opt_comparer) {\n  // If criteria is a string split it on \".\".\n  var criteriaType = typeof criteria;\n  if (criteriaType === 'string') {\n    criteria = criteria.split('.');\n  }\n\n  // If no comparer given use YourJS's compare() function.\n  opt_comparer = opt_comparer || compare;\n\n  // 1. Turn all values in array into meta values containing v (real value) and\n  //    c (value to compare).\n  // 2. Sort the c values.\n  // 3. return the sorted array values (v)\n  return array\n    .map(function(v) {\n      return {\n        v: v,\n        c: criteriaType === 'function'\n          ? criteria(v)\n          : criteria.reduce(function (criteria, key) {\n              if (criteria != undefined) {\n                return criteria[('number' === typeof key && key < 0 && !has(criteria, key) && 'number' === typeof criteria.length) ? criteria.length + key : key];\n              }\n            }, v)\n      };\n    })\n    .sort(function(a, b) { return opt_comparer(a.c, b.c); })\n    .map(function(a) { return a.v; });\n}",
      "description": "Shallow copies and sorts an array given specific criteria.",
      "params": [
        {
          "name": "array",
          "description": "Array to be sorted.",
          "type": "Array"
        },
        {
          "name": "criteria",
          "description": "Criteria by which a shallow copy of `array` will be sorted.  If a string or an array is supplied it will be used as the path to each individual array element that will be keyed off of to do the sort.",
          "type": "string|Array.<string|number>|Function"
        },
        {
          "name": "opt_comparer",
          "description": "Comparison function used to compare each array element criteria.",
          "type": "Function",
          "optional": true,
          "default": "YourJS.compare"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A shallow copy of the array sorted according to the specified criteria and comparison function."
      },
      "requires": [
        "compare",
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "span",
      "code": "function span(first, last, opt_step, opt_mapper) {\n  opt_step = +opt_step || 1;\n  for (var result = [], mult = opt_step < 0 ? -1 : 1; mult * (last - first) >= 0; first += opt_step) {\n    result.push(opt_mapper ? opt_mapper(first) : first);\n  }\n  return result;\n}",
      "description": "Creates an array with the span of numbers going from `first` and ending at `last` if possible depending on the specified step value.",
      "params": [
        {
          "name": "first",
          "description": "First number to be processed for the returned array.",
          "type": "number"
        },
        {
          "name": "last",
          "description": "Last number to be processed for the returned array.",
          "type": "number"
        },
        {
          "name": "opt_step",
          "description": "Defaults to `1` if not given or if `0` or `NaN` is specified.  The difference between each subsequent number to be processed for the returned array.",
          "type": "number",
          "optional": true,
          "default": "1"
        },
        {
          "name": "opt_mapper",
          "description": "Function to call for each number in the sequence and whose return value will be used as the value added to the returned array.  If specified this function will be called for every number in the span, receiving it as the one and only argument.",
          "type": "Function",
          "optional": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array containing the sequence of numbers starting at `first` and ending at `last`.  If `first` is less than `last` and `opt_step` is less than `0` or if `last` is less than `first` and `opt_step` is greater than `0` an empty array will be returned.  If `opt_mapper` is given the array will contain the sequence of mapped."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfDay",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and day of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and day.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and day contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfFridayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Friday to Thursday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Friday to Thursday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Friday to Thursday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfHour",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, day, and hour of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, and hour.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, day, and hour contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfMinute",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, day, hour, and minute of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, hour, and minute.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, day, hour, and minute contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfMondayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Monday to Sunday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Monday to Sunday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Monday to Sunday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfMonth",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year and month of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year and month.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year and month contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var now = new Date;\nvar d = new Date(now.getFullYear(), now.getMonth(), (32 - now.getDate()) % 28 || 1);\nvar span = YourJS.spanOfMonth(now);\ntest(span[0] <= d && d <= span[1], true);"
        }
      ]
    },
    {
      "name": "spanOfSaturdayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Saturday to Friday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Saturday to Friday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Saturday to Friday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfSecond",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, day, hour, minute, and second of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, hour, minute, and second.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, day, hour, minute, and second contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfSundayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Sunday to Saturday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Sunday to Saturday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Sunday to Saturday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfThursdayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Thursday to Wednesday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Thursday to Wednesday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Thursday to Wednesday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfTuesdayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Tuesday to Monday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Tuesday to Monday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Tuesday to Monday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfWednesdayWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Wednesday to Tuesday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Wednesday to Tuesday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Wednesday to Tuesday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfWeek",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year, month, and week (Sunday to Saturday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Sunday to Saturday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year, month, and week (Sunday to Saturday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "spanOfYear",
      "code": "",
      "description": "Determines the earliest and latest date-times of the year of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Array.<Date>",
        "description": "An array of two dates:  the earliest and latest date-times of the year contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "splice",
      "code": "function splice(arrOrStr, start, opt_length, opt_replacement) {\n  opt_length = opt_length != undefined\n    ? opt_length < 0\n      ? arrOrStr.length - start + opt_length\n      : opt_length\n    : Infinity;\n  start = start < 0 ? Math.max(0, arrOrStr.length + start) : start;\n  if (isArrayLike(arrOrStr)) {\n    return slice(arrOrStr, 0, start).concat(opt_replacement || [], slice(arrOrStr, start + opt_length));\n  }\n  return arrOrStr.slice(0, start)\n    + (opt_replacement === undefined ? '' : opt_replacement)\n    + arrOrStr.slice(start + opt_length);\n}",
      "description": "Duplicates an array or a string and adds and/or removes one or more values from it. NOTE: This is different from the traditional splice function because it doesn't modify the array, but rather it returns a modified duplicate.",
      "params": [
        {
          "name": "arrOrStr",
          "description": "The array or string to be duplicated and modified.",
          "type": "Array|string"
        },
        {
          "name": "start",
          "description": "The position at which to start modifying `arrOrStr`. If this number is negative the position will be calculated from the end of `arrOrStr`.",
          "type": "number"
        },
        {
          "name": "opt_length",
          "description": "Indicates the amount of indices that should be removed from `arrOrStr`. If negative this will be used as if it were an index counting from the end of `arrOrStr`.",
          "type": "number",
          "optional": true,
          "default": "Infinity"
        },
        {
          "name": "opt_replacement",
          "description": "If specified, this will be inserted at `start`. If `arrOrStr` is an array, this should be an array of the values to insert at `start`. If `arrOrStr` is a string, this should be the string to insert at `start`.",
          "type": "Array|string",
          "optional": true
        }
      ],
      "return": {
        "type": "Array|string",
        "description": "The modified duplicate of `arrOrStr`."
      },
      "requires": [
        "slice",
        "isArrayLike"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple Array Test",
          "code": "test(\n  JSON.stringify(YourJS.splice([1,5,4,5], 1, -1, [3])),\n  '[1,3,5]'\n);"
        },
        {
          "name": "Simple String Test",
          "code": "test(\n  YourJS.splice('Hello mom!', 6, -1, 'world'),\n  'Hello world!'\n);"
        }
      ]
    },
    {
      "name": "splitPath",
      "code": "function splitPath(path) {\n  return (path + '.').match(/([^\\\\.]|\\\\.)*\\./g).map(function(x) {\n    return x.slice(0, -1).replace(/\\\\(.)/g, '$1');\n  });\n}",
      "description": "Takes a path as a string and splits it into an array.",
      "params": [
        {
          "name": "path",
          "description": "The string path that will be split into its parts.",
          "type": "string"
        }
      ],
      "return": {
        "type": "Array<string>",
        "description": "The string path that was passed in as an array of strings."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  JSON.stringify(YourJS.splitPath('1.2.3\\\\.4.5')),\n  JSON.stringify(['1', '2', '3.4', '5'])\n);"
        }
      ]
    },
    {
      "name": "spread",
      "code": "function spread(fn) {\n  return fn.apply(this, slice(arguments, 1).reduce(function(args, arg) {\n    return args.concat(isArrayLike(arg) ? slice(arg) : [arg]);\n  }, []));\n}",
      "description": "Calls a function while flattening first-level array-like arguments so as the spread those individual values and use them as individual arguments.",
      "params": [
        {
          "name": "fn",
          "description": "Function to which the spread values will be passed.",
          "type": "Function"
        },
        {
          "name": "args",
          "description": "Arguments that will be passed to `fn`.  If any of the arguments are arrays or array-like they will be flattened and passed to `fn` so as the spread those values.",
          "type": "*",
          "optional": true,
          "rest": true
        }
      ],
      "return": {
        "type": "*",
        "description": "Return value after calling `fn` with the specified `args`."
      },
      "requires": [
        "isArrayLike",
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "function sum(a, b) {\n  return a + (arguments.length < 3 ? b : sum.apply(this, [].slice.call(arguments, 1)));\n}\ntest(YourJS.spread(sum,1,2,3,[4,5],6,[7,8,9]), sum(1,2,3,4,5,6,7,8,9));"
        }
      ]
    },
    {
      "name": "spreadNew",
      "code": "function spreadNew(constructor, args) {\n  return new(constructor.bind.apply(constructor, [null].concat(slice(args))));\n}",
      "description": "Passes an array as the arguments to a construct thusly allowing a variable number of arguments to be passed to the constructor.",
      "params": [
        {
          "name": "constructor",
          "description": "Constructor function to be called with a variable number of arguments.",
          "type": "Function"
        },
        {
          "name": "args",
          "description": "Array or array-like object that will be treated as the arguments to pass to `constructor`.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "*",
        "description": "Constructed object."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfDay",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and day of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and day.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and day contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfFridayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Friday to Thursday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Friday to Thursday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Friday to Thursday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfHour",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, day, and hour of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, and hour.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, day, and hour contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfMinute",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, day, hour, and minute of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, hour, and minute.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, day, hour, and minute contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfMondayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Monday to Sunday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Monday to Sunday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Monday to Sunday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfMonth",
      "code": "",
      "description": "Determines the earliest date-time of the year and month of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year and month.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year and month contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfSaturdayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Saturday to Friday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Saturday to Friday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Saturday to Friday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfSecond",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, day, hour, minute, and second of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, day, hour, minute, and second.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, day, hour, minute, and second contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfSundayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Sunday to Saturday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Sunday to Saturday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Sunday to Saturday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfThursdayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Thursday to Wednesday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Thursday to Wednesday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Thursday to Wednesday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfTuesdayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Tuesday to Monday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Tuesday to Monday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Tuesday to Monday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfWednesdayWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Wednesday to Tuesday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Wednesday to Tuesday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Wednesday to Tuesday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfWeek",
      "code": "",
      "description": "Determines the earliest date-time of the year, month, and week (Sunday to Saturday) of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year, month, and week (Sunday to Saturday).",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year, month, and week (Sunday to Saturday) contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startOfYear",
      "code": "",
      "description": "Determines the earliest date-time of the year of a specific `Date` object.",
      "params": [
        {
          "name": "date",
          "description": "The object from which to pull the year.",
          "type": "Date"
        }
      ],
      "return": {
        "type": "Date",
        "description": "The earliest date-time of the year contained by `date`."
      },
      "requires": [
        "isSameYear"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "startsWith",
      "code": "// Similar to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n// Different from String.prototype.startsWith() because 3rd arg can be negative.\nfunction startsWith(string, target, opt_fromIndex) {\n  opt_fromIndex = opt_fromIndex || 0;\n  if (opt_fromIndex < 0) {\n    opt_fromIndex += string.length;\n    if (opt_fromIndex < 0) {\n      opt_fromIndex = 0;\n    }\n  }\n  return string.slice(opt_fromIndex, opt_fromIndex + ('' + target).length) === target;\n}",
      "description": "Determines whether a string starts with the characters of a specified string.",
      "params": [
        {
          "name": "string",
          "description": "The string that will be searched.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "The characters to be searched for at the start of `string`.",
          "type": "string"
        },
        {
          "name": "opt_fromIndex",
          "description": "The position in `string` at which to begin searching for `target`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating whether or not `target` is at the start of `string`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "step",
      "code": "// Example at:  https://www.yourjs.com/console/?gist=b93e3d6df9070b4f5fee28a9331c626d&file=step-example.js\nfunction step(array, opt_stepValue, opt_callback, opt_startIndex) {\n  opt_stepValue = ~~opt_stepValue || 1;\n  var count = array.length;\n  var i = (opt_startIndex == undefined || isNaN(opt_startIndex = ~~opt_startIndex))\n    ? opt_stepValue < 0\n      ? count - 1\n      : 0\n    : opt_startIndex;\n  i = (~~i % count + count) % count;\n  for (var newStep, result = []; 0 <= i && i < array.length; i += opt_stepValue) {\n    newStep = opt_callback && opt_callback(array[i], i, array);\n    result.push(array[i]);\n    opt_stepValue = newStep != undefined ? ~~newStep || 0 : opt_stepValue;\n  }\n  return result;\n}",
      "description": "Allows for an array or an array-like structure to be stepped through in the order specified after each iteration.",
      "params": [
        {
          "name": "array",
          "description": "Array or array-like object to step through.",
          "type": "Array"
        },
        {
          "name": "opt_stepValue",
          "description": "If given this will indicate the amount by which to increase the index of the value to be checked next.  For example, if you always want to traverse an array backwards you can supply `-1`.",
          "type": "number",
          "optional": true,
          "default": "1"
        },
        {
          "name": "opt_callback",
          "description": "If not given `opt_stepValue` will be the only value used for the step value.  If given this function will be called on each iteration.  This will be passed (1) the value, (2) the index of the value and (3) `array`.  The return value will be used as the new step value.  If nothing, `undefined` or `null` is returned then `opt_stepValue` will be used as the next step value.",
          "type": "Function",
          "optional": true
        },
        {
          "name": "opt_startIndex",
          "description": "If not given this will default to `array.length - 1` if `opt_stepValue` is `-1`, otherwise this will default to `0`.  This represents the starting index.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of the values found in the indices that were traversed."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Reverse",
          "code": "var arr = [1,2,3,4,5,6];\nvar arr2 = YourJS.step(arr, -1);\nvar arrCheck = [6,5,4,3,2,1];\ntest(JSON.stringify(arr2), JSON.stringify(arrCheck));"
        }
      ]
    },
    {
      "name": "sub",
      "code": "function sub(template, opt_subs, opt_funcs) {\n  opt_subs = opt_subs || __GLOBAL;\n  opt_funcs = opt_funcs || YourJS;\n  for (\n    var result;\n    result !== template;\n    template = template.replace(\n      /\\{([\\w\\$]+)(?:\\?((?:\\\\.|[^\\\\\\{\\}:])*):((?:\\\\.|[^\\\\\\{\\}:])*)(?::((?:\\\\.|[^\\\\\\{\\}:])*))?|#([\\w\\$]+))?\\}/ig,\n      function(match, arg, multi, one, none, fn) {\n        if (has(opt_subs, arg)) {\n          arg = opt_subs[arg];\n          if ('function' == typeof arg) {\n            arg = arg(multi, one, none, match);\n          }\n          match = multi === undefined ? arg : (arg == 1 ? one : ((!arg && none !== undefined) ? none : multi));\n          if (fn != undefined) {\n            fn = fn ? opt_funcs[fn] : opt_funcs;\n            if ('function' == typeof fn) {\n              match = fn(match);\n            }\n          }\n        }\n        return match;\n      }\n    )\n  ) {\n    result = template;\n  }\n  return result.replace(/\\\\(\\W)/g, '$1');\n}",
      "description": "Substitute values into strings where the corresponding placeholders have been entered.",
      "params": [
        {
          "name": "template",
          "description": "The string containing placeholders to be filled in and returned. A placeholder must correspond to a value in `opt_subs` and its name must be surrounded in curly braces (eg. `\"Hello {name}!\"` contains the `name` placeholder). If a placeholder refers to a number, a ternary operator can be used (eg. `\"You have {apples} apple{apples?s:}\"`). What appears between the `?` and the `:` will replace the placeholder if the variable before the `?` is not `1`. What appears after the `:` will replace the placeholder if the variable before the `?` is `1`. A 4-ary (AKA quaterary) operator can also be used if a placeholder refers to a number (eg. `\"You have {apples?{apples}:one:no} apple{apples?s:}\"`). When using a 4-ary operator, whatever appears after the second `:` will replace the placeholder if the variable before the `?` is `0`.  If a placeholder is not ternary or 4-ary but ends with `#`, `opt_funcs` will be called on the value and the return value will be used.  If a placeholder is not ternary or 4-ary but ends with `#` followed by a name (eg. `#ordinalize`), the function with that property name under `opt_funcs` will be called for the value and the return value will replace the placeholder.  If a placeholder evaluates to a function the function will be called all of the ternary or 4-ary values as arguments.  Nested expressions are supported.",
          "type": "string"
        },
        {
          "name": "opt_subs",
          "description": "Array or object from which to pull the values to be inserted into `template`.",
          "type": "Array|Object",
          "optional": true,
          "default": "global"
        },
        {
          "name": "opt_funcs",
          "description": "If this is a function it can be used to modify the values filled in within `template`.  If this is an object or an array its properties or array items can be referenced to modify the values filled in within `template`.",
          "type": "Array.<Function>|Object.<Function>|Function",
          "optional": true,
          "default": "YourJS"
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns `template` with all of the valid placeholders filled in with their substitutions as found in `opt_subs`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "subtract",
      "code": "",
      "description": "Finds the difference of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be subtracted from `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to subtract from `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given the difference of the two will be returned.  Otherwise a partial function will be returned which when called will accept one number and will return the number passed to the partial function subtracted from `number1`."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "suffix",
      "code": "function suffix(str, strSuffix, opt_rgxTester) {\n  return str == undefined\n    ? function(str) { return suffix(str, strSuffix, opt_rgxTester); }\n    : (opt_rgxTester ? !opt_rgxTester.test(str) : str.slice(-strSuffix.length) != strSuffix)\n      ? str + strSuffix\n      : str;\n}",
      "description": "Always ensures that a string ends with a specific substring.",
      "params": [
        {
          "name": "str",
          "description": "This will be the string to which the suffix will be appended unless the test proves that it doesn't need to be appended.  Specifying `undefined` or `null` will cause a partial function to be returned.",
          "type": "string|undefined|null"
        },
        {
          "name": "strSuffix",
          "description": "This will be the suffix to add to `str` if it needs to be added.",
          "type": "string",
          "optional": false,
          "default": ""
        },
        {
          "name": "opt_rgxTester",
          "description": "Regular expression to test against the string to be suffixed.  If the string tests negative against this regular expression `strSuffix` will be appended to the end of it.",
          "type": "RegExp",
          "optional": true
        }
      ],
      "return": {
        "type": "string|function(string)",
        "description": "If `str` is not given a partial function will be returned which will await the string value of `str`.  If `opt_rgxTester` isn't given, the `str` will be returned and it will be suffixed with `strSuffix` if it isn't already at the end of it.  If `opt_rgxTester` is given and `str` tests negative against it `str` suffixed with `strSuffix` will be returned.  Otherwise `str` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var msg1 = 'Hello', msg2 = 'Hello!';\ntest(\n  YourJS.suffix(msg1, '!') + YourJS.suffix(msg2, '!'),\n  'Hello!Hello!'\n);"
        },
        {
          "name": "Partial",
          "code": "var path1 = 'http://google.com', path2 = 'http://bing.com/';\nvar endWithSlash = YourJS.suffix(undefined, '/');\ntest(\n  endWithSlash(path1) + ' ' + endWithSlash(path2),\n  'http://google.com/ http://bing.com/'\n);"
        },
        {
          "name": "RegExp",
          "code": "var msg1 = 'Hello', msg2 = 'Cool!', endWithPunct = YourJS.suffix(undefined, '.', /[!.?]/);\ntest (\n  endWithPunct(msg1) + ' ' + endWithPunct(msg2),\n  'Hello. Cool!'\n);"
        }
      ]
    },
    {
      "name": "suffixFileSize",
      "code": "var suffixFileSize;\n(function(Math, SUFFIXES) {\n  suffixFileSize = function(count, opt_countInBits) {\n    var div = opt_countInBits ? 3 : 10,\n        base = opt_countInBits ? 10 : 2,\n        level = ~~Math.min(Math['log' + base](count < 0 ? -count : count) / div, 8);\n    count = (count / Math.pow(base, div * level)).toFixed(2).replace(/\\.?0+$/, '')\n      + ' ' + SUFFIXES[level];\n    return opt_countInBits ? count : count.toUpperCase();\n  };\n})(Math, ['b','kb','Mb','Gb','Tb','Pb','Eb','Zb','Yb']);",
      "description": "Used to make a file size human readable.  Takes the number of bytes or bits and converts it into a string indicating the number in the appropriate range (eg. KB, MB, etc.).",
      "params": [
        {
          "name": "count",
          "description": "Number of bytes or bits to represent as a string.",
          "type": "number"
        },
        {
          "name": "opt_countInBits",
          "description": "Specifies whether `count` is given in bits instead of bytes.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "string",
        "description": "A string indicating `count` with the appropriate measure (eg. kb, Mb, etc.)."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "sum",
      "code": "function sum(arr) {\n  for (var result = 0, i = arr.length; i--; result += arr[i]) {}\n  return result;\n}",
      "description": "Gets the sum of an array of numbers.",
      "params": [
        {
          "name": "arr",
          "description": "Array of numbers to be summed up.",
          "type": "Array.<number>"
        }
      ],
      "return": {
        "type": "number",
        "description": "Sum of the array of numbers."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.sum([1,2,3,4,5,6,7,8,9,10]), 55);"
        }
      ]
    },
    {
      "name": "swapProps",
      "code": "function swapProps(target, source, props, opt_dontDelete) {\n  source = Object(source);\n  for (var t, copyToSource, prop, oTarget = Object(target), i = props.length; i--;) {\n    prop = props[i];\n    copyToSource = prop in oTarget;\n    t = oTarget[prop];\n    if ((prop in source) || opt_dontDelete) {\n      oTarget[prop] = source[prop];\n    }\n    else {\n      delete oTarget[prop];\n    }\n    if (copyToSource || opt_dontDelete) {\n      source[prop] = t;\n    }\n    else {\n      delete source[prop];\n    }\n  }\n  return target;\n}",
      "description": "Swaps the specified properties between the target object and the source object.",
      "params": [
        {
          "name": "target",
          "description": "Target object from which the specified properties will be swapped.",
          "type": "*"
        },
        {
          "name": "source",
          "description": "Source object from which the specified properties will be swapped.",
          "type": "*"
        },
        {
          "name": "keys",
          "description": "Array of keys for the properties that should be swapped between `source` and `target`.",
          "type": "Array"
        },
        {
          "name": "opt_dontDelete",
          "description": "Indicates whether properties that dont exist should be deleted between objects.  If `true`, non-existent properties will be set to `undefined`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "Returns a reference to `target`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var a = {a: 1, b: 2};\nvar b = {b: 3, c: 4};\nYourJS.swapProps(a, b, ['b', 'c']);\ntest(JSON.stringify([\n  Object.entries(a).sort((x,y)=>x[0]<y[0]?-1:1),\n  Object.entries(b).sort((x,y)=>x[0]<y[0]?-1:1)\n]),'[[[\"a\",1],[\"b\",3],[\"c\",4]],[[\"b\",2]]]');"
        },
        {
          "name": "Simple dont delete",
          "code": "var a = {a: 1, b: 2};\nvar b = {b: 3, c: 4};\nYourJS.swapProps(a, b, ['b', 'c'], true);\ntest(JSON.stringify([\n  Object.entries(a).sort((x,y)=>x[0]<y[0]?-1:1),\n  Object.entries(b).sort((x,y)=>x[0]<y[0]?-1:1)\n]),'[[[\"a\",1],[\"b\",3],[\"c\",4]],[[\"b\",2],[\"c\",null]]]');"
        }
      ]
    },
    {
      "name": "tan",
      "code": "",
      "description": "Determines the tangent of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose tangent value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The tangent of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the tangent of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "testAt",
      "code": "function testAt(root, path) {\n  for (var result = [], i = 0, l = path.length; i < l; i++) {\n    if (root != undefined && has(root, path[i])) {\n      result[i] = root = root[path[i]];\n    }\n    else {\n      break;\n    }\n  }\n  return result;\n}",
      "description": "Tests a given `path` under the given `root` object and returns the values at each step of that `path`.",
      "params": [
        {
          "name": "root",
          "description": "Object to start at as the root of the proposed `path`.",
          "type": "*"
        },
        {
          "name": "path",
          "description": "An array of strings and/or numbers that represent the path to be tested under `root`.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array having a length less than or equal to that of `path` where each will be the value for the corresponding `path` value."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "throttle",
      "code": "",
      "description": "Creates a throttled version of a function which will only be executable once per every specified wait period.",
      "params": [
        {
          "name": "fn",
          "description": "The function which will esentially be rate-limited.",
          "type": "Function"
        },
        {
          "name": "msBetweenCalls",
          "description": "The amount of time to wait between calls.",
          "type": "number"
        },
        {
          "name": "opt_leading",
          "description": "If `true` the `fn` function will only be invoked on the initial calls if the specified time has elapsed since the last invocation.  If `false` the `fn` function will only be invoked on the trailing calls.  If not specified or if specified as `null` or `undefined` the initial calls and the trailing calls will be used to invoke `fn`.",
          "type": "boolean",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The throttled version of `fn` function."
      },
      "requires": [
        "debounce"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "time",
      "code": "function time(fn, times) {\n  var timesIsFunction = 'function' === typeof times;\n  return function() {\n    var startTime = +new Date,\n        result = fn.apply(this, arguments),\n        endTime = +new Date,\n        timingData = {\n          elapsed: endTime - startTime,\n          start: startTime,\n          end: endTime,\n          returnValue: result,\n          'function': fn,\n          'this': this,\n          'arguments': arguments\n        };\n    timesIsFunction ? times(timingData) : times.push(timingData);\n    return result;\n  };\n}",
      "description": "Creates timed functions which on every successful execution will indicate the amount of time it took to execute.",
      "params": [
        {
          "name": "func",
          "description": "Function to wrap and be timed.",
          "type": "Function"
        },
        {
          "name": "times",
          "description": "If this is an array, on each successful execution of `func` an object will be added to the end containing the following properties:  `elapsed` (time taken), `start` (starting time stamp), `end` (ending time stamp), `returnValue`, `function` (a reference to `func`), `this` (context object passed to `func`), and `arguments` (those passed to `func`).  If this is a function, upon successful execution of `func` it will be called and passed the aforementioned object.",
          "type": "Array|Function"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapped version of `func` which will take the context and arguments and pass them to `func` and then return the return value from `func`.  All timing information will be given to `times`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "timeAgo",
      "code": "function timeAgo(dateTime, opt_currDateTime) {\n  opt_currDateTime = new Date(opt_currDateTime || new Date) - new Date(dateTime);\n  return '31536e6year2592e6month864e5day36e5hour6e4minute1e3second'.replace(/(\\d+e\\d)([a-z]+)/g, function(m, ms, interval) {\n    if (dateTime != undefined) {\n      ms = opt_currDateTime / +ms;\n      if (ms >= 1 || interval == 'second') {\n        dateTime = undefined;\n        return ~~ms + ' ' + interval + (~~ms - 1 ? 's' : '') + ' ago';\n      }\n    }\n    return '';\n  }) || undefined;\n}",
      "description": "Gets a string indicating how long ago a given date was in the largest unit possible.",
      "params": [
        {
          "name": "dateTime",
          "description": "Date in the past.",
          "type": "Date"
        },
        {
          "name": "opt_currDateTime",
          "description": "Current date.  If not given defaults to the current date and time.",
          "type": "Date",
          "optional": true,
          "default": "new Date()"
        }
      ],
      "return": {
        "type": "string",
        "description": "A string indicating in the largest unit possible how long ago `dateTime` happened compared to `opt_currDateTime`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  YourJS.timeAgo(new Date(2016,3,4), new Date(2017,1,2)),\n  '10 months ago'\n)"
        }
      ]
    },
    {
      "name": "titleCase",
      "code": "var titleCase;\n(function(RGX_WORD) {\n  titleCase = function (str, opt_fnFilter) {\n    return str.replace(RGX_WORD, function(word, start, rest, index) {\n      return (!opt_fnFilter || opt_fnFilter(word, index, str) ? start.toUpperCase() : start) + rest;\n    });\n  };\n})(/(\\S)((?:\\B\\S)*)/g);",
      "description": "Capitalizes the first letter of each word in a string. Also commonly known as `toProperCase()`.",
      "params": [
        {
          "name": "str",
          "description": "The string which will be title cased.",
          "type": "string"
        },
        {
          "name": "opt_fnFilter",
          "description": "If specified, this function will be passed every word (along with the position and the original string) and should return `true` if the word should be title cased, otherwise `false` should be returned.",
          "type": "function(string, number, string)",
          "optional": true
        }
      ],
      "return": {
        "type": "string",
        "description": "`str` with all of the 1st letter of each word capitalized (unless filtered out by `opt_fnFilter`)."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "toArray",
      "code": "function toArray(o) {\n  return arguments.length ? isArrayLike(o) ? slice(o) : [o] : [];\n}",
      "description": "Turns anything into an array.",
      "params": [
        {
          "name": "o",
          "description": "Any value to either convert to an array or wrap in an array.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "If no arguments were passed an empty array is returned.  If the argument passed was array-like it will be returned as an `Array`.  Otherwise the argument passed will simply be returned within an array."
      },
      "requires": [
        "isArrayLike",
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "toBase",
      "code": "function toBase(opt_num, base) {\n  return base\n    ? (+opt_num).toString(base)\n    : function(x) { return (+x).toString(opt_num); };\n}",
      "description": "Converts the given number into a string representing the number in the specified base.",
      "params": [
        {
          "name": "opt_num",
          "description": "The number that should be represented in a specific base.",
          "type": "number",
          "optional": true
        },
        {
          "name": "base",
          "description": "A number in the range from `2` to `36`.",
          "type": "number"
        }
      ],
      "return": {
        "type": "string|Function",
        "description": "If only one argument is given a partial function will be returned which will take that original argument as `base`, will accept one argument when called which will be interpreted as the number to convert to the specified `base`.  Otherwise converts the first arguments to the specified `base` and returns the number as a string."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "toggle",
      "code": "function toggle(array, valuesToToggle, opt_fnTestEquality) {\n  array = slice(array);\n  valuesToToggle = slice(valuesToToggle);\n  for (var j, i = array.length, valuesCount = valuesToToggle.length; i--;) {\n    for (j = valuesCount; j--;) {\n      if (opt_fnTestEquality ? opt_fnTestEquality(array[i], valuesToToggle[j]) : (array[i] === valuesToToggle[j])) {\n        array.splice(i, 1);\n        valuesToToggle.splice(j, 1);\n        valuesCount--;\n      }\n    }\n  }\n  return array.concat(valuesToToggle);\n}",
      "description": "Toggles values in an array, adding the values that are missing from the array and removing those that are there.",
      "params": [
        {
          "name": "array",
          "description": "The array whose values should be toggled. A copy of this array with the values toggled will be returned.",
          "type": "Array"
        },
        {
          "name": "valuesToToggle",
          "description": "The array of values to either add to (if they are present) or remove from (if they are missing) `array`.",
          "type": "Array"
        },
        {
          "name": "opt_fnTestEquality",
          "description": "If not given strict equality (`===`) will be used to compare values. If specified, this function will be used to determine if two values are equal. The first argument will be the value within `array` to be tested and the second will be the value within `valuesToToggle` to be tested.",
          "type": "Function",
          "optional": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "A duplicate of `array` with the common values of `valuesToToggle` removed and the missing values added."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var evens = [2,4,6,8], nums = [2,3,4];\ntest(\n  YourJS.toggle(evens, nums).join(','),\n  '6,8,3'\n);"
        }
      ]
    },
    {
      "name": "toString",
      "code": "function toString() {\n  return 'YourJS v' + __VERSION + ' (' + __VARIABLE_NAME + ')';\n}",
      "required": true,
      "description": "Gets the information for this version of YourJS.",
      "return": {
        "type": "string",
        "description": "A quick summary of the YourJS object simply indicating the version and the variable name."
      },
      "params": [],
      "requires": [],
      "tests": []
    },
    {
      "name": "trim",
      "code": "function trim(opt_str, opt_chars) {\n  return opt_str == undefined\n    ? function(str) { return trimLeft(trimRight(str, opt_chars), opt_chars); }\n    : trimLeft(trimRight(opt_str, opt_chars), opt_chars);\n}",
      "description": "Removes all whitespace characters or the specified characters from the beginning of a string.",
      "params": [
        {
          "name": "opt_str",
          "description": "String to return with all whitespace characters or specified characters stripped from the beginning and end of it.",
          "type": "string",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_chars",
          "description": "Characters to remove from the beginning of the string.",
          "type": "string",
          "optional": true,
          "default": "\"\\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\""
        }
      ],
      "return": {
        "type": "Function|string",
        "description": "If `opt_str` is not given a function will be returned that will take one string argument and trim the beginning and end of that string using the characters from `opt_chars`. If `opt_str` is given it will be returned with all leading and trailing characters found in `opt_chars` stripped off."
      },
      "requires": [
        "trimLeft",
        "trimRight"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "trimLeft",
      "code": "function trimLeft(opt_str, opt_chars) {\n  opt_chars = 'string' == typeof opt_chars\n    ? new RegExp('^[' + quoteRegExp(opt_chars) + ']+')\n    : /^[\\t-\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+/;\n  return opt_str == undefined ? function(str) { return str.replace(opt_chars, ''); } : opt_str.replace(opt_chars, '');\n}",
      "description": "Removes all whitespace characters or the specified characters from the beginning of a string.",
      "params": [
        {
          "name": "opt_str",
          "description": "The string to return with all whitespace characters or specified characters stripped from the beginning of it.",
          "type": "string",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_chars",
          "description": "Characters to remove from the beginning of the string.",
          "type": "string",
          "optional": true,
          "default": "\"\\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\""
        }
      ],
      "return": {
        "type": "Function|string",
        "description": "If `opt_str` is not given a function will be returned that will take one string argument and trim the beginning of that string using the characters from `opt_chars`.  If `opt_str` is given it will be returned with all leading characters found in `opt_chars` stripped off."
      },
      "requires": [
        "quoteRegExp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "trimRight",
      "code": "function trimRight(opt_str, opt_chars) {\n  opt_chars = 'string' == typeof opt_chars\n    ? new RegExp('[' + quoteRegExp(opt_chars) + ']+$')\n    : /[\\t-\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+$/;\n  return opt_str == undefined ? function(str) { return str.replace(opt_chars, ''); } : opt_str.replace(opt_chars, '');\n}",
      "description": "Removes all whitespace characters or the specified characters from the end of a string.",
      "params": [
        {
          "name": "opt_str",
          "description": "The string to return with all whitespace characters or specified characters stripped from the end of it.",
          "type": "string",
          "optional": true
        },
        {
          "name": "opt_chars",
          "description": "Characters to remove from the end of the string.",
          "type": "string",
          "optional": true,
          "default": "\"\\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\""
        }
      ],
      "return": {
        "type": "Function|string",
        "description": "If `opt_str` is not given a function will be returned that will take one string argument and trim the end of that string using the characters from `opt_chars`.  If `opt_str` is given it will be returned with all trailing characters found in `opt_chars` stripped off."
      },
      "requires": [
        "quoteRegExp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "trunc",
      "code": "function trunc(num) {\n  return Math[num < 0 ? 'ceil' : 'floor'](num);\n}",
      "description": "Only gets the integral part of a number.",
      "params": [
        {
          "name": "num",
          "description": "The number for which only the integral part shall be returned.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The integral part of `num` while keeping the sign."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "tryUntil",
      "code": "function tryUntil(fn, opt_timeout, opt_interval) {\n  var start = new Date, iteration = 0, self = this;\n  opt_timeout = opt_timeout == undefined ? Infinity : opt_timeout;\n  opt_interval = opt_interval == undefined ? 100 : opt_interval;\n  function fnWrapper() {\n    try {\n      fn.call(self, ++iteration);\n      return true;\n    }\n    catch (e) {\n      if (new Date - start < opt_timeout) {\n        setTimeout(fnWrapper, opt_interval);\n      }\n      return false;\n    }\n  }\n  return fnWrapper();\n}",
      "description": "Keeps trying to execute a function until it has success or until the timeout is reached.",
      "params": [
        {
          "name": "fn",
          "description": "Function to keep trying to run.",
          "type": "Function"
        },
        {
          "name": "opt_timeout",
          "description": "Amount of milliseconds to wait before giving up on running `fn`.",
          "type": "number",
          "optional": true,
          "default": "Infinity"
        },
        {
          "name": "opt_interval",
          "description": "Amount of milliseconds to wait between each try.",
          "type": "number",
          "optional": true,
          "default": "100"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` is returned if no error is thrown the first time `fn` is called.  Otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "typeOf",
      "code": "var kindsOf, typeOf;\n(function (arrObjectTypes, arrLen) {\n  kindsOf = function (value) {\n    var isProto = isPrototype(value),\n      result = [],\n      typeName = __EMPTY_OBJECT.toString.call(value).slice(8, -1);\n    if (isPrimitive(value)) {\n      result.push('*primitive', typeName.toLowerCase());\n    }\n    else if (typeName !== 'Object') {\n      result.push('Object');\n    }\n    if (value != undefined) {\n      result.push(typeName);\n    }\n    if (typeName === 'Object') {\n      value = value.constructor;\n      typeName = (value && value.name) || '*unknown';\n      for (i = 0; i < arrLen; i += 2) {\n        if (value === arrObjectTypes[i]) {\n          typeName = arrObjectTypes[i + 1];\n          break;\n        }\n      }\n      if (typeName !== 'Object') {\n        result.push(typeName);\n      }\n    }\n    if (isProto) {\n      result.push('*prototype');\n    }\n    return result;\n  };\n  typeOf = function (value, opt_typeNameToAdd) {\n    if (opt_typeNameToAdd) {\n      for (var i = 0; i < arrLen; i += 2) {\n        if (value === arrObjectTypes[i]) {\n          return false;\n        }\n      }\n      arrLen += 2;\n      arrObjectTypes.push(value, opt_typeNameToAdd);\n      return true;\n    }\n    value = kindsOf(value);\n    return value[value.length - 1];\n  };\n})([], 0);",
      "description": "Either gets the type of a value or adds a constructor registering its custom type name.",
      "params": [
        {
          "name": "value",
          "description": "A value whose type name will be returned.  Alternatively if `opt_typeNameToAdd` is passed this must be the constructor for the corresponding type name.",
          "type": "*"
        },
        {
          "name": "opt_typeNameToAdd",
          "description": "If specified, `value` will be looked for within an array of all known constructors and if not found a new entry will be added along with this given type name.",
          "type": "string",
          "optional": true
        }
      ],
      "return": {
        "type": "string|boolean",
        "description": "If `opt_typeNameToAdd` was omitted a string representation of `value`'s type usually capitalized unless `\"null\"` or `\"undefined\"` is returned.  If `opt_typeNameToAdd` is given, the constructor passed as `value` will be searched and a boolean indicating whether or not it needed to be added will be returned."
      },
      "requires": [
        "isPrimitive",
        "isPrototype",
        "kindsOf"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "uint16",
      "code": "",
      "description": "Takes a number and converts it to a 16-bit unsigned integer.",
      "params": [
        {
          "name": "number",
          "description": "Number to be converted to a 16-bit unsigned integer.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the specified number as a 16-bit unsigned integer."
      },
      "requires": [
        "int8"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.uint16(-543), Math.pow(2, 16) - 543)"
        }
      ]
    },
    {
      "name": "uint32",
      "code": "",
      "description": "Takes a number and converts it to a 32-bit unsigned integer.",
      "params": [
        {
          "name": "number",
          "description": "Number to be converted to a 32-bit unsigned integer.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the specified number as a 32-bit unsigned integer."
      },
      "requires": [
        "int8"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.uint32(-100), Math.pow(2, 32) - 100)"
        }
      ]
    },
    {
      "name": "uint8",
      "code": "",
      "description": "Takes a number and converts it to a 8-bit unsigned integer.",
      "params": [
        {
          "name": "number",
          "description": "Number to be converted to a 8-bit unsigned integer.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns the specified number as a 8-bit unsigned integer."
      },
      "requires": [
        "int8"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.uint8(-200), Math.pow(2, 8) - 200)"
        }
      ]
    },
    {
      "name": "unbind",
      "code": "function unbind(fn, opt_args) {\n  opt_args = slice(opt_args || []);\n  return function(objThis) {\n    return fn.apply(objThis, opt_args.concat(slice(arguments, 1)));\n  };\n}",
      "description": "Unbinds a value from a function (such as a prototypal function) and creates a wrapper function that when called will use the 1st argument as the bound value.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be unbound.",
          "type": "Function"
        },
        {
          "name": "opt_args",
          "description": "Array of arguments to precede any additionally arguments passed to the returned wrapper function.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function which when called will bound the first argument passed to it to `fn` and then pass the rest of the arguments in after any specified in `opt_args`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "unescape",
      "code": "function unescape(str) {\n  return decodeURIComponent(str.replace(/%(?![\\dA-F]{2})/gi, '%25').replace(/\\+/g, '%20'));\n}",
      "description": "Decodes any `%##` encoding in the given string. Plus symbols (`'+'`) are decoded to a space character.",
      "params": [
        {
          "name": "str",
          "description": "String to be decoded.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "Decoded version of `str`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.unescape('Hello+world%21'), 'Hello world!');"
        }
      ]
    },
    {
      "name": "uneval",
      "code": "var uneval = (function(RGX_BEGIN_WHITESPACE, RGX_LINE, RGX_BEGIN_NON_BLANK, EMPTY, EMPTY_TIMES_START) {\n  EMPTY_TIMES_START = EMPTY + ' \\xD7 ';\n  function recursiveUneval(obj, arrAncestors, spaces, newline, partSep) {\n    var skipFirstLine, minLeadSpace, key, pairs, parts, strWrap, isNotAncestor, emptyCount, l, i,\n        arrNewAncestors = arrAncestors.concat([obj]),\n        typeName = typeOf(obj);\n    if (typeName === 'String') {\n      return JSON.stringify(obj);\n    }\n    if (typeName === 'Number') {\n      return ((!obj && 1 / obj < 0) ? '-' : '') + obj;\n    }\n    else if (typeName === 'Date') {\n      return 'new Date(' + (+obj) + ')';\n    }\n    else if (typeName === 'Function') {\n      minLeadSpace = Infinity;\n      return (obj + '').replace(RGX_BEGIN_WHITESPACE, function(m, i, mLen) {\n        if ((mLen = m.length) || i) {\n          minLeadSpace = Math.min(minLeadSpace, mLen);\n        }\n        else {\n          skipFirstLine = true;\n        }\n        return m;\n      }).replace(RGX_LINE, function(m, i) {\n        return (!i && skipFirstLine) ? m : m.slice(minLeadSpace);\n      });\n    }\n    else if (typeName === 'Array' || typeName === 'Object' || typeName === '*unknown') {\n      parts = [];\n      strWrap = typeName === 'Array' ? '[]' : '{}';\n      isNotAncestor = indexOf(arrAncestors, obj) < 0;\n      i = 0;\n      if (isNotAncestor) {\n        if (strWrap === '[]') {\n          for (emptyCount = 0, l = obj.length; i < l; i++) {\n            if (has(obj, i)) {\n              if (emptyCount) {\n                parts.push(emptyCount - 1 ? EMPTY_TIMES_START + emptyCount : EMPTY);\n                emptyCount = 0;\n              }\n              parts.push(recursiveUneval(obj[i], arrNewAncestors, spaces, newline, partSep));\n            }\n            else {\n              emptyCount += 1;\n            }\n          }\n          if (emptyCount) {\n            parts.push(emptyCount - 1 ? EMPTY_TIMES_START + emptyCount : EMPTY);\n          }\n        }\n        else {\n          pairs = entries(obj).sort(function(a,b){return a<=b?a<b?-1:0:1});\n          for (l = pairs.length; i < l; i++) {\n            key = pairs[i][0];\n            parts.push(\n              (isValidVarName(key) ? key : recursiveUneval(key, [], spaces, newline, partSep))\n              + ': '\n              + recursiveUneval(pairs[i][1], arrNewAncestors, spaces, newline, partSep)\n            );\n          }\n        }\n      }\n      return strWrap.charAt(0)\n        + (isNotAncestor\n            ? (newline + parts.join(partSep) + newline).replace(RGX_BEGIN_NON_BLANK, spaces)\n            : '\\u2026'\n        )\n        + strWrap.charAt(1);\n    }\n    return obj + '';\n  }\n\n  return function(obj, opt_spaceCount) {\n    var spaces = opt_spaceCount ? Array(opt_spaceCount + 1).join(' ') : '',\n        newline = opt_spaceCount ? '\\n' : ''\n        partSep = ',' + (newline || ' ');\n    return recursiveUneval(obj, [], spaces, newline, partSep);\n  };\n})(/^[\\s\\xA0]*/gm, /^.+$/gm, /^(?!$)/gm, 'empty');",
      "description": "Creates a string representation of the given object or primitive.",
      "params": [
        {
          "name": "subject",
          "description": "Object or primitive whose string interpretation will be formulated and returned.",
          "type": "*"
        },
        {
          "name": "opt_spaceCount",
          "description": "If given and not `0` this causes non-empty objects and/or arrays to be split onto multiple lines and indented by the amount of spaces given here.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "string",
        "description": "A string representation of `subject`."
      },
      "requires": [
        "typeOf",
        "has",
        "isValidVarName",
        "indexOf",
        "entries"
      ],
      "required": false,
      "tests": [
        {
          "name": "Zeroes",
          "code": "var arr = [-0, 0];\narr.push(arr);\ntest(YourJS.uneval(arr), '[-0, 0, [\\u2026]]');"
        }
      ]
    },
    {
      "name": "unhashID",
      "code": "function unhashID(hashedID, opt_intHash, opt_strAlpha) {\n  opt_intHash = Math.max(0, Math.min(Math.round(opt_intHash || 0), 9007199254740991));\n  opt_strAlpha = opt_strAlpha || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\n  var id = 0;\n  var FULL_ALPHA_LENGTH = opt_strAlpha.length;\n\n  for (var iter = 0, l = hashedID.length; iter < l; iter++) {\n    var newAlpha = '';\n    for (var x, i = opt_intHash; opt_strAlpha; i += opt_intHash) {\n      newAlpha += opt_strAlpha.charAt(x = i % opt_strAlpha.length);\n      opt_strAlpha = opt_strAlpha.slice(0, x) + opt_strAlpha.slice(x + 1);\n    }\n    opt_strAlpha = newAlpha;\n\n    id += opt_strAlpha.indexOf(hashedID.slice(-1)) * Math.pow(FULL_ALPHA_LENGTH, iter);\n    hashedID = hashedID.slice(0, -1);\n  }\n  return id;\n}",
      "description": "Gets an ID (non-negative integer) by decoding the given hashed ID.",
      "params": [
        {
          "name": "hashedID",
          "description": "The hashed ID that must be parsed to get the original ID.",
          "type": "string"
        },
        {
          "name": "opt_intHash",
          "description": "Non-negative integer that will be used to find the offset of the characters used to represent `hashedID`.",
          "type": "number",
          "optional": true,
          "default": "0"
        },
        {
          "name": "opt_strAlpha",
          "description": "All of the characters that were used to encode `hashedID`.  Defaults to the digits 0 to 9 followed by A to Z followed by a to z.",
          "type": "string",
          "optional": true,
          "default": "\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\""
        }
      ],
      "return": {
        "type": "number",
        "description": "The ID (non-negative integer) that was used to produce `hashedID` based on the hash and the alphabet."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "union",
      "code": "function union(array1, array2) {\n  return array1.concat(diffArrays(array2, array1));\n}",
      "description": "Creates a new array which will contain all of the items of the two given arrays.  Different from concatenation because the number of times a value occurs will never exceed the maximum number of times it was found in one of the arrays.",
      "params": [
        {
          "name": "array1",
          "description": "First array to union with the second array.",
          "type": "Array",
          "optional": false
        },
        {
          "name": "array2",
          "description": "Second array to union with the first array.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of all of the items from `array1` and `array2` but limiting the occurrences to never exceeding the maximum number of times the value occurred in either array."
      },
      "requires": [
        "diffArrays"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.union([1,2,2,2,3,3,4,5], [2,2,3,4,4,5])), '[1,2,2,2,3,3,4,5,4]');"
        }
      ]
    },
    {
      "name": "uniquify",
      "code": "function uniquify(array) {\n  array = slice(array);\n  for (var e1, i1 = 0, l = array.length; i1 < l; i1++) {\n    e1 = array[i1];\n    for (i2 = i1 + 1; i2 < l; i2++) {\n      if (is(e1, array[i2])) {\n        l--;\n        array.splice(i2--, 1);\n      }\n    }\n  }\n  return array;\n}",
      "description": "Creates a new version of an array with all of the duplicate values removed.",
      "params": [
        {
          "name": "array",
          "description": "Array to copy and then modify to get rid of all duplicates from within the copy.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A copy of `array` with all of the duplicates removed."
      },
      "requires": [
        "is",
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  JSON.stringify(YourJS.uniquify([7,5,2,7,6,2,2,3])),\n  '[7,5,2,6,3]'\n);"
        }
      ]
    },
    {
      "name": "untilExists",
      "code": "",
      "description": "Creates a copy of an array with all of the consecutive items up to but not including the first value `true`-ish value.",
      "params": [
        {
          "name": "array",
          "description": "Array or array-like object containing values that will be copied.",
          "type": "Array"
        },
        {
          "name": "opt_fromEnd",
          "description": "Indicates that the values should be copied starting from the end, not from the beginning as normal.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Array",
        "description": "If `opt_fromEnd` is not given or is `false`-ish, an array of all of the consecutive `false`-ish values starting at the beginning of `array` will be returned.  Otherwise an array of all of the consecutive `false`-ish values starting at the end of `array` will be returned."
      },
      "requires": [
        "whileExists"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.untilExists([null,undefined,3,0,8,null,0])), '[null,null]');"
        },
        {
          "name": "Simple From End",
          "code": "test(JSON.stringify(YourJS.untilExists([null,undefined,3,0,8,null,0], true)), '[null,0]');"
        }
      ]
    },
    {
      "name": "upperCase",
      "code": "",
      "description": "Takes a value that will then be upper-cased.",
      "params": [
        {
          "name": "value",
          "description": "The string or value to be upper-cased.",
          "type": "string|*"
        }
      ],
      "return": {
        "type": "string",
        "description": "`value` coerced to a string with all of the characters upper-cased."
      },
      "requires": [
        "lowerCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "upperFirst",
      "code": "",
      "description": "Upper-cases the first character of a string.",
      "params": [
        {
          "name": "string",
          "description": "String that should be returned with the first character upper-cased.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "`string` with the first character upper-cased and any remaining characters kept as is."
      },
      "requires": [
        "lowerFirst"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "upperRest",
      "code": "",
      "description": "Upper-cases all characters after the first one.",
      "params": [
        {
          "name": "string",
          "description": "String that should be returned making sure that all characters after the first are upper-cased.",
          "type": "string"
        }
      ],
      "return": {
        "type": "string",
        "description": "`string` with the first character as is followed by all the rest upper-cased."
      },
      "requires": [
        "lowerFirst"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "utc",
      "code": "function utc(yearOrValue, opt_month, opt_day, opt_hour, opt_min, opt_sec, opt_ms) {\n  var d;\n  if (arguments.length < 2) {\n    d = 'object' == typeof yearOrValue ? yearOrValue : new Date(yearOrValue);\n    d = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n  }\n  else {\n    d = Date.UTC(yearOrValue, opt_month, opt_day == undefined ? 1 : opt_day, opt_hour || 0, opt_min || 0, opt_sec || 0, opt_ms || 0);\n  }\n  return new Date(d);\n}",
      "description": "Creates a date using universal time.",
      "params": [
        {
          "name": "yearOrValue",
          "description": "Either a `Date` object whose properties will be interpreted as UTC properties, or the number of milliseconds since the beginning of Jaunary 1, 1970 GMT, or a string version of the date, or the year.  If this is to be understood as the year additional arguments must also be passed.",
          "type": "Date|number|string"
        },
        {
          "name": "opt_month",
          "description": "An integer between `0` and `11` representing the month.",
          "type": "number",
          "optional": true
        },
        {
          "name": "opt_day",
          "description": "An integer between `1` and `31` representing the month.",
          "type": "number",
          "optional": true
        },
        {
          "name": "opt_hour",
          "description": "An integer between `0` and `23` representing the hour.",
          "type": "number",
          "optional": true
        },
        {
          "name": "opt_min",
          "description": "An integer between `0` and `59` representing the minute.",
          "type": "number",
          "optional": true
        },
        {
          "name": "opt_sec",
          "description": "An integer between `0` and `59` representing the second.",
          "type": "number",
          "optional": true
        },
        {
          "name": "opt_ms",
          "description": "An integer between `0` and `999` representing the millisecond.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "Date",
        "description": "Specified UTC date/time as a `Date` object."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.utc(2010,9,8,7,6,5,4).toISOString(), '2010-10-08T07:06:05.004Z');"
        }
      ]
    },
    {
      "name": "values",
      "code": "function values(value, opt_onlyNonEnums) {\n  for (var result = keys(value, opt_onlyNonEnums), i = result.length; i--;) {\n    result[i] = value[result[i]];\n  }\n  return result;\n}",
      "description": "Gets an array of all of the values within a given array or object.",
      "params": [
        {
          "name": "value",
          "description": "Value for which you would like the property names retrieved.",
          "type": "*"
        },
        {
          "name": "opt_onlyNonEnums",
          "description": "If specified and is not `null` or `undefined` but is `false`-ish, all of the properties (enumerable or not) will be returned.  If this is `true`-ish only the non-enumerable properties will be returned.  If this is not given or is `null` or `undefined` all of the enumerable properties will be returned.",
          "type": "boolean",
          "optional": true,
          "default": ""
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of all of the values in `value`."
      },
      "requires": [
        "keys"
      ],
      "required": false,
      "tests": [
        {
          "name": "Sparse Array Test",
          "code": "var arr = [5,9];\narr[7] = 7;\narr[23] = 23;\ntest(JSON.stringify(YourJS.values(arr)), '[5,9,7,23]');"
        }
      ]
    },
    {
      "name": "wait",
      "code": "function wait(fnReady, opt_clearOrdersAfterReady) {\n  var orders = [], allOrders = [];\n  return function(opt_makeAnOrder, opt_order) {\n    var index;\n    if (opt_makeAnOrder) {\n      orders.push(opt_order);\n      allOrders.push(opt_order);\n    }\n    else {\n      index = orders.findIndex(function(order) {\n        return is(order, opt_order);\n      });\n      if (index >= 0) {\n        orders.splice(index, 1);\n        if (!orders.length) {\n          try {\n            fnReady(slice(allOrders), opt_order);\n          }\n          catch (e) {\n            setTimeout(function(){throw e},0);\n          }\n          if (opt_clearOrdersAfterReady) {\n            allOrders = [];\n          }\n        }\n      }\n    }\n    return !(index < 0);\n  }\n}",
      "description": "Creates a waiter function which takes orders and serves orders in a way and calls a ready function when all orders have been served.",
      "params": [
        {
          "name": "fnReady",
          "description": "Function to be called when the waiter function is has been called to serve the last remaining order.  When called this function will receive all of the orders ever made as the 1st argument and the final order as the 2nd.",
          "type": "Function"
        },
        {
          "name": "opt_clearOrdersAfterReady",
          "description": "If `true`-ish the orders array will be cleared after the `fnReady` function is called.  This prevents previous orders from showing up if `fnReady` is called multiple times.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A waiter function which take and serve orders.  The 1st argument passed to this function should be a boolean indicating that an order is going in.  The 2nd argument passed to this function can be any value that represents an order.  When this function is called a boolean will be returned indicating whether or not the call was successful.  The only way `false` can be returned by this function is if an order is to be served that doesn't exist."
      },
      "requires": [
        "is",
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "whileExists",
      "code": "eval('while until'.replace(/\\w+/g, function(m, i) {\n  return 'function ' + m\n    + 'Exists(b,c){for(var f=c?\"unshift\":\"push\",d=[],g=c?-1:1,e=b.length,a=c?~~(e-1):0;'\n    + (i ? '!' : '') + 'b[a]&&-1<a&&a<e;a+=g)d[f](b[a]);return d}';\n}));",
      "description": "Creates a copy of an array with all of the consecutive items up to but not including the first value `false`-ish value.",
      "params": [
        {
          "name": "array",
          "description": "Array or array-like object containing values that will be copied.",
          "type": "Array"
        },
        {
          "name": "opt_fromEnd",
          "description": "Indicates that the values should be copied starting from the end, not from the beginning as normal.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Array",
        "description": "If `opt_fromEnd` is not given or is `false`-ish, an array of all of the consecutive `true`-ish values starting at the beginning of `array` will be returned.  Otherwise an array of all of the consecutive `true`-ish values starting at the end of `array` will be returned."
      },
      "requires": [
        "untilExists"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(JSON.stringify(YourJS.whileExists([3,7,8,NaN,2,0,1,5])), '[3,7,8]');"
        },
        {
          "name": "Simple From End",
          "code": "test(JSON.stringify(YourJS.whileExists([3,7,8,NaN,2,0,1,5], true)), '[1,5]');"
        }
      ]
    },
    {
      "name": "xorBits",
      "code": "",
      "description": "Finds the bitwise `xor` of two numbers.",
      "params": [
        {
          "name": "number1",
          "description": "Number to be `xor`ed against `number2`.",
          "type": "number"
        },
        {
          "name": "number2",
          "description": "Number to be `xor`ed against `number1`.",
          "type": "number",
          "optional": true
        }
      ],
      "return": {
        "type": "number|Function",
        "description": "If `number1` and `number2` are given a bitwise `xor` will be executed on both and returned.  Otherwise a partial function will be returned which when called will accept one number and will return a number which is the result of using bitwise `xor` on `number1` and the number passed to this partial function."
      },
      "requires": [
        "lt"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "zip",
      "code": "function zip() {\n  for (var j, i = 0, arrays = arguments, maxArrLen = 0, result = [], argc = arrays.length; i < argc; i++) {\n    maxArrLen = Math.max(maxArrLen, arrays[i].length);\n  }\n  for (i = 0; i < maxArrLen; i++) {\n    result[i] = [];\n    for (j = 0; j < argc; j++) {\n      result[i][j] = arrays[j][i];\n    }\n  }\n  return result;\n}",
      "description": "Takes one or more arrays and does a kind of matrix inverse option on them.",
      "params": [
        {
          "name": "array",
          "description": "One or more arrays whose array items will be used to create the returned array.",
          "type": "Array",
          "rest": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "An array of arrays where the first array contains the first item of each array and the second array contains the second item of each array and so on."
      },
      "requires": [],
      "required": false,
      "tests": []
    }
  ]
}
