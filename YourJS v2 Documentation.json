{
  "base": "/**\n * @preserve YourJS - Your Very Own JS Library\n * http://yourjs.com\n *\n * Copyright (c) 2015-2017 Christopher West\n * Licensed under the MIT license.\n */\n(function(__VERSION, __VARIABLE_NAME, undefined) {\n  var YourJS,\n      __GLOBAL = this,\n      __EMPTY_ARRAY = [],\n      __EMPTY_OBJECT = {},\n      __DOCUMENT = __GLOBAL.document,\n      __callsAfterDefs = [];\n  \n  /*{DEFINITIONS}*/\n\n  /**\n   * YourJS object.\n   * @name {{VARIABLE_NAME}}\n   * @namespace\n   * @global\n   */\n  YourJS = /*{MEMBERS_OBJECT}*/;\n\n  __callsAfterDefs.forEach(function(fn) { fn(); });\n\n  // Add to browser/node environment correctly.\n  if(typeof exports !== 'undefined') {\n    if(typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = YourJS;\n    }\n    (exports[__VARIABLE_NAME] = YourJS)[__VARIABLE_NAME] = undefined;\n  } \n  else {\n    __GLOBAL[__VARIABLE_NAME] = YourJS;\n  }\n})(/*{VERSION}*/, /*{VARIABLE_NAME}*/);\n",
  "version": "2.1.0",
  "parts": [
    {
      "name": "alias",
      "code": "function alias(context, name) {\n  return function() {\n    return context[name].apply(context, arguments);\n  };\n}",
      "description": "Creates a function wrapper that calls the function with the given name in the given context.",
      "params": [
        {
          "name": "context",
          "description": "Context object containing the function to be called.",
          "type": "Object"
        },
        {
          "name": "name",
          "description": "Name of the function to call within the context.",
          "type": "string"
        }
      ],
      "return": {
        "description": "Function that when called will execute the function with the given name under the given context.",
        "type": "Function"
      },
      "requires": [],
      "tests": [
        {
          "name": "Array slicer",
          "code": "var sliceArray = YourJS.alias([].slice, 'call');\ntest(sliceArray([3,4,5,6,7,8,9], 2, -3).join(','), [3,4,5,6,7,8,9].slice(2, -3).join(','));"
        }
      ],
      "required": false
    },
    {
      "name": "call",
      "code": "function call(fn, objThis) {\n  var t = typeOf(fn) == 'String';\n  if (t) {\n    t = fn.match(/^([\\w\\$]+(?=\\.|#))?(#|\\.?prototype\\.)(\\w+)$/);\n    fn = t ? (t[1] ? __GLOBAL[t[1]].prototype : objThis)[t[3]] : YourJS[fn];\n  }\n  return fn.apply(t ? objThis : undefined, slice(arguments, t ? 2 : 1));\n}",
      "description": "Calls a function whether it be a global prototype function or a YourJS function or a custom bindable.",
      "params": [
        {
          "name": "fn",
          "description": "If a function is supplied it will be called.  If a string, it can refer to a prototype function by using either the `\"Array.prototype.slice\"` (`\"Prototype_Name.prototype.function_name\"`) format, the `\"Array#slice\"` (`\"Prototype_Name#function_name\"`) format or the `\"#slice\"` (`\"#function_name\"` for `objThis`) format.  If not in the previous format but is a string it must be the string name of a function in the `YourJS` object.",
          "type": "Function|string"
        },
        {
          "name": "objThis",
          "description": "If `fn` is a function or is a string referring to a prototypal function, this will be the value passed as the `this` object to `fn`.",
          "type": "*",
          "optional": true,
          "default": "global"
        },
        {
          "name": "argX",
          "description": "Arguments to pass to `fn`.",
          "type": "*",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "*",
        "description": "Return value of calling `fn` with the specified arguments and using the specified context object."
      },
      "requires": [
        "slice",
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Call YourJS.toString function",
          "code": "test(YourJS.call('toString'), YourJS.toString());"
        },
        {
          "name": "Call YourJS.typeOf function (since it is required)",
          "code": "test(YourJS.call('typeOf', 34), YourJS.typeOf(34));"
        },
        {
          "name": "Call slice on string",
          "code": "var msg = 'Hello world!!!';\nvar start = -8, end = -2;\ntest(\n  YourJS.call('#slice', msg, start, end),\n  msg.slice(start, end)\n);"
        }
      ]
    },
    {
      "name": "calls",
      "code": "function calls(value) {\n  for (var callArgs, args = slice(arguments), i = 0, l = args.length, i = l; i < l; i++) {\n    callArgs = args[i];\n    if (typeOf(callArgs) != 'Array') {\n      callArgs = [callArgs];\n    }\n    value = call.apply(undefined, slice(callArgs, 0, 1).concat([value], slice(callArgs, 1)));\n  }\n  return value;\n}",
      "description": "Makes multiple calls using the YourJS `call()` function.",
      "params": [
        {
          "name": "value",
          "description": "The value to start off with in the calling chain.",
          "type": "*"
        },
        {
          "name": "callArgs",
          "description": "If any of these arguments are strings or functions that will be wrapped in arrays.  The items in each array argument will be passed as arguments to YourJS's `call()` function.",
          "type": "Array|Function|string",
          "optional": true,
          "rest": true
        }
      ],
      "return": {
        "type": "*",
        "description": "Return value of making the specified calls to YourJS's call function in the specified sequence."
      },
      "requires": [
        "typeOf",
        "slice",
        "call"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "cap",
      "code": "function cap(fn, opt_maxArity) {\n  opt_maxArity = opt_maxArity != undefined ? opt_maxArity : fn.length;\n  return function() {\n    return fn.apply(this, slice(arguments, 0, opt_maxArity));\n  };\n}",
      "description": "Puts a cap (limit) on the amount of arguments that a function can receive.",
      "params": [
        {
          "name": "fn",
          "description": "The function whose argument count will be capped off (limited).",
          "type": "Function"
        },
        {
          "name": "opt_maxArity",
          "description": "The max number of arguments that will be passed into `fn`.",
          "type": "number",
          "optional": true,
          "default": "fn.length"
        }
      ],
      "return": {
        "type": "Function",
        "description": "Returns a function that will call `fn` with the passed in arguments when invoked, but it will limit the argument count to the value `opt_maxArity`. When calling this newly created function, it will behave like this: `fn.apply(this, YourJS.slice(arguments, 0, opt_maxArity))`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "ceil",
      "code": "",
      "description": "Rounds towards `Infinity` with the specified precision.",
      "params": [
        {
          "name": "num",
          "description": "The number to be rounded towards `Infinity`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number towards `Infinity`. Using the precision is similar to doing `Math.ceil(num * Math.pow(10, precision)) / Math.pow(10, precision)`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` rounded towards `-Infinity` with the specified precision."
      },
      "requires": [
        "round"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "chain",
      "code": "var chain, mixin;\n(function(RGX_INVALID_PROP_NAMES) {\n  function YourJSChain(value, previousWrap) {\n    this.$$ = previousWrap;\n    this.$ = value;\n  }\n\n  YourJSChain.prototype = {\n    _: function(name) {\n      return new YourJSChain(this.$[name].apply(this.$, slice(arguments, 1)), this);\n    },\n    value: function() { return this.$; },\n    end: function() { return this.$$; }\n  };\n\n  __callsAfterDefs.push(function() {\n    forIn(YourJS, function(prop, name) {\n      if ('function' == typeof prop && !RGX_INVALID_PROP_NAMES.test(name)) {\n        YourJSChain.prototype[name] = function() {\n          return new YourJSChain(prop.apply(undefined, [this.$].concat(slice(arguments))), this);\n        };\n      }\n    });\n  });\n\n  typeOf(YourJSChain, 'YourJSChain');\n\n  chain = function(value) {\n    return new YourJSChain(value);\n  };\n\n  mixin = function(fn, name) {\n    if (RGX_INVALID_PROP_NAMES.test(name) || has(YourJS, name)) {\n      return false;\n    }\n\n    YourJS[name] = fn;\n    YourJSChain.prototype[name] = function() {\n      return new YourJSChain(fn.apply(undefined, [this.$].concat(slice(arguments))), this);\n    };\n    return true;\n  };\n})(/^(value|end|_|mixin|\\$\\$?)$/);",
      "description": "Creates a chained version of a value.",
      "params": [
        {
          "name": "value",
          "description": "Value to make chainable.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "YourJSChain",
        "description": "A `YourJSChain` object allows for chaining other YourJS functions calls together and thusly all of its functions except the `value()` function will return a `YourJSChain` object.  You can call the `YourJSChain`'s `value()` function to return the actual internal value.  The `YourJSChain`'s `end()` function will return the previous `YourJSChain` object."
      },
      "requires": [
        "slice",
        "forIn",
        "typeOf",
        "is",
        "mixin",
        "has"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "clamp",
      "code": "function clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}",
      "description": "Confine a given number to a specific range.",
      "params": [
        {
          "name": "x",
          "description": "The number to be confined to the specified range.",
          "type": "number"
        },
        {
          "name": "min",
          "description": "The minimum number that can be returned.",
          "type": "number"
        },
        {
          "name": "max",
          "description": "The maximum number that can be returned.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The closest number to `x` that is greater than or equal to `min` and less than or equal to `max`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "compare",
      "code": "function compare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}",
      "description": "Simple compare function typically use in sorting.",
      "params": [
        {
          "name": "a",
          "description": "First argument to compare.",
          "type": "*"
        },
        {
          "name": "b",
          "description": "Second argument to compare.",
          "type": "*"
        }
      ],
      "return": {
        "type": "number",
        "description": "`-1` is returned if `a < b`.  `1` is returned if `a > b`.  In all other cases `0` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "compose",
      "code": "function compose(fnWrapper, fnToWrap, opt_applyArgs) {\n  return Function('x,y', 'return function(){return x.' + (opt_applyArgs ? 'apply' : 'call') + '(this,y.apply(this,arguments))}')(fnWrapper, fnToWrap);\n}",
      "description": "Create a new function which is basically the composition of two functions.",
      "params": [
        {
          "name": "fnWrapper",
          "description": "Function that will be passed the return value of `fnToWrap` and whose return value will be returned by the composed function.",
          "type": "Function"
        },
        {
          "name": "fnToWrap",
          "description": "Function that will be called 1st by te composed function and whose return value will be passed to `fnWrapper`.",
          "type": "Function"
        },
        {
          "name": "opt_applyArgs",
          "description": "Set to `true` if the return value from `fnToWrap` is an `Array` and each element should be passed a separate argument to `fnWrapper`.  Leave blank or set to `false` if the return value from `fnToWrap` should just be passed as the 1st argument to `fnWrapper`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The function that is composed of `fnToWrap` and `fnWrapper`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "cos",
      "code": "",
      "description": "Determines the cosine of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose cosine value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cosine of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the cosine of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "cot",
      "code": "",
      "description": "Determines the cotangent of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose cotangent value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cotangent of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the cotangent of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "csc",
      "code": "",
      "description": "Determines the cosecant of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose cosecant value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The cosecant of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the cosecant of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "cut",
      "code": "function cut(str, startIndex, opt_endIndex) {\n  var len = str.length;\n  if (opt_endIndex == undefined) {\n    opt_endIndex = Infinity;\n  }\n  else if (opt_endIndex < 0) {\n    opt_endIndex = opt_endIndex < -len ? 0 : (len + opt_endIndex);\n  }\n  if (startIndex < 0) {\n    startIndex = startIndex < -len ? 0 : (len + startIndex);\n  }\n  if (opt_endIndex < startIndex) {\n    opt_endIndex = startIndex;\n  }\n  return str.slice(0, startIndex) + str.slice(opt_endIndex);\n}",
      "description": "Cut out a substring within a given range.",
      "params": [
        {
          "name": "str",
          "description": "String to cut from.",
          "type": "string"
        },
        {
          "name": "startIndex",
          "description": "Index within `str` where the substring that will be removed starts.",
          "type": "number",
          "optional": false
        },
        {
          "name": "opt_endIndex",
          "description": "Index within `str` where the substring that will be removed ends.",
          "type": "number",
          "optional": true,
          "default": "str.length"
        }
      ],
      "return": {
        "type": "string",
        "description": "`str` without the cut substring found between `startIndex` and `opt_endIndex`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "debounce",
      "code": "function debounce(fn, msBetweenCalls, opt_immediate) {\n  var timeoutID,\n      result;\n  return function() {\n    var objThis = this,\n        args = arguments;\n    if (opt_immediate && !timeoutID) {\n      fnDebounced();\n    }\n    clearTimeout(timeoutID);\n    timeoutID = setTimeout(fnDebounced, msBetweenCalls);\n    function fnDebounced(oldTimeoutID) {\n      timeoutID = 0;\n      if (!opt_immediate) {\n        result = fn.apply(objThis, args);\n      }\n    }\n    return result;\n  };\n}",
      "description": "Creates a debounced copy of the function which when called will delay the execution until the specified amount of milliseconds have elapsed since the last time it ran.",
      "params": [
        {
          "name": "fnCallback",
          "description": "The function to debounce. The context and parameters sent to the debounced function will be sent to this function.",
          "type": "Function"
        },
        {
          "name": "msBetweenCalls",
          "description": "The amount of milliseconds that must pass since the last call to this function before `fnCallback` will be invoked.",
          "type": "number"
        },
        {
          "name": "opt_immediate",
          "description": "Specify `true` if the debounce function should run immediately instead of initially waiting for the delay. If `true` is specified, when the debounced function runs, if the delay has elapsed, the value returned from the debounced function will be that which was returned by `fnCallback`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The debounced copy of `fnCallback`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "defer",
      "code": "function defer(fn, opt_args) {\n  var objThis = this;\n  opt_args = slice(opt_args || []);\n  return setTimeout(function() { fn.apply(objThis, opt_args); }, 0);\n}",
      "description": "Defers calling a function until the current call stack is done.  Similar to using the global `setTimeout` function.",
      "params": [
        {
          "name": "fn",
          "description": "Function whose call will be deferred until after all other calls in the current stack are done.",
          "type": "Function"
        },
        {
          "name": "opt_args",
          "description": "Array of the arguments to be passed to `fn`.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "number",
        "description": "The `timeoutID` associated with the deferred call.  If passed to the global `clearTimeout` while the function is being deferred the deferred function will not be called."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Check deferred change in 100ms",
          "code": "var value, newValue = Math.random();\nYourJS.defer(function(input){ value = input; }, [newValue]);\nif (value === newValue) {\n  test('defer never happened');\n}\nsetTimeout(function() {\n  test(value, newValue);\n}, 100);"
        }
      ]
    },
    {
      "name": "delay",
      "code": "function delay(fn, msDelay, opt_args) {\n  var objThis = this;\n  opt_args = slice(opt_args || []);\n  return setTimeout(function() { fn.apply(objThis, opt_args); }, msDelay);\n}",
      "description": "Calls a function after a given amount of time.  This is very similar to the global `setTimeout` function.",
      "params": [
        {
          "name": "fn",
          "description": "Function to call after a certain amount of time.",
          "type": "Function"
        },
        {
          "name": "msDelay",
          "description": "Delay in milliseconds before `fn` is actually called.",
          "type": "number"
        },
        {
          "name": "opt_args",
          "description": "An array of the arguments to pass to `fn`.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "number",
        "description": "The `timeoutID` corresponding to this delayed function call.  The global `clearTimeout` function can be used to cancel this delayed call."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Delay call",
          "code": "var delayCalled;\nYourJS.delay(function(){ delayCalled = true; }, 500);\nif (delayCalled) {\n  test(true, false);\n}\nelse {\n  setTimeout(function() {\n    test(delayCalled, true);\n  }, 600);\n}"
        }
      ]
    },
    {
      "name": "diffDates",
      "code": "function diffDates(dEnd, dStart, opt_onlyRemainder) {\n  var t = dEnd < dStart, multiplier = t ? -1 : 1;\n  if (t) {\n    t = dEnd;\n    dEnd = dStart;\n    dStart = t;\n  }\n\n  var years = dEnd.getFullYear() - dStart.getFullYear();\n  t = new Date(+dStart);\n  t.setFullYear(dEnd.getFullYear());\n  if (t.getDate() != dStart.getDate() || t.getMonth() != dStart.getMonth()) {\n    t.setDate(0);\n  }\n  if (dEnd < t) {\n    years--;\n    t.setFullYear(dEnd.getFullYear() - 1);\n    t.setDate(dStart.getDate());\n    if (t.getDate() != dStart.getDate()) {\n      t.setDate(0);\n    }\n  }\n  \n  var months = (opt_onlyRemainder ? 0 : (years * 12)) + dEnd.getMonth() - dStart.getMonth();\n  t = new Date(+dEnd);\n  t.setFullYear(dStart.getFullYear());\n  t.setDate(dEnd.getDate());\n  t.setMonth(dStart.getMonth());\n  if (t.getDate() != dEnd.getDate() || t.getMonth() != dStart.getMonth()) {\n    t.setDate(0);\n  }\n  if (dStart > t) {\n    --months;\n    t.setDate(dEnd.getDate());\n    t.setMonth(dStart.getMonth() + 1);\n    if (t.getDate() != dEnd.getDate()) {\n      t.setDate(0);\n    }\n  }\n  if (opt_onlyRemainder || months < 0) {\n    months = (months + 12) % 12;\n  }\n  \n  t = (opt_onlyRemainder ? t : dEnd) - dStart;\n\n  var days = Math.floor(t / 864e5);\n  var hours = Math.floor(t / 36e5) % (opt_onlyRemainder ? 24 : Infinity);\n  var minutes = Math.floor(t / 6e4) % (opt_onlyRemainder ? 60 : Infinity);\n  var seconds = Math.floor(t / 1e3) % (opt_onlyRemainder ? 60 : Infinity);\n  var ms = t % (opt_onlyRemainder ? 1e3 : Infinity);\n\n  t = {\n    start: multiplier + 1 ? dStart : dEnd,\n    end: multiplier + 1 ? dEnd : dStart,\n    years: multiplier * years,\n    months: multiplier * months,\n    days: multiplier * days,\n    hours: multiplier * hours,\n    minutes: multiplier * minutes,\n    seconds: multiplier * seconds,\n    milliseconds: multiplier * ms\n  };\n  if (opt_onlyRemainder) {\n    t.weekDays = t.days % 7;\n    t.weeks = Math.floor(multiplier * t.days / 7) * multiplier;\n  }\n  return t;\n}",
      "description": "Finds the differents between 2 dates.",
      "params": [
        {
          "name": "dEnd",
          "description": "Ending date.",
          "type": "Date"
        },
        {
          "name": "dStart",
          "description": "Starting date.",
          "type": "Date"
        },
        {
          "name": "opt_onlyRemainder",
          "description": "Determines whether or not the values returned will show the remainder values instead of the full values for each unit of measure.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Object",
        "description": "An object containing all of the following measurements in the corresponding object properties: `years`, `months`, `days`, `hours`, `minutes` and `seconds`.  If `opt_onlyRemainder` is specified as `true` all of the object's properties will not include the measures for the next highest unit of measure.  If `op_onlyRemainder` is supplied `weekDays` and `weeks` are added to this returned object.  If `opt_onlyRemainder` is not specified or is `false` all of the object's properties will individual calculations indicating the difference in time."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "doEvery",
      "code": "function doEvery(fn, msDelay, opt_args, opt_immediate) {\n  function caller() { fn.apply(objThis, opt_args); }\n  var objThis = this;\n  opt_args = slice(opt_args || []);\n  if (opt_immediate) {\n    try { caller(); }\n    catch (e) { setTimeout(function(){throw e;}, 0); }\n  }\n  return setInterval(caller, msDelay);\n}",
      "description": "Execute a function every so often.  Similar to `setTimeout`.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be executed every so often.",
          "type": "Function"
        },
        {
          "name": "msDelay",
          "description": "Number of milliseconds between calls to `fn`.",
          "type": "number"
        },
        {
          "name": "opt_args",
          "description": "Arguments to be passed to `fn` every time it is called.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        },
        {
          "name": "opt_immediate",
          "description": "Specifies whether or not an immediate call should occur.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The `timeoutID` associated with the ongoing process of running this function.  To stop calling `fn` you can use `clearInterval(timeoutID)`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "extend",
      "code": "function extend(objToExtend, objProps) {\n  for (var k, args = arguments, i = 1; objProps = args[i++]; ) {\n    for (k in objProps) {\n      if (has(objProps, k)) {\n        objToExtend[k] = objProps[k];\n      }\n    }\n  }\n  return objToExtend;\n}",
      "description": "Adds extra properties to an object based on the properties owned by other specified objects.",
      "params": [
        {
          "name": "objToExtend",
          "description": "Object to be modified.",
          "type": "Object"
        },
        {
          "name": "objPropsX",
          "description": "One or more arguments where each one's properties will be added to `objToExtend`.",
          "type": "Object",
          "rest": true
        }
      ],
      "return": {
        "type": "Object",
        "description": "A reference to `objToExtend`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "floor",
      "code": "",
      "description": "Rounds towards `-Infinity` with the specified precision.",
      "params": [
        {
          "name": "num",
          "description": "The number to be rounded towards `Infinity`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number towards `-Infinity`. Using the precision is similar to doing `Math.floor(num * Math.pow(10, precision)) / Math.pow(10, precision)`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` rounded towards `-Infinity` with the specified precision."
      },
      "requires": [
        "round"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "forEach",
      "code": "function forEach(a, fn, opt_traverseAll) {\n  function end(opt_getIfEnded) {\n    if(opt_getIfEnded) {\n      return !!endCalled;\n    }\n    throw endCalled = 1;\n  }\n  for (var endCalled, count = 0, i = 0, l = a.length, arr = 'string' == typeof a ? a.split('') : a; i < l; i++) {\n    if (opt_traverseAll || has(arr, i)) {\n      try {\n        fn.call(++count, arr[i], i, a, end);\n      }\n      catch (e) {\n        if (endCalled) {\n          break;\n        }\n        throw e;\n      }\n    }\n  }\n  return count;\n}",
      "description": "Traverses all the characters in a string or all of the elements in an array or an array-like object, executing a function on each one.",
      "params": [
        {
          "name": "a",
          "description": "Array or array-like object or string to traverse.",
          "type": "Array|Arguments|string|Object",
          "optional": false
        },
        {
          "name": "fn",
          "description": "Function called on each item in `a`.  The parameters passed are as follows:  (1) value, (2) key, (3) `a` and (4) ender function.  The `this` keyword will contain the number of times the function has been called.  The ender function may be used to immediately stop traversing `a`.  Calling the ender function with a `true`-ish value will instead make it just return a boolean value indicating if the ender function has already been called (useful only in a `catch` or `finally` clause).",
          "type": "Function"
        },
        {
          "name": "opt_traverseAll",
          "description": "Boolean indicating if all items in `a`, including those not owned by `a`, should be traversed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The number of times `fn` was called."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "forIn",
      "code": "function forIn(obj, fn, opt_traverseAll) {\n  var endCalled, count = 0;\n  function end(opt_getIfEnded) {\n    if(opt_getIfEnded) {\n      return !!endCalled;\n    }\n    throw endCalled=1;\n  }\n  for (var k in obj) {\n    if (opt_traverseAll || has(obj, k)) {\n      try {\n        fn.call(++count, obj[k], k, obj, end);\n      }\n      catch (e) {\n        if (endCalled) {\n          break;\n        }\n        throw e;\n      }\n    }\n  }\n  return count;\n}",
      "description": "Runs through all of the properties of an object, executing a function for each property found.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose properties will be traversed.",
          "type": "Object"
        },
        {
          "name": "fn",
          "description": "Function to call for each property in `obj`.  The parameters passed are as follows:  (1) value, (2) key, (3) `obj` and (4) ender function.  The `this` keyword will contain the number of times the function has been called.  The ender function may be used to immediately stop traversing `obj`.  Calling the ender function with a `true`-ish value will instead make it just return a boolean value indicating if the ender function has already been called (useful only in a `catch` or `finally` clause).",
          "type": "Function"
        },
        {
          "name": "opt_traverseAll",
          "description": "Boolean indicating whether or not even the properties that are not owned by `obj` should be traversed.  If `true` all properties will be traversed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "Number of times `fn` was called."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "frac",
      "code": "function frac(num) {\n  return +(+num).toExponential().replace(\n    /(-?)(\\d+(\\.?)\\d*)e(.+)/,\n    function(m, neg, num, dot, offset) {\n      var zeroes = Array(Math.abs(offset) + 2).join('0');\n      num = (zeroes + num + (dot ? '' : '.') + zeroes).split('.');\n      return +(neg + '.' + num.join('').slice(+offset + num[0].length));\n    }\n  );\n}",
      "description": "Gets the fractional part of a number, removing the integral part.",
      "params": [
        {
          "name": "num",
          "description": "The number from which the fractional part will be pulled.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` without the integral part while keeping the sign."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "get",
      "code": "function get(obj, opt_name, opt_default) {\n  var emptyIndex = obj != undefined ? opt_name == undefined ? 1 : -1 : 0;\n  return (emptyIndex + 1)\n    ? Function('g,a,b,c', 'return function(x,y){return g(a,x,b,arguments.length>1?y:c)}'.replace(emptyIndex ? 'b,' : 'a,', ''))(get, obj, opt_name, opt_default)\n    : has(obj, opt_name)\n      ? obj[opt_name]\n      : opt_default;\n}",
      "description": "Get the value of the specified property name.",
      "params": [
        {
          "name": "obj",
          "description": "Object to get the property from.",
          "type": "Object|undefined"
        },
        {
          "name": "opt_name",
          "description": "Name of the property.",
          "type": "string|undefined",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_default",
          "description": "The default value to return if the specified property (`opt_name`) is not owned by `obj`.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "*",
        "description": "If both `obj` and `opt_name` are specified then either the owned property will be returned or `opt_default` will be returned.  If `obj` is `undefined` a partial function will be returned that will accept an object to always pull the same property name (`opt_name`) from and an optional different default value.  If `opt_name` was not specified or is `undefined` a partial function will be returned that will accept a name for a property to always pull from the same object (`obj`) and a different default value."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "getCookie",
      "code": "function getCookie(name, opt_defaultValue) {\n  if(typeOf(name, 'RegExp')) {\n    var ret = getCookie();\n    for(var key in ret) {\n      if(!name.test(key)) {\n        delete ret[key];\n      }\n    }\n  }\n  else if(name == undefined) {\n    var ret = {};\n    __DOCUMENT.cookie.replace(/(?:^|;\\s*)(.+?)(?=;\\s*|$)/g, function($0, $1) {\n      $1 = $1.match(/(.*?)=(.*)/);\n      ret[decodeURIComponent($1[1])] = decodeURIComponent($1[2]);\n    });\n  }\n  else {\n    name = __DOCUMENT.cookie.match(new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(name) + \"=(.*?)(?:;\\\\s*|$)\"));\n    if(name) {\n      var ret = decodeURIComponent(name[1]);\n    }\n  }\n  return ret == undefined ? opt_defaultValue : ret;\n}",
      "description": "Retrieves one or more cookies.",
      "params": [
        {
          "name": "name",
          "description": "Either the name of the cookie to get or a regular expression matching the names of all of the cookies to get.  If `undefined` or `null` is supplied that means all cookies should be retrieved.",
          "type": "string|RegExp|undefined|null",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_defaultValue",
          "description": "The default value to return in the case that `name` was a string but the corresponding cookie doesn't exist.",
          "type": "*",
          "optional": true,
          "default": "undefined"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `name` is a string and matches the name of a cookie, that cookie's value will be returned as a string.  If `name` is a string but doesn't match the name of a cookie `opt_defaultValue` will be returned.  If `name` is of type `RegExp` an object containing all of the cookies with names that match the specified regular expression will be returned.  If `name` is `undefined` or `null` an object containing all of the cookies will be returned.  If an object is returned each key will represent the name of each cookie and each value will be the value of that cookie."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "groupBy",
      "code": "function groupBy(arr, hasher, opt_initial) {\n  opt_initial = opt_initial || {};\n  for (var index, i = 0, l = arr.length; i < l; i++) {\n    if (has(arr, i)) {\n      if (typeOf(opt_initial[index = hasher(arr[i], i, arr)]) != 'Array') {\n        opt_initial[index] = [];\n      }\n      opt_initial[index].push(arr[i]);\n    }\n  }\n  return opt_initial;\n}",
      "description": "Takes an array and groups the items together based on a given hasher function.",
      "params": [
        {
          "name": "arr",
          "description": "Array containing the items to be grouped by the `hasher` function.",
          "type": "Array"
        },
        {
          "name": "hasher",
          "description": "Function that will take item in the array and and return a value to be used as the key in the returned object.",
          "type": "function(*, number, Array)"
        },
        {
          "name": "opt_initial",
          "description": "Object that will be augmented and returned.  The values at the keys produced by `hasher` will be arrays containing all of the corresponding items from `arr`.  If not specified the default is a new empty object.",
          "type": "*",
          "optional": true,
          "default": "{}"
        }
      ],
      "return": {
        "type": "*",
        "description": "`opt_initial` with all of the keys specified by `hasher` corresponding to arrays containing those values that come from `arr`."
      },
      "requires": [
        "has",
        "typeOf"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var names = ['Andrew','Chris','Stacey','Whitney'];\nvar obj = YourJS.groupBy(names, function(name) { return name.length; });\ntest(obj[5].concat(obj[6],obj[7]).join(','), 'Chris,Andrew,Stacey,Whitney');"
        }
      ]
    },
    {
      "name": "has",
      "code": "var has = alias(__EMPTY_OBJECT.hasOwnProperty, 'call');",
      "description": "Every object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose property will be tested.",
          "type": "Object"
        },
        {
          "name": "name",
          "description": "Name of the property to test.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating whether the object has the specified property as own (not inherited) property."
      },
      "requires": [
        "alias"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "hasCookie",
      "code": "function hasCookie(name) {\n  return (';' + __DOCUMENT.cookie).replace(/;\\s+/g, ';').indexOf(';' + encodeURIComponent(name) + '=') >= 0;\n}",
      "description": "Determines if there is a cookie with the specified name.",
      "params": [
        {
          "name": "name",
          "description": "The name of the proposed cookie.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if a cookie with the specified `name` is found."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "info",
      "code": "function info() {\n  return { name: __VARIABLE_NAME, version: __VERSION, toString: YourJS.toString };\n}",
      "required": true,
      "description": "Gets the information for this version of YourJS.",
      "return": {
        "type": "Object",
        "description": "An object containing a `name` property and a `version` property."
      },
      "requires": [
        "toString"
      ],
      "params": [],
      "tests": []
    },
    {
      "name": "is",
      "code": "function is(x, y) {\n  x = x === y\n    ? x !== 0 || 1 / x == 1 / y // -0 vs 0\n    : (x != x && y != y); // NaN\n  return x && arguments.length > 2\n    ? is.apply(0, YourJS.slice(arguments, 1))\n    : x;\n}",
      "description": "Tests to see if two or more values are exactly the same. This is similar to `===` but will also indicate that `NaN` is `NaN` and will indicate that `-0` is not `0`.",
      "params": [
        {
          "name": "x",
          "description": "A value.",
          "type": "*"
        },
        {
          "name": "y",
          "description": "Values to be compared to `x` for equality.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if all of the parameters passed in are the same, otherwise `false` is returned."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isArrayLike",
      "code": "function isArrayLike(o) {\n  var l, i;\n  return !!o\n      && !o.nodeName\n      && typeOf(l = o.length) == 'Number'\n      && !['Function', 'String'].includes(typeOf(o))\n      && (!l || (l > 0 && (i = l - 1) % 1 == 0 && i in o));\n}",
      "description": "Determines if an object is an array or at least array-like.",
      "params": [
        {
          "name": "o",
          "description": "A value to test and see if it array-like.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating if the object was an array or array-like."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isLowerCase",
      "code": "",
      "description": "Determines if a string doesn't have upper cased characters.",
      "params": [
        {
          "name": "str",
          "description": "The value to be turned into a string and checked.",
          "type": "*"
        },
        {
          "name": "opt_allowNoCasing",
          "description": "If `true`, characters without casing found in `str` will be viewed as lower cased characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` only has cased characters that are lower cased or if `opt_allowNoCasing` is `true` and `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isMixCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isMixCase",
      "code": "eval('Mix   Lower Upper No'.replace(/\\w+/g, function(name, i) {\n  return 'function is' + name + 'Case(s,n){s=0 in arguments?s+\"\":\"\";return(s=(s==s.toLowerCase()?6:0)+(s==s.toUpperCase()?12:0))==' + i + '||(!!n&&s>12);}';\n}));",
      "description": "Determines if a string has both upper cased and lower cased characters.",
      "params": [
        {
          "name": "str",
          "description": "The value to be turned into a string and checked.",
          "type": "*"
        },
        {
          "name": "opt_allowNoCasing",
          "description": "If `true`, characters without casing found in `str` will be viewed as mixed cased characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` has mixed cased characters or if `opt_allowNoCasing` is `true` and `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isLowerCase",
        "isUpperCase",
        "isNoCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isNil",
      "code": "function isNil(value) {\n  return value == undefined;\n}",
      "description": "Determines if a value is either `null` or `undefined`.",
      "params": [
        {
          "name": "value",
          "description": "The value to be checked.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if value is either `null` or `undefined`. Otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "isNoCase",
      "code": "",
      "description": "Determines if a string only has characters without casing.",
      "params": [
        {
          "name": "str",
          "description": "The value to be turned into a string and checked.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isMixCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isNumeric",
      "code": "function isNumeric(value) {\n  return  'string' == typeof value && !value != __GLOBAL.isFinite(Number(value));\n}",
      "description": "Indicates if a value is a numeric string.",
      "params": [
        {
          "name": "value",
          "description": "Value to test.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean indicating whether or not `value` is a numeric string."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple True",
          "code": "test(YourJS.isNumeric('34.532'), true);"
        },
        {
          "name": "Simple False",
          "code": "test(YourJS.isNumeric('D34.532'), false);"
        }
      ]
    },
    {
      "name": "isRegExpMatch",
      "code": "function isRegExpMatch(rgx, opt_str, opt_onlyCheckStart) {\n  rgx = RegExp(rgx.source + '|([\\\\S\\\\s])', (rgx + '').replace(/[\\s\\S]+\\/|g/g, '') + 'g');\n  function f(str, opt_checkStartOnly) {\n    rgx.lastIndex = undefined;\n    opt_checkStartOnly = 1 in arguments ? opt_checkStartOnly : opt_onlyCheckStart;\n    var isMatch = false, match, keepGoing = 1;\n    while ((match = rgx.exec(str)) && keepGoing) {\n      isMatch = slice(match, -1)[0] == undefined;\n      keepGoing = isMatch && !opt_checkStartOnly;\n    }\n    return isMatch;\n  }\n  return opt_str == undefined ? f : f(opt_str, opt_onlyCheckStart);\n}",
      "description": "Determine whether or not a RegExp matches an entire string (or the start of a string).",
      "params": [
        {
          "name": "rgx",
          "description": "The regular expression to be used.",
          "type": "RegExp"
        },
        {
          "name": "opt_str",
          "description": "If specified, `rgx` will be matched against the string to see if the regular expression matches from the beginning. If not specified, a function will be returned that will be used to match against `rgx` whenever it is called.",
          "type": "string",
          "optional": true
        },
        {
          "name": "opt_onlyCheckStart",
          "description": "If `true`, `rgx` must only match the beginning of `opt_str`. If `false`, `rgx` must match the entire string `opt_str`.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean|Function",
        "description": "If `opt_str` is given and is not `null` or `undefined`, a boolean will be returned. If `opt_onlyCheckStart` is `true`-ish the value returned will indicate if `rgx` simply matched from the beginning of `opt_str`. If `opt_onlyCheckStart` is `false`-ish, the value returned will indicate if `rgx` matched all of `opt_str`. If `opt_str` is not given or `null` or `undefined` a function to match against `rgx` will be returned which will accept a string as the 1st argument that will act as `opt_str` would have and a 2nd optional argument which will act as `opt_onlyCheckStart` would have and will return a boolean indicating if `rgx` matches `str`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isSafeInt",
      "code": "var isSafeInt;\n(function(MAX_POSITIVE_INT) {\n  isSafeInt = function(value) {\n    return 'number' == typeof value && value % 1 == 0 && Math.abs(value) <= MAX_POSITIVE_INT;\n  };\n})(Math.pow(2,53) - 1);",
      "description": "Determines if the argument that is passed in is an integer in the range of `-9007199254740991` and `9007199254740991`.",
      "params": [
        {
          "name": "value",
          "description": "Value to test out.",
          "type": "number"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean indicating if `value` is an integer within the range of `-9007199254740991` and `9007199254740991`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple Positive Test",
          "code": "test(YourJS.isSafeInt(2384928359223), true);"
        },
        {
          "name": "Simple Negative Test",
          "code": "test(YourJS.isSafeInt(-238492234898359223), false);"
        },
        {
          "name": "Test Int",
          "code": "test(YourJS.isSafeInt(2.9223), false);"
        }
      ]
    },
    {
      "name": "isSpace",
      "code": "var isSpace = isRegExpMatch(/[ \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/);",
      "description": "Test for space characters starting at the beginning of a string.",
      "params": [
        {
          "name": "str",
          "description": "The string to be tested.",
          "type": "string"
        },
        {
          "name": "opt_onlyCheckStart",
          "description": "If `true`, only the beginning of the string is checked to see if it starts with a space character. If `false`, all of the string is checked to see if it only contains space characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if `opt_onlyCheckStart` is `true`-ish and `str` starts with a space character or if `opt_onlyCheckStart` is `false`-ish and `str` only contains space characters. Otherwise `false` is returned."
      },
      "requires": [
        "isRegExpMatch"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isType",
      "code": "function isType(value) {\n  value = typeOf(value);\n  for (var a = arguments, i = a.length; --i && a[i] != value; );\n  return i > 0;\n}",
      "description": "Determines if a value is of a specific type or one of a list of specific types.",
      "params": [
        {
          "name": "value",
          "description": "Value to determine if it matches any of the type names given.",
          "type": "*"
        },
        {
          "name": "typeName",
          "description": "Possible type names to match `value` against.",
          "type": "string",
          "rest": true
        }
      ],
      "return": {
        "type": "boolean",
        "description": "A boolean indicating if the type of `value` matched against any of the `typeName` arguments passed."
      },
      "requires": [
        "typeOf"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isUpperCase",
      "code": "",
      "description": "Determines if a string doesn't have lower cased characters.",
      "params": [
        {
          "name": "str",
          "description": "The value to be turned into a string and checked.",
          "type": "*"
        },
        {
          "name": "opt_allowNoCasing",
          "description": "If `true`, characters without casing found in `str` will be viewed as upper cased characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `str` only has cased characters that are upper cased or if `opt_allowNoCasing` is `true` and `str` only has characters without casing. Otherwise `false` is returned."
      },
      "requires": [
        "isMixCase"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "isWhitespace",
      "code": "var isWhitespace = isRegExpMatch(/[\\t-\\r\\x1C- \\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u205F\\u3000]/);",
      "description": "Test for whitespace characters starting at the beginning of a string.",
      "params": [
        {
          "name": "str",
          "description": "The string to be tested.",
          "type": "string"
        },
        {
          "name": "opt_onlyCheckStart",
          "description": "If `true`, only the beginning of the string is checked to see if it starts with a whitespace character. If `false`, all of the string is checked to see if it only contains whitespace characters.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Returns `true` if `opt_onlyCheckStart` is `true`-ish and `str` starts with a whitespace character or `if opt_onlyCheckStart` is `false`-ish and `str` only contains whitespace characters. Otherwise `false` is returned."
      },
      "requires": [
        "isRegExpMatch"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "join",
      "code": "function join(arr, opt_delimiter, opt_beforeEach, opt_afterEach) {\n  opt_beforeEach = opt_beforeEach || '';\n  opt_afterEach = opt_afterEach || '';\n  return arr.length\n    ? opt_beforeEach + arr.join(\n        opt_afterEach\n        + (opt_delimiter != undefined ? opt_delimiter : ',')\n        + opt_beforeEach\n      ) + opt_afterEach\n    : '';\n}",
      "description": "Glues the values of an array together to form a string.",
      "params": [
        {
          "name": "arr",
          "description": "The array containing the values to be glued together.",
          "type": "Array"
        },
        {
          "name": "opt_delimiter",
          "description": "The string to delimit each value in `arr`.",
          "type": "string",
          "optional": true,
          "default": "\",\""
        },
        {
          "name": "opt_beforeEach",
          "description": "The string to prepend to each value in `arr`.",
          "type": "string",
          "optional": true,
          "default": "\"\""
        },
        {
          "name": "opt_afterEach",
          "description": "The string to append to each value in `arr`.",
          "type": "string",
          "optional": true,
          "default": "\"\""
        }
      ],
      "return": {
        "type": "string",
        "description": "A string representation of `arr` with all of the values prefixed by `opt_beforeEach`, suffixed by `opt_afterEach` and separated by `opt_delimiter`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "keepAspectRatio",
      "code": "function keepAspectRatio(width, height, targetWidth, targetHeight, opt_maximize) {\n  targetWidth = Math[opt_maximize ? 'max' : 'min'](targetHeight * width / height, targetWidth);\n  return { width: targetWidth, height: targetWidth * height / width };\n}\n",
      "description": "Maximizes the dimensions while keeping the same aspect ratio.",
      "params": [
        {
          "name": "width",
          "description": "The base width.",
          "type": "number"
        },
        {
          "name": "height",
          "description": "The base height.",
          "type": "number"
        },
        {
          "name": "tagetWidth",
          "description": "The target width.",
          "type": "number"
        },
        {
          "name": "targetHeight",
          "description": "The target height.",
          "type": "number"
        },
        {
          "name": "opt_maximize",
          "description": "If `false`-ish, the minimum dimensions will be found where at least one of the dimensions matches the corresponding target dimension. If `true`-ish, the maximum dimensions will be found where at least one of the dimensions matches the corresponding target dimension.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Object",
        "description": "Object containing the minimum or maximum calculated width and height while keeping the same aspect ratio provided.  Eg. `{ height: 400, width: 320 }`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "limit",
      "code": "function limit(fn, opt_callLimit, opt_errorMessage) {\n  if (opt_callLimit == undefined) {\n    opt_callLimit = 1;\n  }\n  return function() {\n    if (opt_callLimit-- > 0) {\n      return fn.apply(this, arguments);\n    }\n    else if (opt_errorMessage) {\n      throw new Error(opt_errorMessage);\n    }\n  };\n}",
      "description": "Creates a wrapper function which when called will call the given function, but only a maximum amount of times as specified.",
      "params": [
        {
          "name": "fn",
          "description": "The function which will only be called a limited amount of times.",
          "type": "Function"
        },
        {
          "name": "opt_callLimit",
          "description": "The maximum amount of times the returned wrapper function can be called.",
          "type": "number",
          "optional": true,
          "default": "1"
        },
        {
          "name": "opt_errorMessage",
          "description": "If given, once the call limit is reached every subsequent call to the returned wrapper function will throw an error with this message.  If not given no error will be thrown.",
          "type": "string"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function that is limited in the amount of times it will call `fn`."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "log",
      "code": "var log;\n(function(realLog) {\n  log = function(x, base) { return realLog(x) / realLog(base); };\n})(Math.log10 || Math.log);",
      "description": "Gets the logarithm of any number in the specified base.  NOTE:  this function works best for values that don't rely on a base of `Math.E`.  If you want to find natural log it would be best to simply use `Math.log()`.",
      "params": [
        {
          "name": "x",
          "description": "The number for which the logarithm will be calculated.",
          "type": "number"
        },
        {
          "name": "base",
          "description": "The base of the calculated logarithm.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The logarithm of `x` for the specified `base`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.log(1000, 10), 3);"
        }
      ]
    },
    {
      "name": "matchAll",
      "code": "function matchAll(str, rgx, opt_fnMapper) {\n  var count = 0, matches = [];\n  str.replace(rgx, function(match) {\n    match = slice(arguments, 0, -1);\n    match.index = match.pop();\n    match.input = str;\n    match.source = rgx;\n    if (opt_fnMapper) {\n      match = opt_fnMapper(match, ++count);\n    }\n    if (match !== undefined) {\n      matches.push(match);\n    }\n  });\n  return matches.length ? matches : null;\n}",
      "description": "Gets all of the matches found when matching a regular expression against a string.",
      "params": [
        {
          "name": "str",
          "description": "String against which the regular expression should be matched.",
          "type": "string"
        },
        {
          "name": "rgx",
          "description": "Regular expression to match against `str`.",
          "type": "RegExp"
        },
        {
          "name": "opt_fnMapper",
          "description": "If specified the return value of this function will always be appended to the array which will be returned by `matchAll()` unless `undefined` is the return value.  The 1st argument passed will be an array representing the matches array that was found.  The 2nd argument passed will be the amount of times this mapper has been called.",
          "type": "function(Array,number)",
          "optional": true
        }
      ],
      "return": {
        "type": "Array|null",
        "description": "If `rgx` matched a substring in `str` at least once and `opt_fnMapper` wasn't used, an array of all of the matches will be returned. Each match will at least have `match[0]`, `match.index` (the starting index of the found match within `str`), `match.source` (`rgx`) and `match.input` (`str`). If capture groups were specified in `rgx`, each will be found in its corresponding index starting with `match[1]`. If no matches were found, `null` is returned."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "mixin",
      "code": "",
      "description": "Adds a new function to the YourJS object and to `YourJSChain`'s prototype.",
      "params": [
        {
          "name": "fn",
          "description": "The function to add to the YourJS object.",
          "type": "Function"
        },
        {
          "name": "name",
          "description": "The name to give to the function under the YourJS object and under the `YourJSChain`'s prototype.",
          "type": "string"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean value indicating if the function could be added."
      },
      "requires": [
        "chain"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "mod",
      "code": "function mod(dividend, divisor) {\n  return (dividend % divisor + divisor) % divisor;\n}",
      "description": "Get the remainder after dividing 2 numbers while making sure the remainder is always between 0 and the divisor..",
      "params": [
        {
          "name": "dividend",
          "description": "Number to be divided.",
          "type": "number"
        },
        {
          "name": "divisor",
          "description": "Number to divide by.",
          "type": "number"
        }
      ],
      "return": {
        "description": "Remainder after dividing the dividend by the divisor.",
        "type": "number"
      },
      "tests": [
        {
          "name": "Basic Integer",
          "code": "test(YourJS.mod(5, 3), 5 % 3)"
        },
        {
          "name": "Negative Integer",
          "code": "test(YourJS.mod(-6, 5), 4)"
        }
      ],
      "requires": [],
      "required": false
    },
    {
      "name": "modRegExp",
      "code": "function modRegExp(rgx, modifiers) {\n  var flags = (rgx + '').replace(/[\\s\\S]+\\//, '');\n  modifiers.replace(/([-+!]?)(\\w)/g, function(index, op, flag) {\n    index = flags.indexOf(flag)\n    flags = op == '-' || (op == '!' && index >= 0)\n      ? flags.replace(flag, '')\n      : index < 0\n        ? flags + flag\n        : flags;\n  });\n  return new RegExp(rgx.source, flags);\n}\n",
      "description": "Creates a new copy of a regular expression with modified flags.",
      "params": [
        {
          "name": "rgx",
          "description": "The regular expression to be duplicated with modified flags.",
          "type": "RegExp"
        },
        {
          "name": "modifiers",
          "description": "Specifies how to modify the flags of the duplicate of `rgx`. The standard flags are of course `g` for global, `i` for ignoreCase and `m` for multiline. In some environments other flags are also available. In order to assure that the duplicate will have specified flag you can just add the flag character (optionally you can prefix it with a `+`) to the string. In order to assure that the duplicate will exclude a specified flag you can enter - followed by the flag character in this string. In order to toggle the flag in the duplicate you can prefix the flag character with !. For example `\"g-i!m\"` (which is the same as `\"+g-i!m\"`) will ensure the `g` flag is included, ensure the `i` flag is excluded and toggle `m`.",
          "type": "string",
          "optional": true
        }
      ],
      "return": {
        "type": "RegExp",
        "description": "Returns a duplicate of `rgx` with modified flags as specified by the `modifiers` string."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "not",
      "code": "function not(x) { return !x; }",
      "description": "Apply the boolean negation operator to a value.",
      "params": [
        {
          "name": "x",
          "description": "The value to use boolean negation on.",
          "type": "*"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` if `x` was `false`-like or `false` if `x` was `true`-like."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "nth",
      "code": "function nth(arr, n) {\n  return arr[n < 0 ? arr.length + n : n];\n}",
      "description": "Gets the value at the specified position in an array or an array-like object.",
      "params": [
        {
          "name": "arr",
          "description": "Array or array-like object from which to pull the value.",
          "type": "Array|Arguments|Object"
        },
        {
          "name": "n",
          "description": "The position from which the value should be pulled.  If this is a negative number the position will be calculated from the end of `arr`.",
          "type": "number"
        }
      ],
      "return": {
        "type": "*",
        "description": "Value at position `n`."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var arr = [5,8,2,13];\ntest(YourJS.nth(arr, 3), arr[3]);"
        },
        {
          "name": "Negative Position",
          "code": "var arr = [5,8,2,13];\ntest(YourJS.nth(arr, -3), arr.slice(-3)[0]);"
        }
      ]
    },
    {
      "name": "ordinalize",
      "code": "var ordinalize;\n(function() {\n  ordinalize = function(num, opt_excludeNum) {\n    var ones = num % 10;\n    return (opt_excludeNum ? '' : num) + ((num % 100 - ones - 10 ? [0,'st','nd','rd'][ones] : 0) || 'th');\n  };\n})([0,'st','nd','rd']);",
      "description": "Get the ordinal for an integer (`st`, `nd`, `rd`, or `th`).",
      "params": [
        {
          "name": "num",
          "description": "Number for which to get the ordinal.",
          "type": "number"
        },
        {
          "name": "opt_excludeNum",
          "description": "Indicates whether or not to exclude `num` from the return value.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "string",
        "description": "If `opt_excludeNum` is `false`-ish a string version of `num` with the appropriate ordinal string will be returned.  If `opt_excludeNum` is `true`-ish just the ordinal corresponding to `num` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "padEnd",
      "code": "function padEnd(str, maxLength, opt_fillString) {\n  str += '';\n\n  var filler, fillLen, stringLength = str.length;\n\n  return maxLength > stringLength\n    ? (\n        filler = (opt_fillString !== undefined ? opt_fillString + '' : '') || ' ',\n        fillLen = maxLength - stringLength,\n        str + (new Array(Math.ceil(fillLen / filler.length) + 1)).join(filler).slice(0, fillLen)\n      )\n    : str;\n}",
      "description": "Appends a string with a filler string so that the length of the string is always at least a certain length.",
      "params": [
        {
          "name": "str",
          "description": "The string to append a filler string to.",
          "type": "string"
        },
        {
          "name": "maxLength",
          "description": "The maximum length allowed for the returned string. If this is less than `str.length`, this will be set to `str.length`.",
          "type": "number"
        },
        {
          "name": "opt_fillString",
          "description": "The string to repeatedly append to `str` until the length reaches `maxLength`.",
          "type": "string",
          "optional": true,
          "default": "\" \""
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns `str` with the filler string appended to it as many times as necessary until `maxLength` is reached."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "padStart",
      "code": "function padStart(str, maxLength, opt_fillString) {\n  str += '';\n\n  var filler, fillLen, stringLength = str.length;\n\n  return maxLength > stringLength\n    ? (\n        filler = (opt_fillString !== undefined ? opt_fillString + '' : '') || ' ',\n        fillLen = maxLength - stringLength,\n        (new Array(Math.ceil(fillLen / filler.length) + 1)).join(filler).slice(0, fillLen) + str\n      )\n    : str;\n}",
      "description": "Prepends a string with a filler string so that the length of the string is always at least a certain length.",
      "params": [
        {
          "name": "str",
          "description": "The string to prepend a filler string to.",
          "type": "string"
        },
        {
          "name": "maxLength",
          "description": "The maximum length allowed for the returned string. If this is less than `str.length`, this will be set to `str.length`.",
          "type": "number"
        },
        {
          "name": "opt_fillString",
          "description": "The string to repeatedly prepend to `str` until the length reaches `maxLength`.",
          "type": "string",
          "optional": true,
          "default": "\" \""
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns `str` with the filler string prepended to it as many times as necessary until `maxLength` is reached."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "partial",
      "code": "function partial(fn, arrPresetArgs, opt_presetFromRight) {\n  return opt_presetFromRight\n    ? function() { return fn.apply(this, slice(arguments).concat(arrPresetArgs)); }\n    : function() { return fn.apply(this, arrPresetArgs.concat(slice(arguments))); };\n}",
      "description": "Creates a copy of a function with the left-most arguments preset.",
      "params": [
        {
          "name": "fn",
          "description": "The function whose left-most arguments should be preset.",
          "type": "Function"
        },
        {
          "name": "arrPresetArgs",
          "description": "An array containing all of the arguments to always be passed to the returned version of `fn`.",
          "type": "Array",
          "optional": false
        },
        {
          "name": "opt_presetFromRight",
          "description": "Boolean indicating if the preset arguments should always be passed after all other arguments.  If `false` all preset arguments will precede the other arguments passed.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function which essentially acts as `fn` with the `arrPresetArgs` already being sent.  The arguments in `arrPresetArgs` will be sent as the left-most arguments if `opt_presetFromRight` is not specified or `false`-ish, otherwise they will be sent as the right-most arguments."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "partialAny",
      "code": "function partialAny(fn, objArgPresets) {\n  var objThis, objThisGiven, arrPresets = [];\n  forIn(objArgPresets, function(value, key) {\n    if (key == 'this') {\n      objThis = value;\n      objThisGiven = 1;\n    }\n    else if (isFinite(key = +key) && key == ~~key) {\n      arrPresets.push([key, value]);\n    }\n  });\n  arrPresets.sort(function(a, b) {\n    a = 1 / a[0];\n    b = 1 / b[0];\n      return (a < 0 && b < 0) ? b - a : (a - b);\n  });\n  return function() {\n    for (var preset, arrArgs = slice(arguments), i = arrPresets.length; i--; ) {\n      preset = arrPresets[i];\n      arrArgs.splice(preset[0] || (1/preset[0] < 0 ? Infinity : 0), 0, preset[1]);\n    }\n    return fn.apply(objThisGiven ? this : objThis, arrArgs);\n  };\n}",
      "description": "Creates a partial function where the arguments in any position can be set.  Also allows for setting the value of `this`.",
      "params": [
        {
          "name": "fn",
          "description": "Function to return a partial version of.",
          "type": "Function"
        },
        {
          "name": "objArgPresets",
          "description": "Object whose properties will be used to preset the arguments within the partial function.  Each property name that is a positive integer will be used to fill in arguments from the left while property names that are negative integers (including `-0`) will be used to fill in arguments from the right.  If a property is named `this` it will be used to specify the `this` context object of the partial function.",
          "type": "Object",
          "optional": false
        }
      ],
      "return": {
        "type": "Function",
        "description": "A partial version of `fn` with the arguments specified in `objArgPresets` already set."
      },
      "requires": [
        "slice",
        "forIn"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "paste",
      "code": "function paste(str, newPart, startIndex, opt_endIndex) {\n  str = cut(str, startIndex, opt_endIndex == undefined ? startIndex : opt_endIndex);\n  return str.slice(0, startIndex) + newPart + str.slice(startIndex);\n}",
      "description": "Pastes a string into another string while possibly replacing part of the string being pasted into.",
      "params": [
        {
          "name": "str",
          "description": "String to be modified.",
          "type": "string"
        },
        {
          "name": "newPart",
          "description": "String to be pasted into `str`.",
          "type": "string"
        },
        {
          "name": "startIndex",
          "description": "Index within `str` indicating where to paste `newPart`.",
          "type": "number"
        },
        {
          "name": "opt_endIndex",
          "description": "Index within `str` indicating where the end of `newPart` will end.",
          "type": "number",
          "optional": true,
          "default": "startIndex"
        }
      ],
      "return": {
        "type": "string",
        "description": "A copy of `str` modified so that `newPart` is pasted into it from `startIndex` to `opt_endIndex`."
      },
      "requires": [
        "cut"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "pluck",
      "code": "function pluck(arr, propName) {\n  for (var item, negPropName = propName < 0 && ~~propName === propName, result = [], i = arr.length; i--;) {\n    item = arr[i];\n    if (has(arr, i)) {\n      result[i] = item == undefined\n        ? item\n        : item[(negPropName && isFinite(item.length)) ? propName + item.length : propName];\n    }\n  }\n  return result;\n}",
      "description": "Creates a copy of the given array making each item the value of the given property name.",
      "params": [
        {
          "name": "arr",
          "description": "Array to copy.",
          "type": "Array"
        },
        {
          "name": "propName",
          "description": "Name of the property of each array item that will replace the corresponding array item.  If this is a negative number and the array items are arrays this will be used as the index counting from the end of those arrays.",
          "type": "string|number",
          "optional": false
        }
      ],
      "return": {
        "type": "Array",
        "description": "Copy of `arra` where each item is replaced by one of its properties as specified by `propName`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": [
        {
          "name": "Length property",
          "code": "var arr = ['My', 'name', 'is', 'John', 'Smith.'];\nvar lengths = [2,4,2,4,6];\ntest(YourJS.pluck(arr, 'length').join(''), lengths.join(''));"
        }
      ]
    },
    {
      "name": "prefix",
      "code": "function prefix(str, strPrefix, opt_rgxTester) {\n  return str == undefined\n    ? function(str) { return prefix(str, strPrefix, opt_rgxTester); }\n    : (opt_rgxTester ? !opt_rgxTester.test(str) : str.indexOf(strPrefix))\n      ? strPrefix + str\n      : str;\n}",
      "description": "Always ensures that a string starts with a specific substring.",
      "params": [
        {
          "name": "str",
          "description": "This will be the string to which the prefix will be prepended unless the test proves that it doesn't need to be prepended.  Specifying `undefined` or `null` will cause a partial function to be returned.",
          "type": "string|undefined|null"
        },
        {
          "name": "strPrefix",
          "description": "This will be the prefix to add to `str` if it needs to be added.",
          "type": "string",
          "optional": false,
          "default": ""
        },
        {
          "name": "opt_rgxTester",
          "description": "Regular expression to test against the string to be prefixed.  If the string tests negative against this regular expression `strPrefix` will be prepended to the beginning of it.",
          "type": "RegExp",
          "optional": true
        }
      ],
      "return": {
        "type": "string|function(string)",
        "description": "If `str` is not given a partial function will be returned which will await the string value of `str`.  If `opt_rgxTester` isn't given, the `str` will be returned and it will be prefixed with `strPrefix` if it isn't already at the beginning of it.  If `opt_rgxTester` is given and `str` tests negative against it `str` prefixed with `strPrefix` will be returned.  Otherwise `str` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var path1 = 'google.com', path2 = 'http://bing.com';\ntest(\n  YourJS.prefix(path1, 'http://') + ' ' + YourJS.prefix(path2, 'http://'),\n  'http://google.com http://bing.com'\n);"
        },
        {
          "name": "Partial",
          "code": "var path1 = 'google.com/', path2 = 'http://bing.com/';\nvar prefixHTTP = YourJS.prefix(undefined, 'http://');\ntest(\n  prefixHTTP(path1) + ' ' + prefixHTTP(path2),\n  'http://google.com/ http://bing.com/'\n);"
        },
        {
          "name": "Partial #2",
          "code": "var path1 = 'google.com/', path2 = 'https://bing.com/';\nvar prefixHTTP = YourJS.prefix(undefined, 'http://', /^https?:\\/\\//);\ntest(\n  prefixHTTP(path1) + ' ' + prefixHTTP(path2),\n  'http://google.com/ https://bing.com/'\n);"
        }
      ]
    },
    {
      "name": "quoteRegExp",
      "code": "function quoteRegExp(str, opt_flagsOrMakeRegExp) {\n  var ret = str.replace(/[[\\](){}.+*^$|\\\\?-]/g, '\\\\$&');\n  return (opt_flagsOrMakeRegExp === '' || opt_flagsOrMakeRegExp)\n    ? new RegExp(ret, opt_flagsOrMakeRegExp === true ? '' : opt_flagsOrMakeRegExp)\n    : ret;\n}",
      "description": "Turn any string into a regular expression that matches the exact string without worrying about encoding the metacharacters yourself.",
      "params": [
        {
          "name": "str",
          "description": "The string that should be modified so that any characters that would normally serve as metacharacters in a regular expression will be escaped.",
          "type": "string"
        },
        {
          "name": "flagsOrMakeRegExp",
          "description": "If not specified or if `false`, it will cause just the escaped version of `str` to be returned. If `true`, it will be as if the empty string was passed in. A string represents the flags to be set in the returned regular expression.",
          "type": "boolean|string",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "RegExp|string",
        "description": "If `flagsOrMakeRegExp` is `true` a regular expression without flags will be returned. If `flagsOrMakeRegExp` is a non-empty string, a regular expression with the specified characters representing the corresponding flags will be returned. In all other cases just the escaped string that can be used as a regular expression will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "random",
      "code": "function random(arrOrMinOrMax, opt_max, opt_round) {\n  if ('number' == typeof arrOrMinOrMax) {\n    if ('boolean' == typeof opt_max) {\n      opt_round = opt_max;\n      opt_max = undefined;\n    }\n    if (opt_max === undefined) {\n      opt_max = arrOrMinOrMax;\n      arrOrMinOrMax = 0;\n    }\n    arrOrMinOrMax = Math.random() * (opt_max - arrOrMinOrMax) + arrOrMinOrMax;\n    return opt_round ? Math.trunc(arrOrMinOrMax) : arrOrMinOrMax;\n  }\n  return arrOrMinOrMax[random(0, arrOrMinOrMax.length, 1)];\n}",
      "description": "Either generates a random number or pulls a random value from an array.",
      "params": [
        {
          "name": "arrOrMinOrMax",
          "description": "If an array, a random item from it will be returned.  If this is a number and `opt_max` is either not given or boolean this will be seen as the maximum value.  Otherwise this will be seen as the minimum value that can be returned.",
          "type": "Array|number"
        },
        {
          "name": "opt_max",
          "description": "If this is a number it will be interpreted as the maximum value.  The maximum value will never be returned because a random number between the minimum value (inclusive) and the maximum value (exclusive) is always returned.  If this is a boolean it will be used as `opt_truncate` and the maximum will come from `arrOrMinOrMax` thus setting `0` to `arrOrMinOrMax`.",
          "type": "number|boolean",
          "optional": true
        },
        {
          "name": "opt_truncate",
          "description": "If `true`-ish and `arrOrMinOrMax` wasn't an array the returned value will be truncated.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "*",
        "description": "If `arrOrMinOrMax` is an array a random value from the array will be returned, otherwise a random number in the given range will be returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "range",
      "code": "function range(startOrStop, opt_stop, opt_step) {\n  if (arguments.length < 2) {\n    opt_stop = startOrStop;\n    startOrStop = 0;\n  }\n  for (var ret = [], t = (opt_step = opt_step || 1) > 0; t ? startOrStop < opt_stop : startOrStop > opt_stop; startOrStop += opt_step) {\n    ret.push(startOrStop);\n  }\n  return ret;\n}",
      "description": "Creates an array of numbers within a given range.",
      "params": [
        {
          "name": "startOrStop",
          "description": "The starting point of the range to return.  If this is the argument argument passed the value will be used as `opt_stop` and this will become `0`.",
          "type": "number"
        },
        {
          "name": "opt_stop",
          "description": "The non-inclusive boundary of the range.  This value will not be included in the returned array.  The value is pulled from `startOrStop` if not specified.",
          "type": "number",
          "optional": true,
          "default": "startOrStop"
        },
        {
          "name": "opt_step",
          "description": "The difference between each subsequent number in the range.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array.<number>",
        "description": "Returns an array of all of the numbers in the range. If `opt_step` >= `0` but `startOrStop` >= `opt_stop`, an empty array will be returned. Also, if `opt_step` <= `0`, but `startOrStop` <= `opt_stop`, an empty array will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple 1 Arg",
          "code": "test(YourJS.range(5).join(''), '01234');"
        },
        {
          "name": "Simple 2 Args",
          "code": "test(YourJS.range(5,10).join(','), '5,6,7,8,9');"
        },
        {
          "name": "Simple 3 Args",
          "code": "test(YourJS.range(10,5,-1).join('|'), '10|9|8|7|6');"
        }
      ]
    },
    {
      "name": "rearg",
      "code": "function rearg(fn, indices, opt_restIndex) {\n  var normalIndices = indices.map(function(v,i){return '$' + i;}).join(','),\n      modifiedIndices = indices.map(function(v, i) {\n        return '$' + (v == undefined ? i : v);\n      }).join(',');\n  return Function('f,s', 'return function(' + normalIndices + '){return f.apply(this, [' + modifiedIndices + '].concat(s(arguments,' + (opt_restIndex == undefined ? indices.length : opt_restIndex) + ')))}')(fn,slice);\n}",
      "description": "Creates a new wrapper function that will call the original the arguments in a different order.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be wrapped and called with the arguments in a different order.",
          "type": "Function"
        },
        {
          "name": "indices",
          "description": "Indices of the arguments to be passed.  If the you want `fn(a,b,c)` to always be called as `fn(c,a,b)` you can supply `[2,0,1]`.",
          "type": "Array.<number>"
        },
        {
          "name": "opt_restIndex",
          "description": "The starting index of the rest of the arguments that will be allowed to be passed in after those specified by `indices`.  If `Infinity`, no more arguments will be passed no matter how many are sent to the wrapper function.  If `undefined`, `indices.length` will be used.",
          "type": "number",
          "optional": true,
          "default": "indices.length"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The wrapper function that will call `fn` with the arguments in the specified order."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "repay",
      "code": "function repay(input) {\n  var args = arguments;\n  return Function('s,i,a', 'return function(){return ' + (args.length - 1 ? 's(a)' : 'i') + '}')(slice, input, args);\n}",
      "description": "Produces a function that when called will simply return was was passed in.",
      "params": [
        {
          "name": "input",
          "description": "Zero or more arguments that will be returned by function made by this `repay` function.",
          "type": "*",
          "rest": true,
          "optional": true
        }
      ],
      "return": {
        "type": "Function",
        "description": "A function that when called will return all `input` arguments originally passed to the `repay` function.  If only one `input` was passed, calling this returned function will simply return that one `input` argument.  In all other cases an array containing all `input` arguments will be returned when this returned function is called."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "replace",
      "code": "var replace;\n(function(breakError) {\n  function end() { throw breakError; }\n  replace = function(subject, target, replacer) {\n    var match, matches, i, l,\n        count = 0,\n        replacement = replacer,\n        targetType = typeOf(target = 'string' == typeof target ? [target] : target),\n        targetIsRegExp = targetType == 'RegExp',\n        isObject = !targetIsRegExp && targetType != 'Array',\n        rgx = targetIsRegExp ? target : new RegExp(\n          (isObject ? Object.keys(target) : target).map(function(v){return quoteRegExp(v);}).join('|'),\n          'g'\n        ),\n        result = subject;\n\n    try {\n      for (matches = matchAll(subject, rgx), i = 0, l = matches.length; i < l; i++) {\n        match = matches[i];\n        if (isObject) {\n          replacer = target[match];\n        }\n        if ('function' == typeof replacer) {\n          replacement = replacer.call(result, match, ++count, end);\n        }\n        result = result.slice(0, match.index) + replacement + result.slice(match.index + match[0].length);\n      }\n    }\n    catch (e) {\n      if (e != breakError) {\n        throw e;\n      }\n    }\n\n    return result;\n  };\n})({});",
      "description": "Replace targeted substrings with new strings.",
      "params": [
        {
          "name": "subject",
          "description": "String to be modified and returned.",
          "type": "string"
        },
        {
          "name": "target",
          "description": "If this is a string each instance of this string will be found within `subject` and replaced by the result of `replacer`.  If this is an array each of the contents will be searched for within `subject` and replaced by the result of `replacer`.  If this is an object each key will be searched for and replaced by the result of the corresponding value.  If the corresponding value of an object's property is a function it will be executed the same way `replacer` would be.",
          "type": "Array|Object|string"
        },
        {
          "name": "replacer",
          "description": "If a function is supplied it will be called for each `target` found with argument 1 being the match array (including `match.input`, `match.index`, and `match.source`), argument 2 being the iteration count and argument 3 being a function that when executed will immediately stop replacing values.  If a string is supplied it will replace all instances of `target` within `subject`.  This parameter can be omitted and will be ignored if `target` is an object.",
          "type": "function(Array,number,Function)|string",
          "optional": false
        }
      ],
      "return": {
        "type": "string",
        "description": "`subject` with all of the targeted substrings replaced with new strings as specified either by `target` or `replacer`."
      },
      "requires": [
        "matchAll",
        "typeOf",
        "quoteRegExp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "restParam",
      "code": "function restParam(fn, opt_start) {\n  opt_start = opt_start == undefined ? fn.length - 1 : opt_start;\n  return function() {\n    var args = slice(arguments);\n    return fn.apply(this, args.length < opt_start ? args : slice(args, 0, opt_start).concat([slice(args, opt_start)]));\n  }\n}",
      "description": "Creates a wrapper function that if called with more arguments than specified, those arguments will be passed in as an array in the final argument.",
      "params": [
        {
          "name": "fn",
          "description": "The function to call with the normal parameters followed by the rest parameter in its place as specified by `opt_start`.",
          "type": "Function"
        },
        {
          "name": "opt_start",
          "description": "The index within the arguments passed to the returned function that will start the summary of the rest parameter.",
          "type": "number",
          "optional": true,
          "default": "fn.length-1"
        }
      ],
      "return": {
        "type": "Function",
        "description": "Returns a function that when invoked will call `fn`, but if there are any that have an index greater or equal to `opt_start` they will be passed in as the last parameter which will be an array."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "round",
      "code": "eval('var ceil,floor,round');\n'ceil floor round'.replace(/\\w+/g, function(fnName, RGX_NUM_BOUNDS, RGX_EXTRA_DOT) {\n  RGX_NUM_BOUNDS = /^-?|$/g;\n  RGX_EXTRA_DOT = /(\\.\\d*)\\./;\n  eval('(function(x){' + fnName + '=x})')(function(num, opt_precision) {\n    opt_precision = opt_precision || 0;\n    var absPrecision = Math.abs(opt_precision);\n    var zeroesSub = '$&' + new Array(absPrecision + 2).join('0');\n    var rgxGrow = new RegExp('(\\\\.)(\\\\d{' + absPrecision + '})');\n    var rgxShrink = new RegExp('(\\\\d{' + absPrecision + '})(\\\\.)');\n    num = (num + '.').replace(RGX_NUM_BOUNDS, zeroesSub)\n      .replace(RGX_EXTRA_DOT, '$1')\n      .replace(opt_precision < 0 ? rgxShrink : rgxGrow, '$2$1');\n    num = (Math[fnName](+num) + '.').replace(RGX_NUM_BOUNDS, zeroesSub)\n      .replace(RGX_EXTRA_DOT, '$1')\n      .replace(opt_precision < 0 ? rgxGrow : rgxShrink, '$2$1');\n    return +num;\n  });\n});",
      "description": "Rounds with the specified precision.",
      "params": [
        {
          "name": "num",
          "description": "The number to be rounded.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number. Using the precision is similar to doing `Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision)`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "Returns `num` rounded with the specified precision."
      },
      "requires": [
        "ceil",
        "floor"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "roundIn",
      "code": "eval('var roundIn,roundOut;');\n'In<Out>'.replace(/(\\w+)(.)/g, function(_, fnEnding, op) {\n  eval('(function(c,f){round' + fnEnding + '=function(n,p){return(+n' + op + '0?c:f)(n,p)}})')(ceil, floor);\n});",
      "description": "Rounds a number towards `0`.",
      "params": [
        {
          "name": "num",
          "description": "Number to round towards `0`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number towards `0`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "`num` rounded towards `0`."
      },
      "requires": [
        "ceil",
        "floor",
        "roundOut"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "roundOut",
      "code": "",
      "description": "Rounds a number towards `0`.",
      "params": [
        {
          "name": "num",
          "description": "Number to round away from `0`.",
          "type": "number"
        },
        {
          "name": "opt_precision",
          "description": "The precision (as an integer) with which to round the number away from `0`.",
          "type": "number",
          "optional": true,
          "default": "0"
        }
      ],
      "return": {
        "type": "number",
        "description": "`num` rounded away from `0`."
      },
      "requires": [
        "roundIn"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "sample",
      "code": "// Done this way to account for partially or fully empty arrays\nfunction sample(arr, opt_count) {\n  var t, j, result = [], l = arr.length, i = l;\n  if (l) {\n    for (opt_count = Math.max(1, Math.min(opt_count || 1, l)); i--, result[i] = i;);\n    for (i = l; opt_count > l - i; ) {\n      j = Math.round(Math.random() * --i);\n      if (i && i != j) {\n        t = result[i];\n        result[i] = result[j];\n        result[j] = t;\n      }\n      if (has(arr, result[i])) {\n        result[i] = arr[result[i]];\n      }\n      else {\n        delete result[i];\n      }\n    }\n  }\n  return slice(result, -opt_count);\n}",
      "description": "Takes an array and returns a new array with some or all of the original values not usually in the same order.",
      "params": [
        {
          "name": "arr",
          "description": "Array to create a new sample array from.",
          "type": "Array"
        },
        {
          "name": "opt_count",
          "description": "Number of items to put in the sample array.  Cannot exceed `arr.length`.",
          "type": "number",
          "optional": true,
          "default": "1"
        }
      ],
      "return": {
        "type": "Array",
        "description": "Sample array of random elements picked from `arr`."
      },
      "requires": [
        "has",
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "sec",
      "code": "eval('seccos;cscsin;cottan;'.replace(/(...)(?=(...)?;)/g, function(m, name, base, i) {\n  return 'function ' + name + '(a,b){return ' + (base ? '1/' : '') + 'Math.' + (base || name) + '(b?a*'+Math.PI/180+':a)}';\n}));",
      "description": "Determines the secant of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose secant value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The secant of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the secant of `angle` in degrees will be returned."
      },
      "requires": [
        "cos",
        "csc",
        "sin",
        "cot",
        "tan"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "set",
      "code": "function set(obj, opt_name, opt_value) {\n  var t1, t2,\n      needsObj = obj == undefined,\n      needsName = opt_name == undefined,\n      needsValue = arguments.length < 3;\n  if (needsObj || needsName || needsValue) {\n    t1 = ['b','a'];\n    t2 = { x: needsObj, y: needsName, z: needsValue };\n    return Function(\n      's,x,y,z',\n      'return function(a,b){return s(x,y,z)}'.replace(/x|y|z/g, function(m){return t2[m]?t1.pop():m}).replace(t1[0] ? '' : ',b', '')\n    )(set, obj, opt_name, opt_value);\n  }\n  t1 = obj[opt_name];\n  obj[opt_name] = opt_value;\n  return t1;\n}",
      "description": "Set the value of a property on an object.",
      "params": [
        {
          "name": "obj",
          "description": "Object whose property will be set.",
          "type": "*"
        },
        {
          "name": "opt_name",
          "description": "Name of the property to be set.",
          "type": "string|undefined",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_value",
          "description": "Value to which the property will be set.",
          "type": "*",
          "optional": true,
          "default": ""
        }
      ],
      "return": {
        "type": "*",
        "description": "If all 3 arguments are given the previous property value will be returned.  If one or more arguments are missing a partial function will be returned that will accept the remaining arguments."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "setCookie",
      "code": "function setCookie(name, value, opt_options) {\n  opt_options = opt_options || {};\n  var maxAge = opt_options['max-age'] || opt_options.maxAge,\n    expires = maxAge ? +new Date + maxAge * 1000 : opt_options.expires,\n    path = opt_options.path,\n    domain = opt_options.domain,\n    secure = opt_options.secure;\n  __DOCUMENT.cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value)\n    + (expires ? \"; expires=\" + (new Date(expires)).toGMTString() : \"\")\n    + (path ? \"; path=\" + path : \"; path=/\")\n    + (domain ? \"; domain=\" + opt_options.domain : \"\")\n    + (secure ? \"; secure\" : \"\");\n  return hasCookie(name);\n}",
      "description": "Takes the name of a cookie and sets its value.",
      "params": [
        {
          "name": "name",
          "description": "Name of the cookie to set.",
          "type": "string"
        },
        {
          "name": "value",
          "description": "Value of the cookie to set.  If not a string, it will be coerced into a string.",
          "type": "string"
        },
        {
          "name": "opt_options",
          "description": "Object whose property values can be used to specify additional options.  If the cookie is meant to expire at a certain time you can set the `expires` property to a `Date` object or the number representation of such a date.  If you want to specify the maximum amount of seconds until the cookie expires you can set the `maxAge` (or `max-age`) property to the number of seconds.  If you want to specify the hosts to which the cookie will be sent you can set the `domain` property.  If a domain is specified, subdomains are always included.  If you want to specify the URL path that under which the cookie will be saved you can specify it in the `path` property.  If you want to set a secure cookie while on a secure site (`https:`) you can set the `secure` property to `true`.",
          "type": "Object",
          "optional": true,
          "default": "{path:'/'}"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "Boolean indicating whether or not the cookie was set."
      },
      "requires": [
        "hasCookie"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "shuffle",
      "code": "// Done this way to account for partially or fully empty arrays\nfunction shuffle(arr) {\n  for (var t, j, result = [], l = arr.length, i = l; i--, result[i] = i;);\n  for (i = l; i; ) {\n    j = Math.round(Math.random() * --i);\n    if (i && i != j) {\n      t = result[i];\n      result[i] = result[j];\n      result[j] = t;\n    }\n    if (has(arr, result[i])) {\n      result[i] = arr[result[i]];\n    }\n    else {\n      delete result[i];\n    }\n  }\n  return result;\n}",
      "description": "Creates a new array with the items in a random order.",
      "params": [
        {
          "name": "arr",
          "description": "Array to copy and shuffle.",
          "type": "Array"
        }
      ],
      "return": {
        "type": "Array",
        "description": "Shuffled copy of `arr`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "sin",
      "code": "",
      "description": "Determines the sine of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose sine value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The sine of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the sine of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "slice",
      "code": "var slice = alias(__EMPTY_ARRAY.slice, 'call');",
      "description": "Slice does not modify the original array, but instead returns a shallow copy of elements from the original array.",
      "params": [
        {
          "name": "array",
          "description": "Array or array-like object to shallow copy.",
          "type": "Array|Arguments|Object"
        },
        {
          "name": "begin",
          "description": "Zero-based index at which to begin extraction.  A negative index can be used, indicating an offset from the end of the sequence. `slice(array,-2)` extracts the last two elements in the sequence.  If `begin` is `undefined`, slice begins from index `0`.",
          "type": "number",
          "optional": true,
          "default": 0
        },
        {
          "name": "end",
          "description": "Zero-based index before which to end extraction. slice extracts up to but not including `end`.  For example, `slice(array,1,4)` extracts the second element through the fourth element (elements indexed 1, 2, and 3).  A negative index can be used, indicating an offset from the end of the sequence. `slice(array,2,-1)` extracts the third element through the second-to-last element in the sequence.  If `end` is omitted, `slice` extracts through the end of the sequence (`array.length`).  If `end` is greater than the length of the sequence, slice extracts through the end of the sequence (`array.length`).",
          "type": "number",
          "optional": true,
          "default": "array.length"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A new array containing the extracted elements."
      },
      "requires": [
        "alias"
      ],
      "tests": [],
      "required": false
    },
    {
      "name": "sortBy",
      "code": "function sortBy(array, criteria, opt_comparer) {\n  opt_comparer = opt_comparer || compare;\n  var i, j, t, c, cLen, tArray = [], cType = typeOf(criteria);\n  if (cType == 'String') {\n    cType = 'Array';\n    criteria = criteria.split('.');\n    cLen = criteria.length;\n  }\n  for (tArray = [], i = array.length; i--;) {\n    tArray[i] = t = { v: array[i], c: array[i] };\n    if (cType == 'Array') {\n      for (j = 0; j < cLen; j++) {\n        if (t.c != undefined) {\n          c = criteria[j];\n          t.c = t.c[(c < 0 && 'number' == typeof t.c.length) ? t.c + c : t.c];\n        }\n      }\n    }\n    else if (cType == 'Function') {\n      t.c = criteria(t.c);\n    }\n  }\n  return tArray.sort(function(a, b) {\n    return opt_comparer(a.c, b.c);\n  }).map(function(x) { return x.v; });\n}",
      "description": "Shallow copies and sorts an array given specific criteria.",
      "params": [
        {
          "name": "array",
          "description": "Array to be sorted.",
          "type": "Array"
        },
        {
          "name": "criteria",
          "description": "Criteria by which a shallow copy of `array` will be sorted.  If a string or an array is supplied it will be used as the path to each individual array element that will be keyed off of to do the sort.",
          "type": "string|Array.<string|number>|Function"
        },
        {
          "name": "opt_comparer",
          "description": "Comparison function used to compare each array element criteria.",
          "type": "Function",
          "optional": true,
          "default": "YourJS.compare"
        }
      ],
      "return": {
        "type": "Array",
        "description": "A shallow copy of the array sorted according to the specified criteria and comparison function."
      },
      "requires": [
        "typeOf",
        "compare"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "sub",
      "code": "function sub(template, opt_subs, opt_funcs) {\n  opt_subs = opt_subs || __GLOBAL;\n  opt_funcs = opt_funcs || YourJS;\n  for (\n    var result;\n    result !== template;\n    template = template.replace(\n      /\\{([\\w\\$]+)(?:\\?((?:\\\\.|[^\\\\\\{\\}:])*):((?:\\\\.|[^\\\\\\{\\}:])*)(?::((?:\\\\.|[^\\\\\\{\\}:])*))?|#([\\w\\$]+))?\\}/ig,\n      function(match, arg, multi, one, none, fn) {\n        if (has(opt_subs, arg)) {\n          arg = opt_subs[arg];\n          if ('function' == typeof arg) {\n            arg = arg(multi, one, none, match);\n          }\n          match = multi === undefined ? arg : (arg == 1 ? one : ((!arg && none !== undefined) ? none : multi));\n          if (fn != undefined) {\n            fn = fn ? opt_funcs[fn] : opt_funcs;\n            if ('function' == typeof fn) {\n              match = fn(match);\n            }\n          }\n        }\n        return match;\n      }\n    )\n  ) {\n    result = template;\n  }\n  return result.replace(/\\\\(\\W)/g, '$1');\n}",
      "description": "Substitute values into strings where the corresponding placeholders have been entered.",
      "params": [
        {
          "name": "template",
          "description": "The string containing placeholders to be filled in and returned. A placeholder must correspond to a value in `opt_subs` and its name must be surrounded in curly braces (eg. `\"Hello {name}!\"` contains the `name` placeholder). If a placeholder refers to a number, a ternary operator can be used (eg. `\"You have {apples} apple{apples?s:}\"`). What appears between the `?` and the `:` will replace the placeholder if the variable before the `?` is not `1`. What appears after the `:` will replace the placeholder if the variable before the `?` is `1`. A 4-ary (AKA quaterary) operator can also be used if a placeholder refers to a number (eg. `\"You have {apples?{apples}:one:no} apple{apples?s:}\"`). When using a 4-ary operator, whatever appears after the second `:` will replace the placeholder if the variable before the `?` is `0`.  If a placeholder is not ternary or 4-ary but ends with `#`, `opt_funcs` will be called on the value and the return value will be used.  If a placeholder is not ternary or 4-ary but ends with `#` followed by a name (eg. `#ordinalize`), the function with that property name under `opt_funcs` will be called for the value and the return value will replace the placeholder.  If a placeholder evaluates to a function the function will be called all of the ternary or 4-ary values as arguments.  Nested expressions are supported.",
          "type": "string"
        },
        {
          "name": "opt_subs",
          "description": "Array or object from which to pull the values to be inserted into `template`.",
          "type": "Array|Object",
          "optional": true,
          "default": "global"
        },
        {
          "name": "opt_funcs",
          "description": "If this is a function it can be used to modify the values filled in within `template`.  If this is an object or an array its properties or array items can be referenced to modify the values filled in within `template`.",
          "type": "Array.<Function>|Object.<Function>|Function",
          "optional": true,
          "default": "YourJS"
        }
      ],
      "return": {
        "type": "string",
        "description": "Returns `template` with all of the valid placeholders filled in with their substitutions as found in `opt_subs`."
      },
      "requires": [
        "has"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "suffix",
      "code": "function suffix(str, strSuffix, opt_rgxTester) {\n  return str == undefined\n    ? function(str) { return suffix(str, strSuffix, opt_rgxTester); }\n    : (opt_rgxTester ? !opt_rgxTester.test(str) : str.slice(-strSuffix.length) != strSuffix)\n      ? str + strSuffix\n      : str;\n}",
      "description": "Always ensures that a string ends with a specific substring.",
      "params": [
        {
          "name": "str",
          "description": "This will be the string to which the suffix will be appended unless the test proves that it doesn't need to be appended.  Specifying `undefined` or `null` will cause a partial function to be returned.",
          "type": "string|undefined|null"
        },
        {
          "name": "strSuffix",
          "description": "This will be the suffix to add to `str` if it needs to be added.",
          "type": "string",
          "optional": false,
          "default": ""
        },
        {
          "name": "opt_rgxTester",
          "description": "Regular expression to test against the string to be suffixed.  If the string tests negative against this regular expression `strSuffix` will be appended to the end of it.",
          "type": "RegExp",
          "optional": true
        }
      ],
      "return": {
        "type": "string|function(string)",
        "description": "If `str` is not given a partial function will be returned which will await the string value of `str`.  If `opt_rgxTester` isn't given, the `str` will be returned and it will be suffixed with `strSuffix` if it isn't already at the end of it.  If `opt_rgxTester` is given and `str` tests negative against it `str` suffixed with `strSuffix` will be returned.  Otherwise `str` will be returned."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var msg1 = 'Hello', msg2 = 'Hello!';\ntest(\n  YourJS.suffix(msg1, '!') + YourJS.suffix(msg2, '!'),\n  'Hello!Hello!'\n);"
        },
        {
          "name": "Partial",
          "code": "var path1 = 'http://google.com', path2 = 'http://bing.com/';\nvar endWithSlash = YourJS.suffix(undefined, '/');\ntest(\n  endWithSlash(path1) + ' ' + endWithSlash(path2),\n  'http://google.com/ http://bing.com/'\n);"
        },
        {
          "name": "RegExp",
          "code": "var msg1 = 'Hello', msg2 = 'Cool!', endWithPunct = YourJS.suffix(undefined, '.', /[!.?]/);\ntest (\n  endWithPunct(msg1) + ' ' + endWithPunct(msg2),\n  'Hello. Cool!'\n);"
        }
      ]
    },
    {
      "name": "sum",
      "code": "function sum(arr) {\n  for (var result = 0, i = arr.length; i--; result += arr[i]) {}\n  return result;\n}",
      "description": "Gets the sum of an array of numbers.",
      "params": [
        {
          "name": "arr",
          "description": "Array of numbers to be summed up.",
          "type": "Array.<number>"
        }
      ],
      "return": {
        "type": "number",
        "description": "Sum of the array of numbers."
      },
      "requires": [],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(YourJS.sum([1,2,3,4,5,6,7,8,9,10]), 55);"
        }
      ]
    },
    {
      "name": "tan",
      "code": "",
      "description": "Determines the tangent of a given number either in radians or in degrees.",
      "params": [
        {
          "name": "angle",
          "description": "The angle whose tangent value should be returned.",
          "type": "number"
        },
        {
          "name": "opt_usingDegrees",
          "description": "If `true` then `angle` will be interpreted in degrees, otherwise `angle` will be interpreted in radians.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "number",
        "description": "The tangent of `angle` in radians by default, but if `opt_usingDegrees` is a `true`-ish value then the tangent of `angle` in degrees will be returned."
      },
      "requires": [
        "sec"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "throttle",
      "code": "function throttle(fn, msBetweenCalls, opt_leading) {\n  var lastTimeCalled = 0,\n      objThis,\n      args,\n      result,\n      timeoutID,\n      leading = opt_leading,\n      trailing = opt_leading != undefined && !opt_leading;\n  function fnThrottled() {\n    lastTimeCalled = new Date;\n    clearTimeout(timeoutID);\n    timeoutID = null;\n    result = fn.apply(objThis, args);\n  }\n  return function() {\n    var now = new Date,\n        msTilAllowed = msBetweenCalls - (now - lastTimeCalled);\n    objThis = this;\n    args = arguments;\n    if (trailing && msTilAllowed <= 0) {\n      msTilAllowed = msBetweenCalls;\n    }\n    msTilAllowed > 0\n      ? leading || timeoutID || (timeoutID = setTimeout(fnThrottled, msTilAllowed))\n      : fnThrottled();\n    return result;\n  };\n}",
      "description": "Creates a throttled version of a function which will only be executable once per every specified wait period.",
      "params": [
        {
          "name": "fn",
          "description": "The function which will esentially be rate-limited.",
          "type": "Function"
        },
        {
          "name": "msBetweenCalls",
          "description": "The amount of time to wait between calls.",
          "type": "number"
        },
        {
          "name": "opt_leading",
          "description": "Indicates whether or not the leading call or the trailing call should be executed. If `false` the trailing call will be made. If `true` the leading call will be made.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "The throttled version of `fn` function."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "titleCase",
      "code": "var titleCase;\n(function(RGX_WORD) {\n  titleCase = function (str, opt_fnFilter) {\n    return str.replace(RGX_WORD, function(word, start, rest, index) {\n      return (!opt_fnFilter || opt_fnFilter(word, index, str) ? start.toUpperCase() : start) + rest;\n    });\n  };\n})(/(\\S)((?:\\B\\S)*)/g);",
      "description": "Capitalizes the first letter of each word in a string. Also commonly known as `toProperCase()`.",
      "params": [
        {
          "name": "str",
          "description": "The string which will be title cased.",
          "type": "string"
        },
        {
          "name": "opt_fnFilter",
          "description": "If specified, this function will be passed every word (along with the position and the original string) and should return `true` if the word should be title cased, otherwise `false` should be returned.",
          "type": "function(string, number, string)",
          "optional": true
        }
      ],
      "return": {
        "type": "string",
        "description": "`str` with all of the 1st letter of each word capitalized (unless filtered out by `opt_fnFilter`)."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "toArray",
      "code": "function toArray(o) {\n  return arguments.length ? isArrayLike(o) ? slice(o) : [o] : [];\n}",
      "description": "Turns anything into an array.",
      "params": [
        {
          "name": "o",
          "description": "Any value to either convert to an array or wrap in an array.",
          "type": "*",
          "optional": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "If no arguments were passed an empty array is returned.  If the argument passed was array-like it will be returned as an `Array`.  Otherwise the argument passed will simply be returned within an array."
      },
      "requires": [
        "isArrayLike",
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "toggle",
      "code": "function toggle(array, valuesToToggle, opt_fnTestEquality) {\n  array = slice(array);\n  valuesToToggle = slice(valuesToToggle);\n  for (var j, i = array.length, valuesCount = valuesToToggle.length; i--;) {\n    for (j = valuesCount; j--;) {\n      if (opt_fnTestEquality ? opt_fnTestEquality(array[i], valuesToToggle[j]) : (array[i] === valuesToToggle[j])) {\n        array.splice(i, 1);\n        valuesToToggle.splice(j, 1);\n        valuesCount--;\n      }\n    }\n  }\n  return array.concat(valuesToToggle);\n}",
      "description": "Toggles values in an array, adding the values that are missing from the array and removing those that are there.",
      "params": [
        {
          "name": "array",
          "description": "The array whose values should be toggled. A copy of this array with the values toggled will be returned.",
          "type": "Array"
        },
        {
          "name": "valuesToToggle",
          "description": "The array of values to either add to (if they are present) or remove from (if they are missing) `array`.",
          "type": "Array"
        },
        {
          "name": "opt_fnTestEquality",
          "description": "If not given strict equality (`===`) will be used to compare values. If specified, this function will be used to determine if two values are equal. The first argument will be the value within `array` to be tested and the second will be the value within `valuesToToggle` to be tested.",
          "type": "Function",
          "optional": true
        }
      ],
      "return": {
        "type": "Array",
        "description": "A duplicate of `array` with the common values of `valuesToToggle` removed and the missing values added."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "var evens = [2,4,6,8], nums = [2,3,4];\ntest(\n  YourJS.toggle(evens, nums).join(','),\n  '6,8,3'\n);"
        }
      ]
    },
    {
      "name": "toString",
      "code": "function toString() {\n  return 'YourJS v' + __VERSION + ' (' + __VARIABLE_NAME + ')';\n}",
      "required": true,
      "description": "Gets the information for this version of YourJS.",
      "return": {
        "type": "string",
        "description": "A quick summary of the YourJS object simply indicating the version and the variable name."
      },
      "params": [],
      "requires": [],
      "tests": []
    },
    {
      "name": "trim",
      "code": "function trim(opt_str, opt_chars) {\n  return opt_str == undefined\n    ? function(str) { return trimLeft(trimRight(str, opt_chars), opt_chars); }\n    : trimLeft(trimRight(opt_str, opt_chars), opt_chars);\n}",
      "description": "Removes all whitespace characters or the specified characters from the beginning of a string.",
      "params": [
        {
          "name": "opt_str",
          "description": "String to return with all whitespace characters or specified characters stripped from the beginning and end of it.",
          "type": "string",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_chars",
          "description": "Characters to remove from the beginning of the string.",
          "type": "string",
          "optional": true,
          "default": "\"\\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\""
        }
      ],
      "return": {
        "type": "Function|string",
        "description": "If `opt_str` is not given a function will be returned that will take one string argument and trim the beginning and end of that string using the characters from `opt_chars`. If `opt_str` is given it will be returned with all leading and trailing characters found in `opt_chars` stripped off."
      },
      "requires": [
        "trimLeft",
        "trimRight"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "trimLeft",
      "code": "function trimLeft(opt_str, opt_chars) {\n  opt_chars = 'string' == typeof opt_chars\n    ? new RegExp('^[' + quoteRegExp(opt_chars) + ']+')\n    : /^[\\t-\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+/;\n  return opt_str == undefined ? function(str) { return str.replace(opt_chars, ''); } : opt_str.replace(opt_chars, '');\n}",
      "description": "Removes all whitespace characters or the specified characters from the beginning of a string.",
      "params": [
        {
          "name": "opt_str",
          "description": "The string to return with all whitespace characters or specified characters stripped from the beginning of it.",
          "type": "string",
          "optional": true,
          "default": "undefined"
        },
        {
          "name": "opt_chars",
          "description": "Characters to remove from the beginning of the string.",
          "type": "string",
          "optional": true,
          "default": "\"\\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\""
        }
      ],
      "return": {
        "type": "Function|string",
        "description": "If `opt_str` is not given a function will be returned that will take one string argument and trim the beginning of that string using the characters from `opt_chars`.  If `opt_str` is given it will be returned with all leading characters found in `opt_chars` stripped off."
      },
      "requires": [
        "quoteRegExp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "trimRight",
      "code": "function trimRight(opt_str, opt_chars) {\n  opt_chars = 'string' == typeof opt_chars\n    ? new RegExp('[' + quoteRegExp(opt_chars) + ']+$')\n    : /[\\t-\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+$/;\n  return opt_str == undefined ? function(str) { return str.replace(opt_chars, ''); } : opt_str.replace(opt_chars, '');\n}",
      "description": "Removes all whitespace characters or the specified characters from the end of a string.",
      "params": [
        {
          "name": "opt_str",
          "description": "The string to return with all whitespace characters or specified characters stripped from the end of it.",
          "type": "string",
          "optional": true
        },
        {
          "name": "opt_chars",
          "description": "Characters to remove from the end of the string.",
          "type": "string",
          "optional": true,
          "default": "\"\\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\""
        }
      ],
      "return": {
        "type": "Function|string",
        "description": "If `opt_str` is not given a function will be returned that will take one string argument and trim the end of that string using the characters from `opt_chars`.  If `opt_str` is given it will be returned with all trailing characters found in `opt_chars` stripped off."
      },
      "requires": [
        "quoteRegExp"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "trunc",
      "code": "function trunc(num) {\n  return Math[num < 0 ? 'ceil' : 'floor'](num);\n}",
      "description": "Only gets the integral part of a number.",
      "params": [
        {
          "name": "num",
          "description": "The number for which only the integral part shall be returned.",
          "type": "number"
        }
      ],
      "return": {
        "type": "number",
        "description": "The integral part of `num` while keeping the sign."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "tryUntil",
      "code": "function tryUntil(fn, opt_timeout, opt_interval) {\n  var start = new Date, iteration = 0, self = this;\n  opt_timeout = opt_timeout == undefined ? Infinity : opt_timeout;\n  opt_interval = opt_interval == undefined ? 100 : opt_interval;\n  function fnWrapper() {\n    try {\n      fn.call(self, ++iteration);\n      return true;\n    }\n    catch (e) {\n      if (new Date - start < opt_timeout) {\n        setTimeout(fnWrapper, opt_interval);\n      }\n      return false;\n    }\n  }\n  return fnWrapper();\n}",
      "description": "Keeps trying to execute a function until it has success or until the timeout is reached.",
      "params": [
        {
          "name": "fn",
          "description": "Function to keep trying to run.",
          "type": "Function"
        },
        {
          "name": "opt_timeout",
          "description": "Amount of milliseconds to wait before giving up on running `fn`.",
          "type": "number",
          "optional": true,
          "default": "Infinity"
        },
        {
          "name": "opt_interval",
          "description": "Amount of milliseconds to wait between each try.",
          "type": "number",
          "optional": true,
          "default": "100"
        }
      ],
      "return": {
        "type": "boolean",
        "description": "`true` is returned if no error is thrown the first time `fn` is called.  Otherwise `false` is returned."
      },
      "requires": [],
      "required": false,
      "tests": []
    },
    {
      "name": "typeOf",
      "code": "var typeOf;\n(function(arrObjectTypes, arrLen) {\n  typeOf = function(value, opt_typeNameToAdd) {\n    var typeName, i;\n    if (opt_typeNameToAdd) {\n      for (i = 0; i < arrLen; i += 2) {\n        if (value === arrObjectTypes[i]) {\n          return false;\n        }\n      }\n      arrLen += 2;\n      arrObjectTypes.push(value, opt_typeNameToAdd);\n      return true;\n    }\n    else {\n      typeName = value == undefined ? value === undefined ? 'undefined' : 'null' : __EMPTY_OBJECT.toString.call(value).slice(8, -1);\n      if (typeName == 'Object') {\n        for (value = value.constructor, i = 0, typeName = 'Unknown'; i < arrLen; i += 2) {\n          if (value === arrObjectTypes[i]) {\n            return arrObjectTypes[i + 1];\n          }\n        }\n      }\n      return typeName;\n    }\n  };\n})([Object,'Object'], 2);",
      "description": "Either gets the type of a value or adds a constructor registering its custom type name.",
      "params": [
        {
          "name": "value",
          "description": "A value whose type name will be returned.  Alternatively if `opt_typeNameToAdd` is passed this must be the constructor for the corresponding type name.",
          "type": "*"
        },
        {
          "name": "opt_typeNameToAdd",
          "description": "If specified, `value` will be looked for within an array of all known constructors and if not found a new entry will be added along with this given type name.",
          "type": "string",
          "optional": true
        }
      ],
      "return": {
        "type": "string|boolean",
        "description": "If `opt_typeNameToAdd` was omitted a string representation of `value`'s type usually capitalized unless `\"null\"` or `\"undefined\"` is returned.  If `opt_typeNameToAdd` is given, the constructor passed as `value` will be searched and a boolean indicating whether or not it needed to be added will be returned."
      },
      "requires": [],
      "tests": [],
      "required": false
    },
    {
      "name": "unbind",
      "code": "function unbind(fn, opt_args) {\n  opt_args = slice(opt_args || []);\n  return function(objThis) {\n    return fn.apply(objThis, opt_args.concat(slice(arguments, 1)));\n  };\n}",
      "description": "Unbinds a value from a function (such as a prototypal function) and creates a wrapper function that when called will use the 1st argument as the bound value.",
      "params": [
        {
          "name": "fn",
          "description": "Function to be unbound.",
          "type": "Function"
        },
        {
          "name": "opt_args",
          "description": "Array of arguments to precede any additionally arguments passed to the returned wrapper function.",
          "type": "Array",
          "optional": true,
          "default": "[]"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A wrapper function which when called will bound the first argument passed to it to `fn` and then pass the rest of the arguments in after any specified in `opt_args`."
      },
      "requires": [
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "wait",
      "code": "function wait(fnReady, opt_clearOrdersAfterReady) {\n  var orders = [], allOrders = [];\n  return function(opt_makeAnOrder, opt_order) {\n    var index;\n    if (opt_makeAnOrder) {\n      orders.push(opt_order);\n      allOrders.push(opt_order);\n    }\n    else {\n      index = orders.findIndex(function(order) {\n        return is(order, opt_order);\n      });\n      if (index >= 0) {\n        orders.splice(index, 1);\n        if (!orders.length) {\n          try {\n            fnReady(slice(allOrders), opt_order);\n          }\n          catch (e) {\n            setTimeout(function(){throw e},0);\n          }\n          if (opt_clearOrdersAfterReady) {\n            allOrders = [];\n          }\n        }\n      }\n    }\n    return !(index < 0);\n  }\n}",
      "description": "Creates a waiter function which takes orders and serves orders in a way and calls a ready function when all orders have been served.",
      "params": [
        {
          "name": "fnReady",
          "description": "Function to be called when the waiter function is has been called to serve the last remaining order.  When called this function will receive all of the orders ever made as the 1st argument and the final order as the 2nd.",
          "type": "Function"
        },
        {
          "name": "opt_clearOrdersAfterReady",
          "description": "If `true`-ish the orders array will be cleared after the `fnReady` function is called.  This prevents previous orders from showing up if `fnReady` is called multiple times.",
          "type": "boolean",
          "optional": true,
          "default": "false"
        }
      ],
      "return": {
        "type": "Function",
        "description": "A waiter function which take and serve orders.  The 1st argument passed to this function should be a boolean indicating that an order is going in.  The 2nd argument passed to this function can be any value that represents an order.  When this function is called a boolean will be returned indicating whether or not the call was successful.  The only way `false` can be returned by this function is if an order is to be served that doesn't exist."
      },
      "requires": [
        "is",
        "slice"
      ],
      "required": false,
      "tests": []
    },
    {
      "name": "dom",
      "code": "var dom;\n(function(RGX_DASH, INNER_TEXT, TEXT_CONTENT, PROP_HASH) {\n  function capAfterDash(m, afterDash) {\n    return afterDash.toUpperCase();\n  }\n  dom = function(input) {\n    var elem, realPropName, propName, propValue, i, l, j, c, style, stylePropName, kids;\n    if (typeOf(input) == 'String') {\n      elem = slice(dom({ _: 'DIV', html: input }).childNodes);\n    }\n    else {\n      elem = __DOCUMENT.createElement(input.nodeName || input._);\n      for (realPropName in input) {\n        propValue = input[realPropName];\n        if (has(input, realPropName) && (propName = has(PROP_HASH, realPropName) ? PROP_HASH[realPropName] : realPropName) != '_') {\n          if (propName == 'style') {\n            style = elem[propName];\n            if (typeOf(propValue) == 'String') {\n              style.cssText = propValue;\n            }\n            else {\n              for (stylePropName in propValue) {\n                if (has(propValue, stylePropName)) {\n                  style[stylePropName.replace(RGX_DASH, capAfterDash)] = propValue[stylePropName];\n                }\n              }\n            }\n          }\n          else if (propName == INNER_TEXT || propName == TEXT_CONTENT) {\n            elem[TEXT_CONTENT] = elem[INNER_TEXT] = propValue;\n          }\n          else if (propName == '$') {\n            propValue = toArray(propValue);\n            for (i = 0, l = propValue.length; i < l;) {\n              for (kids = toArray(dom(propValue[i++])), j = 0, c = kids.length; j < c;) {\n                elem.appendChild(kids[j++]);\n              }\n            }\n          }\n          else {\n            elem[propName] = propValue;\n            if (propName == realPropName && elem.getAttribute(propName) == undefined) {\n              elem.setAttribute(propName, propValue);\n            }\n          }\n        }\n      }\n    }\n    return elem;\n  };\n})(/-([^-])/g, 'innerText', 'textContent',\n  {nodeName:'_',html:'innerHTML',text:'innerText',children:'$','for':'htmlFor','class':'className',cls:'className'});",
      "description": "Creates HTML DOM objects.",
      "params": [
        {
          "name": "input",
          "description": "The value that will be converted to DOM objects.  If a string, it will be interpreted as raw HTML.  Otherwise this must be an object specifying at least the `nodeName` (or `_`) property.  To represent an element with child nodes you can set the `children` (or `$`) property to an `input` object, `input` string, or array of `input` strings and/or objects that will be recursively interpreted.  The `html` property will be interpreted as the `innerHTML` property.  The `text` property will be interpreted ass the `innerText` and `textContent` properties.  The `cls` property will be interpreted as the element's class name.",
          "type": "string|Object"
        }
      ],
      "return": {
        "type": "Array.<Node>|HTMLElement",
        "description": "If `input` was a string an array of nodes represented in that string will be returned.  Otherwise the element represented by `input` will be returned."
      },
      "requires": [
        "has",
        "typeOf",
        "toArray"
      ],
      "required": false,
      "tests": [
        {
          "name": "Simple",
          "code": "test(\n  YourJS.dom({_:'div',$:{nodeName:'div',text:'1>2'}}).innerHTML.toLowerCase(),\n  '<div>1&gt;2</div>'\n);"
        }
      ]
    }
  ]
}